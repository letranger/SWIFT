#+TITLE: SwiftUI v.s. Firebase
#+INCLUDE: ../purpleweb.org
#+HTML_HEAD_EXTRA: <style>*{font-family: Courier New !important}</style>
#+OPTIONS: ^:nil
#+latex:\newpage

* Introduction
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-Intro
:END:
什麼是Firebase？Firebase是由Google收購的子公司，所提供的是行動應用程式開發的平台服務，也就是BaaS(Backend as a Service)，它能夠幫助我們快速開發我們的應用程式，並且支援跨平台包括Android、iOS以及Web，幫我們整合大部分建立一個服務所需要的後台功能。主要像是提供雲端給使用者架起網頁、提供資料庫供使用者存取資料以及做後台分析等等。[fn:1]

Firebase can power your app’s backend, including data storage, user authentication, static hosting, and more. With Firebase, you can easily build mobile and web apps that scale from one user to one million.

** A Brief History[fn:3]
Back in 2011, before Firebase was Firebase, it was a startup called *Envolve*. As Envolve, it provided developers with an API that enabled *the integration of online chat functionality into their website*.

What’s interesting is that people used Envolve to pass application data that was more than just chat messages. Developers were using Envolve to *sync application data* such as a game state in real time across their users.

This led the founders of Envolve, James Tamplin and Andrew Lee, to separate the chat system and the real-time architecture. In April 2012, Firebase was created as a separate company that provided Backend-as-a-Service with real-time functionality.

After it was acquired by Google in 2014, Firebase rapidly evolved into the multifunctional behemoth of a mobile and web platform that it is today.

** With Firebase you can[fn:3]
Firebase helps mobile app teams succeed. With Firebase you can:
1. Build better apps
2. Improve app quality
3. Grow your business
*** Build better apps
Firebase lets you build more powerful, secure and scalable apps, using world-class infrastructure using:
1) Cloud Firestore: is a flexible, scalable database for mobile, web, and server development from Firebase and Google Cloud Platform. It is a *NoSQL document database* that lets you easily *store, sync, and query data* for your mobile and web apps — at a global scale.It's supporting for Android, iOS and Web Platform.
2) ML Kit: is a mobile SDK that brings *Google’s machine learning expertise to Android and iOS apps* in a powerful yet easy-to-use package. Whether you’re new or experienced in machine learning, you can implement the functionality you need in just a few lines of code. There’s no need to have deep knowledge of neural networks or model optimization to get started. On the other hand, if you are an experienced ML developer, ML Kit provides convenient APIs that help you use your custom TensorFlow Lite models in your mobile apps. It’s supporting for Android and iOS Platform.
3) Cloud Functions: for Firebase lets you automatically run backend code in response to events *triggered* by Firebase features and HTTPS requests. Your code is stored in Google’s cloud and runs in a managed environment. There’s no need to manage and scale your own servers. It’s supporting for Android, iOS, C++, Unity and Web Platform.
4) Authentication: provides backend services, easy-to-use SDKs, and ready-made UI libraries to *authenticate users to your app*. It supports authentication using passwords, phone numbers, popular federated identity providers like Google, Facebook and Twitter, and more. It’s supporting for Android, iOS and Web Platform.
5) Hosting: is production-grade web content hosting for developers. *With a single command, you can quickly deploy web apps and serve both static and dynamic content to a global CDN* (content delivery network). You can also pair Firebase Hosting with Cloud Functions to build and host microservices on Firebase. It’s supporting only Web Platform.
6) Cloud Storages: is for *object storage service* built for Google scale. The Firebase SDKs for Cloud Storage add Google security to file uploads and downloads for your Firebase apps, regardless of network quality. You can use our SDKs to store images, audio, video, or other user-generated content. On the server, you can use Google Cloud Storage, to access the same files. It’s supporting for Android, iOS, C++, Unity and Web Platform.
7) Real-time Database: is a cloud-hosted NoSQL database that lets you *store and sync between your users in real-time*. The Real-time Database is really just *one big JSON object* that the developers can manage in real-time. It’s supporting for *Android, iOS, C++, Unity and Web Platform*.

*** Improve app quality
Firebase gives you insights into app performance and stability, so you can channel your resources effectively using:

1) Crashlytics: is *a lightweight, real-time crash reporter* that helps you track, prioritize, and fix stability issues that erode your app quality. Crashlytics saves you troubleshooting time by intelligently grouping crashes and highlighting the circumstances that lead up to them. It’s supporting for Android and iOS Platform.
2) Performance Monitoring: is a service that helps you *to gain insight into the performance characteristics of your iOS and Android apps*. You use the Performance Monitoring SDK to collect performance data from your app, and then review and analyze that data in the Firebase console. Performance Monitoring helps you to understand where and when the performance of your app can be improved so that you can use that information to fix performance issues. It’s supporting for Android and iOS Platform.
3) Test Labs: is a cloud-based app-testing infrastructure. It provides *a large number of mobile test devices* to help you test your apps. It’s supporting for Android and iOS Platform.

*** Grow your business

Firebase helps you grow to millions of users, simplifying user engagement and retention using:

1) In-App Messaging: helps you engage users who are actively using your app by *sending them targeted and contextual messages* that nudge them to complete key in-app actions — like beating a game level, buying an item, or subscribing to content. It’s supporting for Android and iOS Platform.
2) Google Analytics: for Firebase is a free app measurement solution that provides insight on *app usage and user engagement*. At the heart of Firebase is Google Analytics for Firebase, a free and unlimited analytics solution. Analytics integrates across Firebase features and provides you with unlimited reporting for up to 500 distinct events that you can define using the Firebase SDK. Analytics reports help you understand clearly how your users behave, which enables you to make informed decisions regarding app marketing and performance optimizations. It’s supporting for Android, iOS, C++ and Unity Platform.
3) Predictions: applies *machine learning* to your analytics data to create dynamic user segments based on the predicted behavior of users in your app. These predictions are automatically available for use with Firebase Remote Config, the Notifications composer, Firebase In-App Messaging, and A/B Testing. You can also link your app’s Predictions data to BigQuery so you can get daily exports that you can further analyze or push to third party tools. It’s supporting for Android, iOS, C++ and Unity Platform.
4) A/B Testing: helps you optimize your app experience by making it easy to run, analyze, and scale product and marketing experiments. It gives you the power to test changes to your app’s UI, features, or engagement campaigns to see if they actually move the needle on your key metrics (like revenue and retention) before you roll them out widely. It’s supporting for Android, iOS, C++ and Unity Platform.
5) Cloud Messaging(FCM): provides a reliable and battery-efficient connection between your server and devices that allows you to deliver and receive messages and notifications on iOS, Android, and the web at no cost.
6) Remote Config: essentially allows us to publish updates to our users immediately. Whether we wish to change the color scheme for a screen, the layout for a particular section in our app or show promotional/seasonal options — this is completely doable using the server side parameters without the need to publish a new version. It’s supporting for Android, iOS, C++ and Unity Platform.
7) Dynamic Links: With Dynamic Links, your users get the best available experience for the platform they open your link on. If a user opens a Dynamic Link on iOS or Android, they can be taken directly to the linked content in your native app. If a user opens the same Dynamic Link in a desktop browser, they can be taken to the equivalent content on your website. It’s supporting for Android, iOS, Web, C++ and Unity Platform.
8) App Indexing: gets your app into Google Search. If users have your app installed, they can launch your app and go directly to the content they’re searching for. App Indexing reengages your app users by helping them find both public and personal content right on their device, even offering query autocompletion to help them more quickly find what they need. If users don’t yet have your app, relevant queries trigger an install card for your app in Search results. It’s supporting for Android and iOS Platform.

* Firebase database
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-database
:END:
Firebase offers two cloud-based, client-accessible database solutions that support realtime data syncing:

- Cloud Firestore is Firebase's *newest* database for mobile app development. It builds on the successes of the Realtime Database with a *new, more intuitive data model*. Cloud Firestore also features *richer, faster queries* and scales further than the Realtime Database.
- Realtime Database is Firebase's *original* database. It's an efficient, low-latency solution for mobile apps that require synced states across clients in realtime.

** Data model
Both Realtime Database and Cloud Firestore are NoSQL Databases[fn:4].
#+NAME: Realtime Database v.s. Cloud Firestore
|--------------------------------------------------------------+-----------------------------------------------------------------------------------------------------|
| Realtime Database                                            | Cloud Firestore                                                                                     |
| <40>                                                         | <40>                                                                                                |
|--------------------------------------------------------------+-----------------------------------------------------------------------------------------------------|
| Stores data as one large JSON tree.                          | Stores data as collections of documents.                                                            |
| - Simple data is very easy to store.                         | - Simple data is easy to store in documents, which are very similar to JSON.                        |
| - Complex, hierarchical data is harder to organize at scale. | - Complex, hierarchical data is easier to organize at scale, using subcollections within documents. |
|                                                              | - Requires less denormalization and data flattening.
|--------------------------------------------------------------+-----------------------------------------------------------------------------------------------------|

* Cloud Firestore Data model
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-datamodel
:END:
Cloud Firestore is a NoSQL, document-oriented database. Unlike a SQL database, there are no tables or rows. Instead, you store data in *documents*, which are organized into *collections*.

Each document contains a set of key-value pairs. Cloud Firestore is optimized for storing large collections of small documents.

All documents must be stored in collections. Documents can contain subcollections and nested objects, both of which can include primitive fields like strings or complex objects like lists.

Collections and documents are created implicitly in Cloud Firestore. Simply assign data to a document within a collection. If either the collection or document does not exist, Cloud Firestore creates it.

** Documents
In Cloud Firestore, the unit of storage is the document. A document is a lightweight record that contains fields, which map to values. Each document is identified by a name.

A document representing a user alovelace might look like this:
#+BEGIN_SRC
first : "Ada"
last : "Lovelace"
born : 1815
#+END_SRC

Complex, *nested objects in a document* are called *maps*. For example, you could structure the user's name from the example above with a map, like this:

#+BEGIN_SRC
name :
    first : "Ada"
    last : "Lovelace"
born : 1815
#+END_SRC

You may notice that documents *look a lot like JSON*. In fact, *they basically are*. There are some differences (for example, documents support extra data types and are limited in size to 1 MB), but in general, you can treat documents as lightweight JSON records.

** Collections
Documents live in collections, which are simply containers for documents.
#+CAPTION: Cloud Firestore data model
#+LABEL:fig:FirestoreDatModel
#+name: fig:FirestoreDatModel
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/structure-data.png]]
For example, you could have a users collection to contain your various users, each represented by a document:
#+BEGIN_SRC
collections_bookmark users

    alovelace

    first : "Ada"
    last : "Lovelace"
    born : 1815

    aturing

    first : "Alan"
    last : "Turing"
    born : 1912
#+END_SRC
Cloud Firestore is schemaless, so you have complete freedom over what fields you put in each document and what data types you store in those fields. Documents within the same collection can all contain different fields or store different types of data in those fields. However, it's a good idea to use the same fields and data types across multiple documents, so that you can query the documents more easily.

A collection contains documents and nothing else. It can't directly contain raw fields with values, and it can't contain other collections. (See Hierarchical Data for an explanation of how to structure more complex data in Cloud Firestore.)

The names of documents within a collection are unique. You can provide your own keys, such as user IDs, or you can let Cloud Firestore create random IDs for you automatically.

You do not need to "create" or "delete" collections. After you create the first document in a collection, the collection exists. If you delete all of the documents in a collection, it no longer exists.

** References
Every document in Cloud Firestore is *uniquely identified* by its location within the database. The previous example showed a document alovelace within the collection users. To refer to this location in your code, you can create a reference to it.
#+begin_src swift -r -n :results output :exports nil
let alovelaceDocumentRef = db.collection("users").document("alovelace")
#+end_src

A reference is *a lightweight object that just points to a location in your database*. You can create a reference *whether or not data exists there*, and creating a reference does not perform any network operations.

You can also create references to collections:
#+begin_src swift -r -n :results output :exports nil
let usersCollectionRef = db.collection("users")
#+end_src

** Supported data types
|-----------------------+------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Data type             | Sort order                                                             | Notes                                                                                                                                                         |
| <20>                  | <40>                                                                   | <40>                                                                                                                                                          |
|-----------------------+------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Array                 | By element values                                                      | An array cannot contain another array value as one of its elements.                                                                                           |
| Boolean               | false < true                                                           |                                                                                                                                                               |
| Bytes                 | Byte order                                                             | Up to 1,048,487 bytes (1 MiB - 89 bytes). Only the first 1,500 bytes are considered by queries.                                                               |
| Data and time         | Chronological                                                          | When stored in Cloud Firestore, precise only to microseconds; any additional precision is rounded down.                                                       |
| Floating-point-number | Numeric                                                                | 64-bit double precision, IEEE 754.                                                                                                                            |
| Geographical point    | By latitude, then longitude                                            |                                                                                                                                                               |
| Integer               | Numeric                                                                | 64-bit, signed                                                                                                                                                |
| Map                   | By keys, then by value                                                 | Key ordering is always sorted. For example, if you write {c: "foo", a: "bar", b: "qux"} the map is sorted by key and saved as {a: "bar", b: "qux", c: "foo"}. |
| Null                  | None                                                                   |                                                                                                                                                               |
| Reference             | By path elements (collection, document ID, collection, document ID...) | For example, projects/[PROJECT_ID]/databases/[DATABASE_ID]/documents/[DOCUMENT_PATH].                                                                         |
| Text string           | UTF-8 encoded byte order                                               | Up to 1,048,487 bytes (1 MiB - 89 bytes). Only the first 1,500 bytes of the UTF-8 representation are considered by queries.                                   |
|-----------------------+------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------|

** Index types in Cloud Firestore
Indexes are an important factor in the performance of a database. Much like the index of a book which maps topics in a book to page numbers, a database index maps the items in a database to their locations in the database. When you send a database a query, the database can use an index to quickly look up the locations of the items you requested.

This page describes the two types of indexes that Cloud Firestore uses, single-field indexes and composite indexes.

*** An index behind every query

If no index exists for a query, most databases crawl through their contents item by item, a slow process that slows down even more as the database grows. Cloud Firestore guarantees high query performance by using indexes for all queries. As a result, query performance depends on the size of the result set and not on the number of items in the database.

*** Less index management, more app development
Cloud Firestore includes features that reduce the amount of time you need to spend managing indexes. The indexes required for the most basic queries are automatically created for you. As you use and test your app, Cloud Firestore helps you identify and create additional indexes your app requires.

*** Automatic indexing

By default, Cloud Firestore automatically maintains single-field indexes for each field in a document and each subfield in a map. Cloud Firestore uses the following default settings for single-field indexes:
- For each non-array and non-map field, Cloud Firestore defines two collection-scope single-field indexes, one in ascending mode and one in descending mode.
- For each map field, Cloud Firestore creates one collection-scope ascending index and one descending index for each non-array and non-map subfield in the map.
- For each array field in a document, Cloud Firestore creates and maintains a collection-scope array-contains index.
- Single-field indexes with collection group scope are not maintained by default.

* Create your own Cloud Firestore database
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-CreateDatabase
:END:
1. Sign in https://firebase.google.com
2. Click Get started
3. Two mode of Firebase web navigation
   - console
   - docs: 讀doc破萬卷、寫code如有神
4. Create project
5. Create a Cloud Firestore database
   1) If you haven't already, create a Firebase project: In the Firebase console, click *Add project*, then follow the on-screen instructions to create a Firebase project or to add Firebase services to an existing GCP project.
   2) Navigate to the *Cloud Firestore section* of the *Firebase console*. You'll be prompted to select an existing Firebase project. Follow the database creation workflow.
   3) Select a starting mode for your Cloud Firestore Security Rules:
      - Locked mode
        Denies all reads and writes from mobile and web clients. Your authenticated application servers (C#, Go, Java, Node.js, PHP, Python, or Ruby) can still access your database.
        #+begin_src swift -r -n :results output :exports nil
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
        #+end_src
        To get started with the C#, Go, Java, Node.js, PHP, Python, or Ruby server client library, select locked mode.Select a location for you database.
      - Test mode
        *Good for getting* started with the mobile and web client libraries, but allows *anyone* to read and overwrite your data. *After testing, make sure to review the Secure your data section*.
        #+begin_src swift -r -n :results output :exports nil
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if
          request.time < timestamp.date(2021, 4, 15);
    }
  }
}
        #+end_src
        To get started with the web, iOS, or Android SDK, select test mode.
   4) Select a location for your database.
      This location setting is your project's default Google Cloud Platform (GCP) resource location. Note that this location will be used for GCP services in your project that require a location setting, specifically, your default Cloud Storage bucket and your App Engine app (which is required if you use Cloud Scheduler).
      If you aren't able to select a location, then your project already has a default GCP resource location. It was set either during project creation or when setting up another service that requires a location setting.
   5) done
6. Create your own collection in your database
   You can create multiple collections in one database
7. Why you should switch to english mode when reading Firebase Web pages?

* Adding Firebase to your iOS project
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-AddFirebase
:END:
** key process
1. Create a FIrebase project [DONE]
2. Register your app with Firebase
3. Add a Firebase configuration file
4. Add Firebase SDKs to your app
5. Initialize Firebase in your app
詳組說明參見[[https://firebase.google.com/docs/ios/setup][Firebase Documentation]]

** Setting up Firebase project: Step by step
1. Create or open a Firebase project
   Firebase Console: https://console.firebase.google.com/
2. Add Firebase to your iOS app
   1) Register app
      - iOS bundle ID
      - App nickname (optional)
      - App Store ID (optional)
   2) Download config file
      this config file (GoogleService-info.plist) will be added to your project
3. Add Firebase SDKs
   1) Create a Podfile
      a. open Terminal app
      b. switch to Xcode folder (xcodeproj location)
         #+BEGIN_SRC bash
cd ~/Desktop/ProjectName
         #+END_SRC
      c. Create Podfile (terminal command)
         Create Podfile
         #+BEGIN_SRC bash
pod init
         #+END_SRC
   2) Edit Podfile
      a. Open your Podfile (terminal command)
         #+BEGIN_SRC bash
open Podfile
         #+END_SRC
         or use text editor to open Podfile
      b. Add the following code to Podfile (target(iOS))
         #+BEGIN_SRC bash
# Uncomment the next line to define a global platform for your project
# platform :ios, '9.0'

target 'FirebaseTask' do
  # Comment the next line if you don't want to use dynamic frameworks
  use_frameworks!

  # Pods for FirebaseTask
  # the Firebase module your project need
  pod 'Firebase'
  pod 'Firebase/Firestore'
  pod ‘Firebase/Analytics’
  pod 'FirebaseFirestoreSwift'
end

         #+END_SRC
         edit and save
      c. save Podfile
         cmd+S or via menu File/Save
   3) Install Firebase SDK by pod install (terminal command)
      #+BEGIN_SRC bash
pod install
      #+END_SRC
      and then wait......
4. Open your project (xcworkspace)
5. add config file (GoogleService-info.plist) to your project
6. Add initialization code
   #+begin_src swift -r -n :results output :exports nil
import Firebase
   #+end_src
   Initilize the App struct by adding the following code
   #+begin_src swift -r -n :results output :exports nil
import SwiftUI
import Firebase
@main
struct FirebaseTaskApp: App {
    // configure Firebase database
    init() {
        FirebaseApp.configure()
    }
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
   #+end_src

** 資料來源
- [[https://1998design.medium.com/%E5%A6%82%E4%BD%95-%E5%B0%87firebase%E5%8A%A0%E5%85%A5ios-swiftui-2-2020-d4315d0173ca][如何：將Firebase加入iOS SwiftUI 2 (2020)]]

* Basic operations to Firebase with iOS
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-BasicOperations
:END:
Create a button on View for trying the following function
** Add document
*** create a document with specific document ID
- setData
  #+begin_src swift -r -n :results output :exports nil
store.collection("tasks").document().setData(documentData: [String : Any])
  #+end_src
- setData and catch error
  #+begin_src swift -r -n :results output :exports nil
store.collection("tasks").document().setData(documentData: [String : Any]) {
    err in
    if let err = err {
        print("Error writing document: \(err)")
    } else {
        print("Document successfully written!")
    }
}

  #+end_src
- 範例
  ContentView.swift
  #+begin_src swift -r -n :results output :exports nil
//  Created by yen yung chin on 2021/3/17.
import SwiftUI
import Firebase

struct ContentView: View {
    var body: some View {
        let store = Firestore.firestore()
        Button(action: {
            store.collection("tasks").document("new").setData(["title" : "testing setData()", "completion" : true])
        }, label: {
            Text("New Task")
        })
    }
}
 #+end_src
- Question: What happen if you try to repeat clicking button to add document with the same ID
*** create a document with auto-generate document ID
- addDocument()
  #+begin_src swift -r -n :results output :exports nil
store.collection("tasks").addDocument(data: [String : Any]>)
  #+end_src
- add document and catch error
  #+begin_src swift -r -n :results output :exports nil
//  Created by yen yung chin on 2021/3/17.
store.collection().addDocument(data) { err in
    if let err = err {
        print("Error adding document: \(err).")
    } else {
        print("Adding Document successfully.")
    }
}
  #+end_src
- 範例
  ContentView.swift
#+begin_src swift -r -n :results output :exports nil
//  Created by yen yung chin on 2021/3/17.
import SwiftUI
import Firebase

struct ContentView: View {
    var body: some View {
        let store = Firestore.firestore()
        Button(action: {
                store.collection("tasks").addDocument(data: ["title": "222", "completion" : false]) { err in
                if let err = err {
                    print("Error adding document: \(err).")
                } else {
                    print("Adding Document successfully.")
                }
            }
        }, label: {
            Text("New Task")
        })
    }
}
#+end_src

** Get data from Cloud Firestore: Basic
*** Getting collection
- 語法
  #+begin_src swift -r -n :results output :exports nil

  #+end_src
- 範例
    ContentView.swift
  #+begin_src swift -r -n :results output :exports nil
//  Created by yen yung chin on 2021/3/17.
//

import SwiftUI
import Firebase

struct ContentView: View {
    var body: some View {
        let store = Firestore.firestore()
        Button(action: {
            store.collection("tasks").getDocuments { (querySnapshot, error) in
                if let querySnapshot = querySnapshot {
                    for document in querySnapshot.documents {
                        print(document.data())
                    }
                }
            }
        }, label: {
            Text("Button")
        })
    }
}
  #+end_src
*** Getting document
- 語法
  #+begin_src swift -r -n :results output :exports nil
let docRef = db.collection().document()
docRef.getDocument(source: .cache) { (document, error) in
    if let document = document {
        let dataDescription = document.data().map(String.init(describing:)) ?? "nil"
        print("Cached document data: \(dataDescription)")
    } else {
        print("Document does not exist in cache")
    }
}
  #+end_src
- 範例
  ContentView.swift
  #+begin_src swift -r -n :results output :exports nil
//  Created by yen yung chin on 2021/3/17.
//

import SwiftUI
import Firebase

struct ContentView: View {
    var body: some View {
        let store = Firestore.firestore()
        Button(action: {
            let docRef = store.collection("tasks").document("new")
            docRef.getDocument { (document, error) in
                if let document = document, document.exists {
                    let dataDescription = document.data().map(String.init(describing: )) ?? "nil"
                    print("Document data: \(dataDescription)")
                } else {
                    print("Document does not exist")
                }
            }
        }, label: {
            Text("Button")
        })
    }
}
  #+end_src
***

* Get data from Cloud: UI with Firebase [MVVM]
** MVVM architecture
#+CAPTION: MVVM for FirebaseApp
#+LABEL:fig:MVVM-d2
#+name: fig:MVVM-d2
#+ATTR_LATEX: :width 500
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 500
[[file:images/mvvm-d2.png]]
** Model
Task.swift
#+begin_src swift -r -n :results output :exports nil
import Foundation
import FirebaseFirestore
import FirebaseFirestoreSwift

struct Task: Identifiable, Codable {
    @DocumentID var id: String?
    var title: String
    var completion: Bool
}

#+end_src
** View
TaskListView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct TaskListView: View {
    @ObservedObject var taskListVM = TaskListViewModel()
    var body: some View {
        VStack {
            List(taskListVM.taskCellViewModels) { taskCellVM in
                Text("\(taskCellVM.task.title)")
            }
        }
    }
}
#+end_src
** ViewModel
- TaskCellViewModel.swift
  #+begin_src swift -r -n :results output :exports nil
import Foundation
import Combine

class TaskCellViewModel: ObservableObject, Identifiable {
    @Published var task: Task

    private var cancellables = Set<AnyCancellable>()
    var id = ""

    init(task: Task) {
        self.task = task
        $task
            .compactMap { $0.id }
            .assign(to: \.id, on: self)
            .store(in: &cancellables)
    }

}

  #+end_src
- TaskListViewModel.swift
  #+begin_src swift -r -n :results output :exports nil
import Foundation
import Combine

class TaskListViewModel: ObservableObject {
    @Published var taskRepository = TaskRepository()
    @Published var taskCellViewModels = [TaskCellViewModel]()

    private var cancellables = Set<AnyCancellable>()
    init() {
        taskRepository.loadData()

        taskRepository.$tasks.map { tasks in
            tasks.map(TaskCellViewModel.init)
        }
        .assign(to: \.taskCellViewModels, on: self)
        .store(in: &cancellables)
    }
}

  #+end_src
** Repository
TaskRepository.swift
#+begin_src swift -r -n :results output :exports nil

import Foundation
import FirebaseFirestore
import FirebaseFirestoreSwift
import Combine

class TaskRepository: ObservableObject {
    private let db = Firestore.firestore()
    @Published var tasks = [Task]()

    func loadData() {
        db.collection("tasks").addSnapshotListener { (querySanpshot, error) in

            if let error = error {
                print("錯誤: \(error.localizedDescription)")
            }
            // method #1
            self.tasks = querySanpshot?.documents.compactMap { document in
                try? document.data(as: Task.self)
            } ?? []

            // method #2
            if let querySnapshot = querySanpshot {
                self.tasks = querySnapshot.documents.compactMap({ (queryDocumentSnapshot) -> Task? in
                    return try? queryDocumentSnapshot.data(as: Task.self)
                })
            }
        }
    }
}


#+end_src

** 資料來源
- [[https://www.raywenderlich.com/11609977-getting-started-with-cloud-firestore-and-swiftui][Getting Started with Cloud Firestore and SwiftUI]]
- [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%AE%80%E5%8F%96-cloud-firestore-%E7%9A%84-database-203bdcdb5661][讀取 Cloud Firestore 的 database]]
- [[https://cloud.google.com/firestore/docs/query-data/get-data][Getting data]]
- [[https://medium.com/彼得潘的-swift-ios-app-開發問題解答集/利用-firebasefirestoreswift-將-firestore-的資料變成自訂型別-89f33c852018][利用 FirebaseFirestoreSwift 將 Firestore 的資料變成自訂型別]]
- [[https://peterfriese.dev/swiftui-firebase-codable/][SwiftUI: Mapping Firestore Documents using Swift Codable]]
- [[https://peterfriese.dev/swiftui-firebase-fetch-data/][SwiftUI: Fetching Data from Firestore in Real Time]]

* Learning resources
:PROPERTIES:
:CUSTOM_ID: SW-Firebase-LearningResource
:END:
** web
- [[https://medium.com/flawless-app-stories/how-to-build-a-firebase-app-with-swiftui-5919d2d8a396][How To Build A Firebase App With SwiftUI]]
- [[https://benmcmahen.com/authentication-with-swiftui-and-firebase/][Using Firebase Authentication with SwiftUI]]
** Videos
- [[https://www.youtube.com/watch?v=4RUeW5rUcww][Building a to-do list app with SwiftUI and Firebase - Part 1]]
- [[https://www.youtube.com/watch?v=2k6_Mi2ERWc][Building a Todo List App Using Firebase and SwiftUI - Part 2 ]]
- [[https://www.youtube.com/watch?v=HDde7TqKCpk][Build a to-do list app w/ SwiftUI & Firebase - Pt 2: Firestore & Anonymous Auth]]
- https://www.youtube.com/watch?v=elhzkcoBl-A
- https://www.youtube.com/watch?v=9VpaaJ3eLWk&list=PLY_qIufNHc292EYDwe3B6sGYO_vQ7pOLx&index=8
- https://www.hackingwithswift.com/books/ios-swiftui/creating-a-form
- https://www.youtube.com/watch?v=1QcekWFK2d8

* Footnotes

[fn:4] [[https://firebase.google.com/docs/firestore/rtdb-vs-firestore][Choose a database: Cloud Firestore or Realtime Database]]

[fn:3] [[https://medium.com/codingurukul/introduction-to-firebase-f9f6ccc8a785][Introduction to Firebase]]

[fn:1] [[https://medium.com/ho-japan/%E5%89%8D%E7%AB%AF%E4%BA%BA%E7%9A%84%E6%95%91%E6%98%9Ffirebase%E7%9A%84%E7%94%A8%E9%80%94%E8%88%87%E5%AF%A6%E4%BD%9Ctodolist-c7af49fe3104][前端工程師的救星，Firebase的簡介與實作TodoList]]
