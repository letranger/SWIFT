#+TITLE: SwiftUI
#+INCLUDE: ../purpleweb.org
#+latex:\newpage

* iOS app çš„é–‹ç™¼ç•Œé¢: UIKit v.s. SwiftUI
:PROPERTIES:
:CUSTOM_ID: SW-UIKIT-SWIFTUI
:END:
** UIKit èˆ‡ SwiftUI çš„å·®ç•°æ€§
*** ç³»çµ±éœ€æ±‚
UIKit æ˜¯å¾ Xcode1 å°±ä¸€ç›´å­˜åœ¨çš„ Frameworkï¼›è€Œ SwiftUI å‰‡æ˜¯ 2019/6 WWDC æ‰€ç™¼è¡¨çš„å…¨æ–°ç”¨ä¾†ç¹ªè£½ UI çš„ Frameworkã€‚å› æ­¤ï¼ŒSwiftUI å¿…é ˆæ­é… iOS13+ å’Œ MacOS10.15+ã€‚[fn:1]
*** åº•å±¤èªè¨€
UIKit åº•å±¤ä»ç‚º Objecitve-Cï¼›è€Œ SwiftUI å‰‡æ˜¯å®Œå®Œå…¨å…¨ç”¨ Swift æ‰“é€ çš„ Frameworkã€‚
*** èªæ³•ç°¡æ½”åº¦
SwiftUI ç”¢ç”Ÿä¸€é¡¯ç¤ºæ–‡å­—çš„å…ƒä»¶æ›´ç²¾ç°¡æ½”äº†ã€‚
*** Declarative vs Imperative Programming
- imperative programmingï¼šå‘Šè¨´é›»è…¦å¦‚ä½•åš(HOW)ä¾†å¾—åˆ°æˆ‘å€‘æƒ³è¦çš„çµæœ(WHAT)ï¼Œå¦‚ Java, C++, PHP, C#, Swift
- declarative programmingï¼šå‘Šè¨´é›»è…¦æˆ‘å€‘æƒ³è¦çš„çµæœ(WHAT)ï¼Œè®“é›»è…¦æ±ºå®šå¦‚ä½•åš(HOW)ï¼Œå¦‚ SwiftUI

*** è·¨å¹³å°
è·¨å¹³å°æŒ‡çš„éè·¨ Android(ä½†å¸Œæœ›æœ‰é‚£éº¼ä¸€å¤©æ˜¯å¯ä»¥æ”¯æ´çš„ğŸ˜€)ã€‚è·¨å¹³å°æŒ‡çš„æ˜¯ä½¿ç”¨ SwiftUI æ‰€é–‹ç™¼çš„å°ˆæ¡ˆï¼Œå¯ä»¥åŒæ™‚æ”¯æ´ macOSã€watchOSã€tvOS ç­‰ç³»çµ±ã€‚å¼•ç”¨ä¸€å¥ WWDC2019 SwiftUI æ¼”è¬›è€…æ‰€èªªçš„ä¸€å¥è©±ã€‚
#+BEGIN_QUOTE
Learn once, apply everywhere.
#+END_QUOTE
*** Automatic Preview
é€™æ˜¯æ­¤æ¬¡ SwiftUI æœ€å¤§çš„äº®é»ä¹‹ä¸€ï¼Œæ‰€è¬‚ Automatic Previewï¼Œæ„æ€æŒ‡çš„æ˜¯å³æ™‚é è¦½ï¼Œå³æˆ‘å€‘ä¸€é‚Šèª¿æ•´ç¨‹å¼ç¢¼çš„åŒæ™‚ï¼Œä¹Ÿå¯ä»¥ç«‹å³çœ‹åˆ°ä¿®æ”¹å¾Œçš„çµæœã€‚
*** è‡ªå‹•æ”¯æ´é€²éšåŠŸèƒ½
SwiftUI æœ¬èº«å³æ”¯æ´ Dynamic Typeã€Dark Modeã€ Localization ç­‰ç­‰ã€‚é€™é‚Šç‰¹åˆ¥ä¾†è¬›ä¸€ä¸‹ UIKit å’Œ SwiftUI åœ¨æ–‡å­—è¨­å®šä¸Šæœ‰é—œæ–¼ Dark Mode çš„å·®ç•°ï¼ŒUIKit è‹¥æ˜¯ç„¡ç‰¹åˆ¥æŒ‡å®šæ–‡å­—çš„é¡è‰²(æ„å³ä½¿ç”¨ Default çš„é¸é …)ï¼Œåœ¨ Light Mode å­—é«”æœƒæ˜¯ç™½è‰²ï¼›ç›¸å°çš„åœ¨ Dark Mode å³æœƒæ˜¯ç™½è‰²ï¼Œé€™é»è·Ÿ SwiftUI æ²’æœ‰ç‰¹åˆ¥çš„å·®ç•°ï¼Œä½†æ˜¯ SwiftUI é™¤äº† Default å¤–ï¼Œé‚„æœ‰ Secondaryï¼Œå¦‚æœé‚„ä¸å–œæ­¡çš„è©±ï¼Œé‚„æœ‰ç¬¬ä¸‰å€‹é¸é …ï¼Œå°±æ˜¯åœ¨ Assets è‡ªè¡Œè¨­å®š Light Mode å’Œ Dark Mode åˆ†åˆ¥è¦é¡¯ç¤ºçš„é¡è‰²ã€‚
#+CAPTION: UIKit èˆ‡ SwiftUI çš„å·®ç•°æ€§æ¯”è¼ƒåœ–
#+LABEL:fig:Diff-1
#+name: fig:Diff-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/differences.png]]
** SwiftUI vs UIKit: Benefits and Drawbacks
*** Drawbacks of SwiftUI [fn:2]
- It supports only iOS 13 and Xcode 11. By switching to them, you abandon users of older versions of iOS, which is a radical move devoid of concern for the user. But since Apple annually updates its list of supported iOS versions, I think SwiftUI will be used more over the next two years as users install the latest iOS version.
- Itâ€™s still very young, so there isnâ€™t much data on [[https://stackoverflow.com/][Stack Overflow]]. This means that you canâ€™t get much help resolving complicated issues.
- It doesnâ€™t allow you to examine the view hierarchy in Xcode Previews.
*** Benefits of SwiftUI [fn:2]
- Itâ€™s easy to learn, and the code is simple and clean.
- It can be mixed with UIKit using UIHostingController.
- It allows you to easily manage themes. Developers can easily add dark mode to their apps and set it as the default theme, and users can easily enable dark mode. Besides, it looks awesome.
- SwiftUI provides mechanisms for reactive programming enthusiasts with BindableObject, ObjectBinding, and the whole Combine framework.
- It offers Live Preview. This is a very convenient and progressive way to see the results of code execution in real time without having to build. Iâ€™m not sure if it somehow affects the processor. So far, Iâ€™ve noticed a delay provoked by the use of Live Preview, but I think Apple will soon make improvements.
- SwiftUI no longer needs Interface Builder. It was replaced by Canvas, an interactive interface editor. When writing code, the visual part in Canvas is automatically generated, and when you create visual presentation elements, they automatically appear in the code.
- Your application will no longer crash if you forget to update the @IBOutlet association with the variable.
- Thereâ€™s no AutoLayout or related problems. Instead, you use things like HStack, VStack, ZStack, Groups, Lists, and more. Unlike AutoLayout, SwiftUI always produces a valid layout. Thereâ€™s no such thing as an ambiguous or unsatisfiable layout. SwiftUI replaces storyboards with code, making it easy to create a reusable view and avoid conflicts related with the simultaneous use of one project by the development team.

  #+latex:\newpage
* AppDelegate v.s. SceneDelegate
:PROPERTIES:
:CUSTOM_ID: delegate
:END:
- AppDelegate åŸä¾†çš„è·è²¬ç‚ºè² è²¬ App çš„ç”Ÿå‘½é€±æœŸå’Œ UI ç”Ÿå‘½é€±æœŸï¼Œåœ¨ Xcode11 å¾Œï¼ŒAppDelegate å°‡ UI çš„ç”Ÿå‘½é€±æœŸ(Scene Session)äº¤çµ¦ SceneDelegateã€‚åŸ Xcode10
- ä½¿ç”¨ Swift ç‚º User Interface çš„å°ˆæ¡ˆ Launch çš„ç”Ÿå‘½é€±æœŸç‚º AppDelegate â†’ ViewControllerï¼Œè€Œä½¿ç”¨ SwiftUI ç‚º User Interface çš„å°ˆæ¡ˆå‰‡è®Šæˆç‚º AppDelegate â†’ SceneDelegate â†’ ContentViewï¼ŒåŸæœ¬æ‡‰è©²å‡ºç¾åœ¨ AppDelegate çš„ applicationWillEnterForeground(_:) ç­‰ç›¸é—œ App åˆ°å‰ã€èƒŒæ™¯ç­‰ç›¸é—œçš„ç”Ÿå‘½é€±æœŸé‚è¼¯ä¹Ÿéƒ½ç§»è‡³ SceneDelegate è£¡äº†ï¼Œmethod åç¨± application çš„å‰ç¶´å­—ä¹Ÿéƒ½æ›´æ”¹ç‚º scene äº†ã€‚[fn:3]

** SceneDelegate.swift
#+BEGIN_SRC swift -r -n
import UIKit
import SwiftUI

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).

        // Create the SwiftUI view that provides the window contents.
        let contentView = ContentView()

        // Use a UIHostingController as window root view controller.
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not neccessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
    }
}

struct SceneDelegate_Previews: PreviewProvider {
    static var previews: some View {
        /*@START_MENU_TOKEN@*/Text("Hello, World!")/*@END_MENU_TOKEN@*/
    }
}
#+END_SRC
#+latex:\newpage
* UIKit
:PROPERTIES:
:CUSTOM_ID: SW-UIKIT-SWIFTUI
:END:
DEMO
#+latex:\newpage
* SwiftUI
:PROPERTIES:
:CUSTOM_ID: SW-SWIFTUI-INTRO
:END:
** æ•™å­¸å½±ç‰‡
- [[https://www.youtube.com/watch?v=VlhcNR7Qrno][Your First SwiftUI App (Full Compilation!)]]
- [[https://www.youtube.com/watch?v=jbtqIBpUG7g][Lecture 1: Course Logistics and Introduction to SwiftUI]]: Stanford University CS193p
- [[https://www.youtube.com/watch?v=4GjXq2Sr55Q&t=5254s][Lecture 2: MVVM and the Swift Type System]]
- [[https://www.youtube.com/watch?v=uUMWEu2YJew&list=PLuoeXyslFTuZRi4q4VT6lZKxYbr7so1Mr][SwiftUI by Paul Hudson: Play All]]
- [[https://www.youtube.com/watch?v=uUMWEu2YJew][Understanding the basic structure of a SwiftUI app â€“  WeSplit SwiftUI Tutorial 1/10]]
- [[https://www.youtube.com/watch?v=BB3Gi4CGKrA][Creating a form â€“ WeSplit SwiftUI Tutorial 2/10]]
- [[https://www.youtube.com/watch?v=K5628N_vTCs][Pushing new views onto the stack using NavigationLink â€“ Moonshot SwiftUI Tutorial 3/10]]
- [[https://www.youtube.com/watch?v=46vqD5OPdys][Modifying program state â€“ WeSplit SwiftUI Tutorial 4/10]]
- [[https://www.youtube.com/watch?v=IG1os9XXNiI&list=PLuoeXyslFTuZRi4q4VT6lZKxYbr7so1Mr&index=5][Binding state to user interface controls â€“ WeSplit SwiftUI Tutorial 5/10]]
- [[https://www.youtube.com/watch?v=JGlWrqMbizI][SwiftUI - Calculator Demo from Stanford iOS Course Part 1 of 2]]
- [[https://www.youtube.com/watch?v=cjrAWGcpwJM][The Calculator (part 1) - Learn Swift UI]]
- [[https://www.youtube.com/watch?v=cbqMkIG6Qeg][Understanding MVVM Design Pattern]]: è¬›çš„è¶…æ¸…æ¥š
- [[https://www.youtube.com/user/azamsharp/videos][azamsharp SwiftUI Videos]]
- [[https://www.youtube.com/watch?v=nc-n5Gc8wN0][ç³»åˆ—: Setting up - SwiftUI Starter Project 1/14]]
** ä½¿ç”¨ SwiftUI é–‹å•Ÿæ–°å°ˆæ¡ˆ [fn:3]
1) é¦–å…ˆï¼Œæ‰“é–‹ Xcodeï¼Œä¸¦é»æ“Š Create new Xcode projectã€‚åœ¨ iOS ä¹‹ä¸‹é¸æ“‡ Single View Appï¼Œä¸¦ç‚ºå°ˆæ¡ˆå‘½åã€‚
2) ç„¶å¾Œåœ¨ä¸‹æ–¹å‹¾é¸ Use SwiftUI çš„é¸é …ï¼Œå¦‚æœæ²’æœ‰å‹¾é¸è©²é¸é …çš„è©±ï¼ŒXcode æœƒè‡ªå‹•ç”¢ç”Ÿ storyboard æª”æ¡ˆ(UIKit)ã€‚
3) Xcode æœƒè‡ªå‹•å¹«ä½ å‰µå»ºä¸€å€‹åç‚º ContentView.swif çš„æª”æ¡ˆï¼ŒXcode æœƒåœ¨ç¨‹å¼ç¢¼çš„å³é‚Šå‘ˆç¾ä¸€å€‹å³æ™‚çš„é è¦½è¦–çª—(preview), é»é¸ resume éˆ•ç”Ÿæˆé è¦½ç•«é¢(æœƒèŠ±ä¸€é»æ™‚é–“)ã€‚

*** ContentView.swift
#+BEGIN_SRC swift -r -n
import SwiftUI (ref:import)

struct ContentView: View { (ref:struct)
    var body: some View { (ref:vg)
        Text("æ–‡å­—") (ref:text)
    }
}

struct ContentView_Previews: PreviewProvider { (ref:preview)
    static var previews: some View {
        ContentView()
    }
}
#+END_SRC
- ç¬¬[[(import)]]è¡Œå’Œ C++ä¸­çš„#include <iostream>åŒæ„ï¼Œå…ˆåŒ¯å…¥æ‰€éœ€å‡½å¼åº«
- ç¬¬[[(struct)]]è¡Œèªªæ˜æœ‰ä¸€å€‹ struct åç‚º ContentViewï¼Œé€™å€‹ ContentView conform(å°Šå¾ª)View é€™å€‹ Protocolï¼Œé€™ä»£è¡¨å¿…é ˆæœ‰ä¸€å€‹ some view æˆ–å›å‚³ä¸€å€‹ some view
- åœ¨ ContentView ä¸­ï¼Œæœ‰ä¸€å€‹å« body çš„è®Šæ•¸(ç¬¬[[(vg)]]è¡Œ)ï¼Œé€™å€‹ body çš„å›å‚³é¡å‹ç‚º some viewï¼Œsome ç‚º swift 5.1 å‡ºç¾çš„æ–° keywordï¼Œå±¬æ–¼ opaque å›å‚³é¡å‹ï¼Œä»£è¡¨å®ƒæœƒå›å‚³æŸäº›é¡å‹ç‚º view çš„å€¼ï¼Œè‡³æ–¼å¯¦éš›å›å‚³çš„æ˜¯é‚£ä¸€ç¨®é¡å‹çš„ viewï¼Œswift ä¸¦ä¸å¤ªåœ¨æ„
- ç¬¬[[(text)]]è¡Œçš„æœ€å‰é¢çœç•¥äº†ä¸€å€‹ returnï¼Œæ„æ€æ˜¯ body é€™å€‹ variable æœ€å¾Œæœƒå‚³å›ä¸€å€‹ Text, å³ï¼Œå‘ˆç¾åœ¨ View ä¸Šï¼Œbody åªèƒ½å›å‚³ä¸€å€‹å€¼ï¼Œè‹¥ view ä¸Šé¢æœ‰è¨±å¤šç‰©ä»¶ï¼Œå‰‡éœ€åŒ…å«é€²ä¸€å€‹ container ä¸­ï¼Œæœ€å¾Œå›å‚³é€™ä¸€å€‹ containerã€‚
- ç¬¬[[(preview)]]è¡Œçš„ ContentView_Previews è² è²¬ç”¢ç”Ÿé è¦§ç•«é¢ã€‚
** Text
*** æ”¹è®Š Text çš„å±¬æ€§
- æ”¹è®Š component æœ‰å…©ç¨®æ–¹å¼ï¼šå·¥å…·åˆ—ã€code
- Attributes (modifier çš„ä¸åŒé †åºå¯èƒ½ç”¢ç”Ÿä¸åŒæ•ˆæœ)
  + frame
  + foregroundColor
  + background
  + font
  + padding
  + cornerRadius


**** SwiftUI Inspector:
1) on Text object (in preview screen): CMD + click
2) select *Show SwiftUI Inspector*
3) change *Text*, *Font*, *Color*
4) Monitor the corresponding code changes in code window
#+CAPTION: SwiftUI Inspector
#+LABEL:fig:Inspector-1
#+name: fig:Inspector-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 600
[[file:images/inspector-1.gif]]
**** Inspector frame
#+CAPTION: SwiftUI Inspector
#+LABEL:fig:inspector-2
#+name: fig:inspector-2
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 600
[[file:images/inspector-2.gif]]
**** code
æ–¼ Text("...")å¾ŒåŠ ä¸Šå±¬æ€§ function æˆ–ä¿®æ”¹å…¶ä»–å±¬æ€§
#+CAPTION: SwiftUI Change Attributes
#+LABEL:fig:ChangeAttribute
#+name: fig:ChangeAttribute
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 600
[[file:images/inspector-3.gif]]
** VStack

ä¸€å€‹ä»¥ä¸Šçš„ç‰©ä»¶éƒ½è¦æ”¾åœ¨ Stack ä¸­ï¼ŒStack èˆ‡ Stack å¯ç›¸äº’åŒ…å«ï¼ŒåŠ å…¥æ–¹å¼æœ‰äºŒï¼š
*** ç”±å·¥å…·åˆ— drag: Xcode æœƒè‡ªå‹•åŠ å…¥ç›¸å°çš„ code
#+CAPTION: Drag component from toolbar
#+LABEL:fig:VStack
#+name: fig:VStack
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 600
[[file:images/vstack.gif]]
*** coding
#+begin_src swift -r -n :results output :exports both
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Text("ç¬¬ä¸€è¡Œæ–‡å­—")
            Text("ç¬¬äºŒè¡Œæ–‡å­—")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#+end_src

#+RESULTS:

#+CAPTION: VStack
#+LABEL:fig:VStack-1
#+name: fig:VStack-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/vstack-1.jpg]]
*** SwiftUI æ’°å¯«åŸå‰‡
- body æ†ç‚ºåªèƒ½ return ä¸€ç‰©ä»¶ã€‚
- è‹¥æœ‰å¤šå€‹ç‰©ä»¶æ™‚ï¼Œä¸€å®šå¾—æ”¾åœ¨ Stack è£¡ã€‚
** HStack
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        HStack {
            VStack {
                Button("è«‹æŒ‰æˆ‘") {
                    print("TEST")
                }
                .frame(width: 60, height: 30, alignment: .center)
                .foregroundColor(.white)
                .background(Color.green)
                Button("åˆ¥äº‚æŒ‰") {
                    print("QQ")
                }
            }
            VStack {
                Text("ç¬¬ä¸€è¡Œæ–‡å­—")
                    .frame(width: 100, height: 30, alignment: .center   )
                    .foregroundColor(.white)
                    .background(Color.orange)
                Text("ç¬¬äºŒè¡Œæ–‡å­—")
                    .frame(width: 100, height: 30, alignment: .center)
                    .foregroundColor(.white)
                    .background(Color.red)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#+end_src
#+CAPTION: HStack
#+LABEL:fig:HStack-1
#+name: fig:HStack-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/hstack-1.jpg]]
** ZStack
** Image
å½±åƒä¾†æºå¯ä»¥æ˜¯ System Image æˆ–è‡ªè¡Œä¸‹è¼‰/ç·¨ä¿®çš„å½±åƒ(Customized Image)
*** System Image
**** [[https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/][SF Symbols ]][fn:4]
**** å¾ iOS 13 é–‹å§‹ï¼ŒApple ä»‹ç´¹äº†ä¸€å€‹åç‚º SFSymbols çš„æ–°åŠŸèƒ½ã€‚SF Symbols é€™åŠŸèƒ½ç”± Apple æ‰€è¨­è¨ˆï¼Œç•¶ä¸­é›†åˆäº† 1500 å¤šå€‹å¯ä»¥åœ¨ App ä¹‹ä¸­ä½¿ç”¨çš„ç¬¦è™Ÿã€‚[fn:3]
**** [[https://developer.apple.com/design/resources/][Download SF Symbols app]]
**** code
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Text("System Image")
                .font(.headline)
                .foregroundColor(.orange)
            Image(systemName: "icloud")
            .resizable()
            .scaledToFit()
            .frame(width: 100, height: 80, alignment: .center)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#+end_src

**** Demo
#+CAPTION: Images-1
#+LABEL:fig:Images-1
#+name: fig:Images-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/image-1.jpg]]

*** Customized Image èªæ³•
1) Drag image into Project folder *Assets.xcassets*
2) Add following code
#+begin_src swift -r -n :eval no
Image("ImageName") //file name in Assets.xcassets
  .resizable()
  .scaledToFit()
  .frame(width: 200, height: 160, alignment: .center)
#+end_src

*** Image Attributes
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Text("Albert Camus")
                .font(.title)
                .foregroundColor(.white)
                .background(Color.orange)
            Image("Albert-Camus")
                .resizable()
                .scaledToFill()
                .frame(width: 200, height: 200, alignment: .center)
                .clipShape(Circle())

        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#+end_src
#+CAPTION: Images-2
#+LABEL:fig:Images-2
#+name: fig:Images-2
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/image-2.jpg]]

*** Using SF Symbols
- SF Symbols app
- [[https://sfsymbols.com/][sfsymbols.com]]
- [[https://www.avanderlee.com/swift/sf-symbols-guide/][SF Symbols: The benefits and how to use them guide]]
** Button
*** èªæ³•
#+begin_src swift -r -n :eval no
//...
Button("Title") {
    //action
}

Button(action: <#T##() -> Void#>, label: <#T##() -> _#>)
//...
#+end_src
*** å°‡è®Šæ•¸åŠ å…¥ View ä¸­
#+begin_src swift -r -n :eval no
struct ContentView: View {
    var title = "Hello SWiftUI"

    var body: some View {
        VStack {
            Text(verbatim: title)
                .padding(4)
                .foregroundColor(.white)
                .background(Color.gray)
        }
    }
}
#+end_src
*** å•é¡Œï¼šå¯å¦æ–¼ç¨‹å¼ä¸­æ”¹è®Š title çš„å€¼ä¾†æ”¹è®Š View çš„é¡¯ç¤ºå…§å®¹?
*** @State
#+begin_src swift -r -n :eval no
struct ContentView: View {
    @State var title = "Hello SWiftUI"

    var body: some View {
        VStack {
            Text(verbatim: title)
                .padding(4)
                .foregroundColor(.white)
                .background(Color.gray)
        }
    }
}
#+end_src
View ç‚º structï¼ŒæœªåŠ ä¸Š @State çš„è®Šæ•¸æ˜¯ä¸å…è¨±è®Šæ›´çš„(immutable)ï¼›åŠ äº† @State å¾Œï¼ŒSwiftUI å°‡èªç‚ºé€™å€‹è®Šæ•¸(æˆ–ï¼Œstruct çš„ property)ä»£è¡¨æŸç¨®å½±å°‡ View ç•«é¢æˆ–å…§å®¹çš„ç‹€æ…‹ï¼Œä¸¦åœ¨èƒŒå¾Œå¦å¤–ç”¢ç”Ÿç©ºé–“å„²å­˜ property çš„å…§å®¹ï¼Œå®ƒä¸å†å„²å­˜åœ¨ ContentView è£¡ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥ä¿®æ”¹å®ƒçš„å…§å®¹[fn:5]ã€‚

ä»¥ @State å®£å‘Šçš„ property æœ‰å€‹é‡è¦çš„ç‰¹æ€§ï¼Œåªè¦å®ƒçš„å…§å®¹æ”¹è®Šï¼Œç•«é¢ä¹Ÿæœƒç«‹å³æ›´æ–°ã€‚å®ƒå¸¶ä¾†äº†ä»¥ä¸‹å…©å€‹å¥½è™•:
- ä¸ç”¨å¦å¤–å¯« property å…§å®¹æ”¹è®Šæ™‚æ›´æ–°ç•«é¢çš„ç¨‹å¼ã€‚
- ä¸ç”¨æ“”å¿ƒç•«é¢é¡¯ç¤ºçš„å…§å®¹è·Ÿ property çš„å…§å®¹ä¸åŒæ­¥ï¼Œæ¯”æ–¹ä¿®æ”¹äº† propertyï¼Œä½†å»å¿˜äº†æ›´æ–°ç•«é¢ã€‚

**** å•é¡Œï¼šåœ¨ä»€éº¼åœ°æ–¹å»æ”¹è®Š title çš„å€¼ï¼Ÿ --> Button
*** ç¯„ä¾‹: æŒ‰ä¸‹ Buttonï¼Œæ”¹è®Š Text title
#+begin_src swift -r -n :eval no
struct ContentView: View {
    @State var title = "Hello SWiftUI"

    var body: some View {
        VStack {
            Text(verbatim: title)
                .padding(4)
                .foregroundColor(.white)
                .background(Color.gray)
            Button("Click Me") {
                self.title = "QQ"
            }
        }
    }
}
#+end_src
*** å•é¡Œï¼šå¯å¦è‡ªè¡Œè¼¸å…¥è¦æ›´æ”¹çš„ title å…§å®¹ï¼Ÿ --> TextField + $var
** TextField (with @State)
*** èªæ³•
#+begin_src swift -r -n :eval no
@State private var è®Šæ•¸="å€¼"
TextField("æç¤ºæ–‡å­—", text: $è®Šæ•¸)
#+end_src
*** ç¯„ä¾‹: æ–¼ TextField è¼¸å…¥è³‡æ–™ï¼Œé¡¯ç¤ºæ–¼ Text ä¸­
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    @State private var title = "" (ref:StateVar)

    var body: some View {
        VStack {
            Text(verbatim: "Hello "+title) (ref:strTitle)
            HStack {
                Text("Your Name: ")
                TextField("è«‹è¼¸å…¥å§“å:", text: $title) (ref:dollarSign)

            }
        }
    }
}
#+end_src
åœ¨ä¸Šè¿°ç¨‹å¼ä¸­ï¼Œæˆ‘å€‘å¸Œæœ›åœ¨ *TextField* ä¸­è¼¸å…¥æ–‡å­—æ™‚å°±èƒ½å³æ™‚æ”¹è®Š title çš„å€¼ï¼Œä¾¿è¦åšç¶å®š(Binding)çš„å‹•ä½œï¼Œä¹Ÿå°±æ˜¯åœ¨ *TextField* ä¸­ title å‰åŠ ä¸Šä¸€å€‹$ (ç¬¬[[(dollarSign)]]è¡Œ)ï¼Œç”± *TextField* çš„èªæ³•ä¹Ÿå¯ä»¥çœ‹å‡º: TextField(<titleKey: LocalizedStringKey, text: Binding<String>)ã€‚SwiftUI ä¾¿æ˜¯é€éã€Œåœ¨@State property å‰åŠ ä¸Š$ã€çš„æ–¹å¼ä¾†å–å¾—é€™å€‹ property çš„ bindingï¼Œç•¶ç¬¬[[(dollarSign)]]çš„å€¼ä¸€æ”¹è®Šï¼Œç¬¬[[(strTitle)]]è¡Œçš„ Text ä¹Ÿæœƒå³æ™‚è·Ÿè‘—æ”¹è®Šï¼Œé€™ä¾¿æ˜¯ binding çš„ä½œç”¨ã€‚

é™¤äº† *TextField* ä¹‹å¤–ï¼ŒSwiftUI é‚„æœ‰è¨±å¤šæä¾› *Binding* çš„å…ƒä»¶ï¼Œä¾‹å¦‚ï¼šToggle, Slider, DatePicker...ã€‚
*** Demo
#+CAPTION: Button
#+LABEL:fig:Button-1
#+name: fig:Button-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/txtfield-1.jpg]]
*** @State
[[https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs][Why @State only works with structs]]
SwiftUIâ€™s State property wrapper is designed for simple data that is local to the current view.
Letâ€™s break this down with some code â€“ hereâ€™s a struct to store a userâ€™s first and last name:
#+begin_src swift -r -n :results output :exports nil
struct User {
    var firstName = "Bilbo"
    var lastName = "Baggins"
}
#+end_src
We can now use that in a SwiftUI view by creating an @State property and attaching things to $user.firstName and $user.lastName, like this:
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    @State private var user = User()

    var body: some View {
        VStack {
            Text("Your name is \(user.firstName) \(user.lastName).")

            TextField("First name", text: $user.firstName)
            TextField("Last name", text: $user.lastName)
        }
    }
}
#+end_src
That all works: SwiftUI is smart enough to understand that one object contains all our data, and will update the UI when either value changes. Behind the scenes, whatâ€™s actually happening is that each time a value inside our struct changes the whole struct changes â€“ itâ€™s like a new user every time we type a key for the first or last name. That might sound wasteful, but itâ€™s actually extremely fast.
** some view
** SubView
*** è‡ªè¡Œæ”¹å¯«
*** Extract Subview
** @State v.s. @Bidning
#+begin_src swift -r -n :eval no
struct ContentView: View {
    var isRain = true
    var body: some View {
        VStack {
            Image(systemName: isRain ? "cloud.rain.fill" : "sun.max.fill")
                .resizable()
                .frame(width: 100, height: 100)
            Text(isRain ? "æˆ‘å€‘æ·‹è‘—å¤§é›¨ä¸çŸ¥ä½•æ™‚æ‰èƒ½æ”¾æ™´" : "å¤ªé™½å…¬å…¬å‡ºä¾†äº†ï¼Œä»–å°æˆ‘å‘€ç¬‘å‘€ç¬‘")

            Button("ä»Šå¤©å¤©æ°£å¦‚ä½• ?") {
                self.isRain = Bool.random() (ref:immutable)
            }
        }
    }
}
#+end_src

ä¸Šè¿°ç¨‹å¼ä¸­ç¬¬[[(immutable)]]è¡Œæœƒç”¢ç”Ÿ *Cannot assign to property: self is immutable* çš„éŒ¯èª¤ï¼Œå› ç‚º Swift çš„ view ç‚º struct å®šç¾©ï¼Œè€Œ struct ç‚º value typeï¼Œæ•…ç„¡æ³•åœ¨ computed property è£¡ getter & function ä¸­ä¿®æ”¹å…¶ property.

ä¿®æ­£æ–¹å¼ç‚ºï¼šåœ¨ isRain æœ€å‰é¢åŠ ä¸Š@Stateï¼Œå¦‚
#+begin_src swift -r -n :eval no
// ...
@State var isRain = true
//...
#+end_src
** TODO onAppear(perform:)
View ç§€å‡ºæ™‚è¦é¡å¤–åšå“ªäº›äº‹æƒ…....
** å­¸ç¿’è³‡æº
- [[https://developer.apple.com/tutorials/swiftui/creating-and-combining-views][SwiftUI Tutorials from Apple (å®˜æ–¹åŸºæœ¬æ•™æ)]]
- [[https://swiftdoc.org/][swiftdoc.org]]
- [[http://swiftdeveloperblog.com/code-examples/][Swift Developer Blog]]
- [[https://www.hackingwithswift.com/quick-start/swiftui][Hacking with SWIFT]]
- [[https://medium.com/@ivanchemical/swift-ui-social-network-c27a67078d62][Swift UI social network]]
#+latex:\newpage
* Customize UI Components
:PROPERTIES:
:CUSTOM_ID: SW-CUSTOMIZED-UI-COMPONENTS
:END:
SwiftUI æä¾›è±å¯Œçš„ modifier å¹«åŠ©æˆ‘å€‘è¨­è¨ˆå®¢è£½ UI å…ƒä»¶çš„æ¨£å¼ï¼Œè«¸å¦‚é™°å½±ï¼Œæ—‹è½‰ç­‰æ•ˆæœçš†å¯é€é modifier å¯¦ç¾ï¼Œé‚„å¯ä»¥æ­é…æ–¹ä¾¿çš„æ‹–æ›³åŠ å…¥ç›¸é—œç¨‹å¼ç¢¼ã€‚[fn:6]

** Text
*** Advanced Attributes [fn:6]
#+begin_src swift -r -n :eval no
struct ContentView: View {
    var body: some View {
        Text("Example")
          .font(.title)
          .fontWeight(.bold)
          .foregroundColor(Color.white)
          .padding(4)
          .background(Color.gray)
          .cornerRadius(14.0)
          .rotationEffect(Angle(degrees: 15))
          .rotation3DEffect(Angle(degrees: 30), axis: (x: 10, y: 30, z: 30))
          .shadow(radius: 20)
    }
}
#+end_src
*** Demo
#+CAPTION: Text Attributes
#+LABEL:fig:Adv-Text_Attributes
#+name: fig:Adv-Text_Attributes
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/adv-text-attributes.jpg]]
** Image
*** Advanced Attributes s[fn:7]
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Text("Albert Camus")
              .font(.body)
              .foregroundColor(.white)
              .background(Color.orange)
            Image("Albert-Camus")
              .resizable()
              .scaledToFill()
              .frame(width: 100, height: 100, alignment: .center)
              .clipShape(Circle())
            Image(systemName: "alarm.fill")
              .resizable()
              .scaledToFill()
              .frame(width: 100, height: 100, alignment: .center)
            Image("Albert-Camus")
              .frame(width: 100, height: 100, alignment: .center)
              .mask(Image(systemName: "alarm.fill")
                      .resizable()
                      .scaledToFit())
              .shadow(radius: 20)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

#+end_src
*** Demo
#+CAPTION: Image Attributes
#+LABEL:fig:Adv-Image-Attributes
#+name: fig:Adv-Image-Attributes
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/image-advanced-attributes.jpg]]
** Button
*** Advanced Attributes [fn:8]
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack(spacing: 5.0) {
            Text("Customized Button")
              .font(.body)
              .foregroundColor(.white)
              .background(Color.orange)
            Button(action: {
                       print("Hello button tapped!")
                   }) {
                Text("HI HI")
                  .fontWeight(.bold)
                  .font(.title)
                  .foregroundColor(.purple)
                  .padding()
                  .border(Color.purple, width: 5)
            }
            Button(action: {
                       print("Hello button tapped!")
                   }) {
                Text("Press me")
                  .fontWeight(.light)
                  .font(.title)
                  .foregroundColor(.green)
                  .padding(5)
                  .overlay(
                    Capsule(style: .continuous)
                      .stroke(Color.green, style: StrokeStyle(lineWidth: 3, dash: [10]))
                  )
            }
        }
    }
}

#+end_src
*** Demo
#+CAPTION: Button Attributes
#+LABEL:fig:Adv-Button-Attributes
#+name: fig:Adv-Button-Attributes
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/customized-button-1.jpg]]
** Button, Divider
#+begin_src swift -r -n :eval no
//
//  ContentView.swift
//  uitest
//
//  Created by yen yung chin on 2020/7/29.
//  Copyright Â© 2020 Letranger.tw. All rights reserved.
//

import SwiftUI

struct ContentView: View {
    @State private var a = ""
    @State private var b = ""
    @State private var c = "Ans:"

    var body: some View {
        VStack {
            VStack {
                Divider()
                TextField("Number 1: ", text: $b)
                Divider()
                TextField("Number 2:", text: $a)
                Divider()
                Button("â•") {
                    let one = Int(self.a) ?? 0
                    let two = Int(self.b) ?? 0
                    self.c = "Ans: " + String(one + two)
                }
                  .frame(width: 40, height: 30, alignment: .center)
                  .foregroundColor(.white)
                  .background(Color.green)
                  .font(.largeTitle)
                Divider()
                Text(verbatim: c)
                  .foregroundColor(.gray)
            }
              .frame(width: 200, height: 160, alignment: .center)
        }
    }
}
#+end_src
#+CAPTION: Button
#+LABEL:fig:Button-1
#+name: fig:Button-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/btn-1.jpg]]
** background, opacity
#+begin_src swift -r -n :eval no
//
//  ContentView.swift
//  uitest
//
//  Created by yen yung chin on 2020/7/29.
//  Copyright Â© 2020 Letranger.tw. All rights reserved.
//

import SwiftUI

struct ContentView: View {
    @State private var a = ""
    @State private var b = ""
    @State private var c = "Ans:"

    var body: some View {
        VStack(alignment: .center) {
            Text("è¨ˆç®—æ©Ÿ")
            Divider()
            TextField("Number 1: ", text: $b)
            Divider()
            TextField("Number 2:", text: $a)
            Divider()
            Button("â•") {
                let one = Int(self.a) ?? 0
                let two = Int(self.b) ?? 0
                self.c = "Ans: " + String(one + two)
            }
              .frame(width: 40, height: 30, alignment: .center)
              .foregroundColor(.white)
              .background(Color.white)
              .font(.largeTitle)
            Divider()
            Text(verbatim: c)
              .foregroundColor(.black)


        }
          .padding(60)
          .background(Image("background").resizable().scaledToFill())
          .opacity(0.9)
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}


#+end_src
#+CAPTION: Background
#+LABEL:fig:Background-1
#+name: fig:Background-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/background-1.jpg]]
** Further reading
- [[https://www.simpleswiftguide.com/advanced-swiftui-button-styling-and-animation/][Advanced SwiftUI button styling and animation]]
* List
:PROPERTIES:
:CUSTOM_ID: list
:END:
** What is List
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    var body: some View {
        List {
            Text("Hello world.")
            Text("Hello world.")
            Text("Hello world.")
        }
    }
}
#+end_src
** æº–å‚™å–®ä¸€ cell æ ¼å¼
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        HStack {
            Image(systemName: "book")
              .resizable()
              .frame(width: 30, height: 30, alignment: .center)
            VStack(alignment: .leading) {
                Text("Artificial Intelligence: A Modern Approach")
                  .multilineTextAlignment(.leading)
                  .foregroundColor(Color.green)
                Text("Stuart Russell and Peter Norvig")
                  .multilineTextAlignment(.leading)
                  .foregroundColor(Color.orange)
            }
        }
    }
}

#+end_src
#+CAPTION: Single cell
#+LABEL:fig:single-cell
#+name: fig:single-cell
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/single-cell.jpg]]
** è½‰å…¥ List æ ¼å¼(éœæ…‹ List)
*** å°‡æœ€å¤–å±¤çš„ VStack åŠ å…¥ List ä¸­
#+CAPTION: List-1
#+LABEL:fig:list-1
#+name: fig:list-1
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 500
[[file:images/list-1.jpg]]
*** list èªæ³•
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    var body: some View {
        List(0 ..< 5) { item in
            Image(systemName: "book")
              .resizable()
              .frame(width: 30, height: 30, alignment: .center)
            VStack(alignment: .leading) {
                Text("Artificial Intelligence: A Modern Approach")
                  .multilineTextAlignment(.leading)
                  .foregroundColor(Color.green)
                Text("Stuart Russell and Peter Norvig")
                  .multilineTextAlignment(.leading)
                  .foregroundColor(Color.orange)
            }
        }
    }
}
#+end_src
*** çµæœ
#+CAPTION: List-2
#+LABEL:fig:list-2
#+name: fig:list-2
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 500
[[file:images/list-2.jpg]]
** å»ºç«‹ list ä¾†æºè³‡æ–™(å‹•æ…‹ List) [fn:3]
#+begin_verse
In order to handle dynamic items, you must first tell SwiftUI how it can identify which item is which. This is done using the Identifiable protocol, which has only one requirement: some sort of id value that SwiftUI can use to see which item is which. [fn:9]
#+end_verse
#+begin_src swift -r -n :eval no
import SwiftUI

//å»ºç«‹book struct
struct Book: Identifiable {
    var id = UUID()
    var title: String
    var author: String
    var image: String
}

struct ContentView: View {
    var books = [
      Book(id: UUID(), title: "åœ°ç„è—èª¿", author: "ææŸ¥å¾·", image: "b1"),
      Book(id: UUID(), title: "è‡³æ­»æ–¹ä¼‘", author: "ææŸ¥å¾·", image: "b2"),
      Book(id: UUID(), title: "ä¸€è§¸å³ç™¼", author: "ææŸ¥å¾·", image: "b3"),
      Book(id: UUID(), title: "ç´¢å‘½è¨ªå®¢", author: "ææŸ¥å¾·", image: "b4"),
      Book(id: UUID(), title: "é—‡å¤œå›è² ", author: "ææŸ¥å¾·", image: "b5")]

    //.....
}
#+end_src
** å°‡è³‡æ–™é€£çµåˆ°åˆ—è¡¨ä¸­ [fn:3]
#+begin_src swift -r -n :eval no
import SwiftUI

//....
var body: some View {
    List(books) { book in
        Image(book.image)
          .resizable()
          .frame(width: 40, height: 40, alignment: .center)
        VStack(alignment: .leading) {
            Text(book.title)
              .multilineTextAlignment(.leading)
              .foregroundColor(Color.green)
            Text(book.author)
              .multilineTextAlignment(.leading)
              .foregroundColor(Color.orange)
        }
    }
}
}
#+end_src
** çµæœ
#+CAPTION: List-3
#+LABEL:fig:list-3
#+name: fig:list-3
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/list-3.jpg]]
** ç‚ºä»€éº¼è¦åŠ å…¥ id èˆ‡ Identifiable
- Identifiable: å…è¨± Array ä¸­æœ‰é‡è¤‡å€¼
- id: æ˜ç¢ºå€åˆ†é‡è¤‡å€¼
- UUID: è‡ªå‹•ç”Ÿæˆ unique å€¼
- è©³ç´°èªªæ˜å¦‚[[https://medium.com/flawless-app-stories/swiftui-dynamic-list-identifiable-73c56215f9ff][SwiftUI - Dynamic List & Identifiable]]
** Reading source
- [[https://www.youtube.com/watch?v=bz6GTYaIQXU][SwiftUI Basics: Dynamic Lists, HStack VStack, Images with Circle Clipped Stroke Overlays]]
- [[https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation][Building Lists and Navigation]]

#+latex:\newpage
* Passing data between Views #1: @State and @Binding
:PROPERTIES:
:CUSTOM_ID: StateBinding
:END:
** @State
- State is a value, or a set of values, that can change over time, and that affects a viewâ€™s behavior, content, or layout. You use a property with the @State attribute to add state to a view.
- é€šéä½¿ç”¨ @State ä¿®é£¾å™¨æˆ‘å€‘å¯ä»¥é—œè¯å‡º View çš„ç‹€æ…‹. SwiftUI å°‡æœƒæŠŠä½¿ç”¨é @State ä¿®é£¾å™¨çš„å±¬æ€§å­˜å„²åˆ°ä¸€å€‹ç‰¹æ®Šçš„å…§å­˜å€åŸŸ(heap)ï¼Œä¸¦ä¸”é€™å€‹å€åŸŸå’Œ View struct æ˜¯éš”é›¢çš„. ç•¶ @State è£é£¾éçš„å±¬æ€§ç™¼ç”Ÿäº†è®ŠåŒ–ï¼ŒSwiftUI æœƒæ ¹æ“šæ–°çš„å±¬æ€§å€¼é‡æ–°å‰µå»ºViewã€‚[fn:10]
- Simple properties like String or Int
- Belongs to a specific view
- Never used outside that view
- The wrappedValue is: anything (but almost certainly a value type).
- What it does: stores the wrappedValue in the heap; when it changes, invalidates the View.
- Projected value (i.e. $): a Binding (to that value in the heap).
** @Binding
- @Binding is one of SwiftUIâ€™s less used property wrappers, but itâ€™s still hugely important: it lets us declare that one value actually comes from elsewhere, and should be shared in both places. This is not the same as @ObservedObject or @EnvironmentObject, both of which are designed for reference types to be shared across potentially many views.[fn:11]
- æœ‰æ™‚å€™æˆ‘å€‘æœƒæŠŠä¸€å€‹è¦–åœ–çš„å±¬æ€§å‚³è‡³å­ç¯€é»ä¸­ï¼Œä½†æ˜¯åˆä¸èƒ½ç›´æ¥çš„å‚³éçµ¦å­ç¯€é»ï¼Œå› ç‚ºåœ¨ Swift ä¸­å€¼çš„å‚³éå½¢å¼æ˜¯å€¼é¡å‹å‚³éæ–¹å¼ï¼Œä¹Ÿå°±æ˜¯å‚³éçµ¦å­ç¯€é»çš„æ˜¯ä¸€å€‹æ‹·è²éçš„å€¼ã€‚ä½†æ˜¯é€šé @Binding ä¿®é£¾å™¨ä¿®é£¾å¾Œï¼Œå±¬æ€§è®Šæˆäº†ä¸€å€‹å¼•ç”¨é¡å‹ï¼Œå‚³éè®Šæˆäº†å¼•ç”¨å‚³éï¼Œé€™æ¨£çˆ¶å­è¦–åœ–çš„ç‹€æ…‹å°±èƒ½é—œè¯èµ·ä¾†äº†ã€‚[fn:10]
- The wrappedValue is: a value that is bound to something else.
- What it does: gets/sets the value of the wrappedValue from some other source.
- What it does: when the bound-to value changes, it invalidates the View.
- Projected value (i.e. $): a Binding (self; i.e. the Binding itself)
** Time to use Binding
Bindings are all about having a *single source of the truth (data)!*.
- Getting text out of a TextField
- Using a Toggle or other state-modifying UI element
- Finding out which ittem in a NavigationView was chosen.
- Find out whether we're being targeted with a Drag
- Binding our gesture to the .updating function of a gesture.
** Demo 1: @State v.s. @Bidning
é€é@State èˆ‡@Bidning, ContentView.swift å¯ä»¥å°‡è®Šæ•¸ switchIsOn pass çµ¦ SwitchView.swiftï¼Œè€Œå¾Œè€…å¯ä»¥è—‰ç”±æ›´æ”¹è®Šæ•¸å€¼ä¾†æ”¹è®Š ContentView.swift çš„é¡¯ç¤ºçµæœã€‚
*** ContentView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    @State var switchIsOn = false

    var body: some Vie {
        VStack {
            Text(switchIsOn ? "-_-" : "^_^")
            SwitchView(switchIsOn: $switchIsOn)
        }
    }
}
#+end_src
*** SwitchView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct SwitchView: View {
    @Binding var swtichIsOn: Bool

    var body: some View {
        Toggle(isOn: $switchIsOn, label: {
            Text(switchIsOn ? "ON" : "OFF")
        })
    }
}
#+end_src
** Demo 2: sharing data between Views
ç›®çš„ï¼šåœ¨ ContentView ä¸­æŒ‰ä¸‹ Buttonï¼Œè‡³ Order View è¼¸å…¥ä¸‹å–®å…§å®¹ï¼Œæœ€å¾Œå°‡ä¸‹å–®å…§å®¹å‚³å› ContentView
*** ContentView.swift: Version-1
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    var body: some View {
        VStack {
            Button("ä¸‹å–®") {
            }
        }
    }
}
#+end_src
*** Order.swift
æ–¼ä¸»ç¨‹å¼ContentViewä¸­click button å¾Œï¼Œç§€å‡ºç›®æ¨™ View (order), ä¸‹å–® View å…§å®¹ç‚ºï¼š
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct Order: View {
    @Binding var orders:String (ref:bindBack)
    var body: some View {
        VStack {
            Text("ä¸‹å–®å€")
            TextField("è«‹è¼¸å…¥è¦è³¼è²·çš„ç‰©å“", text: $orders)
              .textFieldStyle(RoundedBorderTextFieldStyle())
              .padding()
        }
    }
}

struct Order_Previews: PreviewProvider {
    static var previews: some View {
        Order(orders: .constant("")) (ref:ordersPassing)
    }
}

#+end_src
ç¨‹å¼ä¸­ç¬¬[[(bindBack)]]è¡Œçš„ orders ç‚ºå„²å­˜ä¸‹å–®å…§å®¹çš„å­—ä¸²ï¼Œä¸¦æ–¼ç¨å¾Œå°‡å­—ä¸²å…§å®¹å‚³å›ä¸»ç¨‹å¼ï¼Œæ•…é€™å€‹ property ä¸»è¦æ˜¯ä¾†è‡ª ContentView ä¸­çš„æŸä¸€å€‹è®Šæ•¸(property)ï¼Œä¸¦åœ¨ ContentView å‘¼å«(æˆ–ç§€å‡º)order View æ™‚è¦äº¤å¾…æ¸…æ¥šè®Šæ•¸ä¾†æº(å‚³éåƒæ•¸)ã€‚é€™ä¹Ÿå¯ä»¥å¾åº•ä¸‹çš„ Order_previews åœ¨è¦å‘¼å« Order æ™‚æœƒè¢«å¼·è¿«å¡«å…¥ä¸€å€‹åƒæ•¸(ç¬¬[[(ordersPassing)]]è¡Œ)çœ‹å‡ºå…¶å‘¼å«æ–¹å¼ã€‚
*** ContentView.swift: Version-2
è€Œæ­¤æ™‚çš„ ContentView å†åŠ å…¥å‘¼å« Order ä»¥åŠæº–å‚™å‚³éå»çš„åƒæ•¸ï¼Œå…¶å…§å®¹å¦‚ä¸‹(æ‡‰è©²æ˜¯è¦å…ˆåœ¨ ContentView å®£å‘Šå¥½é€™å€‹åƒæ•¸ï¼Œä¸éæ­¤è™•å…ˆä¾åå‘é †åºé€²è¡Œä»¥åˆ©èªªæ˜)ï¼š
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    @State private var isPresented: Bool = false (ref:initIsP)
    @State private var orderContent: String = ""
    var body: some View {

        VStack {
            Button("ä¸‹å–®") {
                self.isPresented = true
            }.sheet(isPresented: self.$isPresented, content: {
                                                        Order(orders: $orderContent) (ref:callOrder)
                                                    })
            Text(orderContent)
        }
    }
}
#+end_src

ContentView çš„ç¬¬[[(callOrder)]]è¡Œå‘¼å« Order ä¸¦å°‡æœ¬èº«çš„ property(orderContent)å‚³éå»ï¼Œè€Œ isPresented æ˜¯ç”¨ä¾†æ§åˆ¶ Order ç§€å‡ºèˆ‡å¦ï¼Œæ•…åœ¨ä¸€é–‹å§‹å…¶åˆå€¼è¨­å®šç‚º false(ç¬¬[[(initIsP)]]è¡Œ)ï¼Œç­‰åˆ° Button è¢«æŒ‰ä¸‹å¾Œå†è®Šæ›´å…§å®¹ç‚º trueï¼Œç§€å‡ºä¸‹å–® View çš„å…§å®¹(å¯ä»¥å¯¦é©—ä¸€ä¸‹å°‡ isPresented åˆå€¼è¨­å®šç‚º trueï¼Œè§€å¯Ÿå¯¦é©—çµæœ)ã€‚

#+LATEX:\newpage
* Alert
:PROPERTIES:
:CUSTOM_ID: Alert
:END:
ç›®çš„: è·³å‡ºå°è©±è¦–çª—
** ä»¥ Buuton è§¸ç™¼
å’Œå‘¼å«å…¶ä»– View ä¸€æ¨£ï¼Œä»ç„¶æ˜¯ä»¥ä¸€å€‹ bool ä¾†æ§åˆ¶æ˜¯å¦ç§€å‡º Alert
#+begin_src swift -r -n :results output :exports nil
struct SecondView: View {
    @State private var showAlert:Bool = false
    var body: some View {
        Button("è«‹æŒ‰æˆ‘") {
            showAlert = true
        }.alert(isPresented: $showAlert, content: {
                                             return Alert(title: Text("åˆ¥äº‚æŒ‰"))
                                         })
    }
}
#+end_src
** ä»¥ TextField è§¸ç™¼
å°‡æ§åˆ¶é¡¯ç¤ºçš„ boo å€¼å¯«åœ¨ *onCommit*
#+begin_src swift -r -n :results output :exports nil
struct SecondView: View {
    @State private var title:String = ""
    @State private var showAlert:Bool = false
    var body: some View {
        TextField("To be or not to be", text: $title, onCommit:  {
                                                          showAlert = true
                                                      })
          .alert(isPresented: $showAlert, content: {
                                              return Alert(title: Text("\(title)"))
                                          })

    }
}
#+end_src

#+LATEX: \newpage
* Navigation Views: Tabbed View
Tab bar æ˜¯åœ¨ App è¢å¹•åº•éƒ¨å‡ºç¾çš„æ¬„ï¼Œæä¾›äº†åœ¨ä¸åŒçš„ç‰ˆé¢ä¹‹é–“é€²è¡Œå¿«é€Ÿåˆ‡æ›çš„é€”å¾‘ã€‚Tab bar çš„èƒŒæ™¯é¡è‰²æ˜¯åŠé€æ˜ï¼Œå¯ä»¥æœ‰èª¿è‰²ã€‚Tab bar åœ¨æ‰€æœ‰è¢å¹•å°ºå¯¸éƒ½ä¿æŒä¸€æ¨£çš„é«˜åº¦ï¼Œä¸¦ä¸”åœ¨éµç›¤æ™‚å‡ºç¾æœƒéš±è—èµ·ä¾†ã€‚

ä¸€å€‹ tab bar å¯ä»¥åŒ…å«ç„¡æ•¸å€‹ tabï¼Œä½†å¯ä»¥èƒ½å®¹ç´çš„æ•¸é‡è¦–ä¹æ ¹æ“šæ‰‹æ©Ÿ/å¹³æ¿çš„å¤§å°ï¼Œä»¥åŠæ©«ã€è±å±æ¨¡å¼éƒ½æœƒæœ‰æ‰€å½±éŸ¿ã€‚åœ¨ç©ºé–“çš„é™åˆ¶ä¸‹ï¼Œç•¶æŸäº› tab ç„¡æ³•è¢«é¡¯ç¤ºæ™‚ï¼Œæœ€å¾Œä¸€å€‹ tab æœƒè®Šæˆâ€œæ›´å¤šâ€(More)ï¼Œ é€šéé€™å€‹ tab å¯ä»¥åˆ°å¦ä¸€å€‹ç¨ç«‹çš„åˆ—è¡¨é é¢ï¼Œé‚£è£¡æœƒåˆ—å‡ºæ‰€æœ‰ç„¡æ³•è¢«é¡¯ç¤ºçš„ tabã€‚[fn:12]

** Create subView
#+begin_src swift -r -n :results output :exports nil
// create StoreView, AboutView, NewsView first
struct ContentView: View {
    @ObservedObject var user = User()

    init() {
        UITabBarItem.appearance().setTitleTextAttributes([.font: UIFont.systemFont(ofSize: 16) ], for: .normal)
    }

    var body: some View {
        TabView {
            StoreView().tabItem {
                Image(systemName: "cart.fill.badge.plus")
                Text("è³¼è²·")
            }
            AboutView().tabItem {
                Image(systemName: "person.3")
                Text("é—œæ–¼")
            }
            NewsView().tabItem {
                Image(systemName: "message")
                Text("æ¶ˆæ¯")
            }
        }.accentColor(.pink)    }
}
#+end_src
** customize tab bar
*** Change tabView font size
#+begin_src swift -r -n :results output :exports nil
init() {
    UITabBarItem.appearance().setTitleTextAttributes([.font: UIFont.systemFont(ofSize: 14) ], for: .normal)
}

#+end_src
*** the color of unselected tab bar
#+begin_src swift -r -n :results output :exports nil
init() {
    UITabBar.appearance().unselectedItemTintColor = UIColor.systemGray3
}
#+end_src
*** the color of the tab bar item : .accentColor
#+begin_src swift -r -n :results output :exports nil
TabView {

}.accentColor(.pink)
#+end_src
*** the tab barâ€™s color: appearance()
å…©ç¨®åšæ³•(å°šæœªå€åˆ† backgroundColor èˆ‡ barTintColor ä¹‹å·®ç•°)
**** init()
#+begin_src swift -r -n :results output :exports nil
init() {
        UITabBar.appearance().barTintColor = UIColor.systemPink
    }
#+end_src
**** onAppear()
èˆ‡ init()å…±ç”¨æ™‚ï¼ŒonAppear()å„ªå…ˆ
#+begin_src swift -r -n :results output :exports nil
.onAppear() {
    UITabBar.appearance().barTintColor = .white
}
#+end_src
** Switching Between Tabs Programmatically
Users can tap the tab bar items to switch between tabs, which is automatically handled the TabView. In some use cases, you may want to switch to a specific tab programmatically. The TabView has another init method for this purpose. The method takes a state variable which associates with the tag value of the tabs.[fn:13]
#+begin_src swift -r -n :results output :exports nil
TabView(selection: $selection)
#+end_src
As an example, declare the following state variable in ContentView:
#+begin_src swift -r -n :results output :exports nil
@State private var selection = 0
#+end_src
Here we initialize the selection variable with a value of 0, which is the tag value of the first tab item. We havenâ€™t defined the tag value for the tab items yet. Therefore, update the code like this and attach the tag modifier for each of the tab items:
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct BookDetailView: View {
    var body: some View {
        Text("This is the Book Detail View")
    }
}

struct BookOrderView: View {
    var body: some View {
        Text("è³¼ç‰©è»Š")
    }
}

struct BookAboutView: View {
    var body: some View {
        Text("About me")
    }
}

struct ContentView: View {
    init() {
        UITabBar.appearance().barTintColor = UIColor.systemPink
        UITabBar.appearance().unselectedItemTintColor = UIColor.systemGray3
    }
    @State private var selection = 0
    var body: some View {

        ZStack(alignment: Alignment(horizontal: .trailing, vertical: .top), content: {
            TabView(selection: $selection,
                    content:  {
                        BookDetailView().tabItem {
                            Image(systemName: "book.fill")
                            Text("Detail")
                        }.tag(0)
                        BookOrderView().tabItem {
                            Image(systemName: "cart.fill")
                            Text("Order")
                        }.tag(1)
                        BookAboutView().tabItem {
                            Image(systemName: "person")
                            Text("About")
                        }.tag(2)
                    })
                .accentColor(.white)
            Button(action: {
                selection = (selection + 1) % 3
                print(selection)
            }, label: {
                Text("Button")
                    .padding(3)
                    .background(Color.pink)
                    .foregroundColor(.white)
                    .padding(3)
            })
        })
    }
}
#+end_src
** ä¸€å€‹å„ªç§€çš„ Tab Bar æ‡‰è©²å…·å‚™å“ªäº›ç‰¹é»ï¼Ÿ[fn:12]
1. ä¸æœƒæœ‰å¤ªå¤šçš„ tab
   æ¯å¢åŠ ä¸€å€‹ tab æœƒæ¸›å°äº†é¸æ“‡å„åˆ¥çš„å¯è§¸å€åŸŸï¼Œä¸¦å¢åŠ  app çš„è¤‡é›œæ€§ï¼Œè®“ç”¨æˆ¶æ›´é›£æ‰¾åˆ°æ‰€éœ€çš„è³‡æ–™ã€‚å³ä½¿â€œæ›´å¤š(More)â€æ¨™ç±¤å¯ä»¥å±•ç¤ºé¡å¤–çš„ tabï¼Œä½†é€™æœƒéœ€è¦é¡å¤–çš„é»æ“Šæ­¥é©Ÿï¼Œè€Œä¸”æ²’æœ‰å¾ˆå¥½åˆ©ç”¨ tab bar çš„æœ‰é™ç©ºé–“ã€‚å¤ªå°‘çš„ tab ä¹Ÿæ˜¯å•é¡Œï¼Œå®ƒæœƒä½¿ä½ çš„ç•Œé¢æ„Ÿè¦ºè¢«åˆ†é›¢ã€‚ä¸€èˆ¬ä¾†èªªï¼Œåœ¨ iPhone ä¸Šæ‡‰ä½¿ç”¨ 3 è‡³ 5 å€‹æ¨™ç±¤ï¼Œåœ¨ iPad ä¸Šå‰‡å¯ç¨å¾®å¤šå¹¾å€‹ã€‚
1. ä¸æœƒç¶“å¸¸è®Šå‹•
   åœ¨æŸå€‹ tab çš„åŠŸèƒ½ç„¡æ³•ä½¿ç”¨æ™‚ï¼Œ ä¸è¦ç§»é™¤é€™å€‹ tab æˆ–æ˜¯è®“å®ƒå¤±æ•ˆã€‚å¦‚æœ tab æ™‚æœ‰æ™‚ç„¡ï¼ŒApp ç•Œé¢æœƒè®Šå¾—ä¸ç©©å®šå’Œé›£ä»¥æ‰æ‘¸ã€‚ç¢ºä¿æ‰€æœ‰çš„ tab éƒ½å¯æœ‰æ•ˆé»æ“Šï¼Œä¸¦ä¸”å‘ç”¨æˆ¶è§£é‡‹ç›®å‰ tab å…§å®¹ä¸å¯ç”¨çš„åŸå› ã€‚è­¬å¦‚èªªï¼Œç•¶ iOS è£ç½®æ²’æœ‰æ­Œæ›²æ™‚ï¼ŒéŸ³æ¨‚ app çš„â€œæˆ‘çš„éŸ³æ¨‚â€tab æœƒé¡¯ç¤ºå¦‚ä½•ä¸‹è¼‰æ­Œæ›²çš„èªªæ˜ã€‚
1. æ‡‰åœ¨ç›¸é€£æ¥çš„è¦–çª—é€²è¡Œå…§å®¹çš„è½‰æ›
   ç‚ºäº†è®“ç•Œé¢ç¬¦åˆç”¨æˆ¶é æœŸï¼Œé¸æ“‡ä¸€å€‹ tab å¾Œçš„ä½œç”¨æ‡‰è©²ç›´æ¥é¡¯ç¤ºæ–¼èˆ‡å…¶ tab bar ç›¸é€£çš„è¦–çª—ï¼Œè€Œä¸æ˜¯è¢å¹•ä¸Šå…¶å®ƒç¯„åœçš„è¦–çª—ã€‚ä¾‹å¦‚ï¼Œå¦‚åœ¨å·¦é‚Šçš„ split view é¸æ“‡äº†ä¸€å€‹ tabï¼Œæ˜¯ä¸æœƒè®“å³åŠéƒ¨åˆ†çªç„¶ç”¢ç”Ÿè®ŠåŒ–çš„ã€‚åœ¨ popover ä¸­é¸æ“‡çš„ tab ä¸æœƒå°è‡´å¾Œæ–¹çš„è¦–çª—ç™¼ç”Ÿæ”¹è®Šã€‚
1. æ‡‰ä¿æŒ icon çš„é¢¨æ ¼çµ±ä¸€å’Œå¹³è¡¡
   ç³»çµ±æä¾›äº†ä¸€ç³»åˆ—é å…ˆè¨­å®šå¥½ã€ä¸€èˆ¬ç”¨é€”çš„ iconï¼Œæˆ‘å€‘ä¹Ÿå¯ä»¥å‰µå»ºè‡ªå·±çš„ iconï¼Œç¢ºä¿ tab bar icon åœ¨è¦–è¦ºä¸Šçš„é¢¨æ ¼çµ±ä¸€å’Œå¹³è¡¡ã€‚
1. æ‡‰ä½¿ç”¨ badge å‚³éä¿¡æ¯
   æˆ‘å€‘å¯ä»¥åœ¨ tab ä¸ŠåŠ ä¸Š badge (ä¸€å€‹ç´…è‰²æ©¢åœ“ä¸Šå¸¶æœ‰ç™½è‰²æ•¸å­—æˆ–æ„Ÿå˜†è™Ÿçš„åœ–æ¡ˆ) ï¼Œä¾†æš—ç¤ºè©² tab æˆ–æ¨¡å¼æœ‰æ–°ä¿¡æ¯ã€‚
** Reading Resources
- [[https://www.appcoda.com/swiftui-tabview/][Customizing the Tab Bar Color]]
- [[https://www.youtube.com/watch?v=tDyvkIe9RsA][Tabbed View SwiaftUI - TabBar Tutorial & Basic Customization - Xcode 11 - 2019]]
- [[https://medium.com/@nwyyy/swift%E7%AD%86%E8%A8%98-tab-bar-2ddba7d56587][iOSç­†è¨˜ï¼šTab Bar]]
- [[https://www.simpleswiftguide.com/][Simple Swift Guide]]
#+latex:\newpage
* Navigation Views: Navigation Bar
:PROPERTIES:
:CUSTOM_ID: navigation
:END:
** Navigation bar
- æ–¼ body ä¸­æœ€å¤–å±¤çš„ component ä¹‹å¤–åŠ å…¥ NavigationView
- Title: navigationBarTitle()ï¼Œtitle ç½®æ–¼ NavigationView {}å…§ attach åœ¨ List ä¸Šï¼Œå› ç‚º NavigationView ä¸»è¦è² è²¬æ–¼ä¸åŒçš„ View ä¸­åˆ‡æ›ï¼Œæ¯å€‹ View éƒ½æœƒæœ‰è‡ªå·±çš„ content èˆ‡ Titleã€‚
- DisplayMode æœ‰ ä¸‰é¡ï¼š
  1) large: é©ç”¨æ–¼ top level
  2) inline: é©ç”¨æ–¼ detail level
  3) automatic: è‡ªå‹•åˆ¤æ–·æœ‰ç„¡ parent level
#+begin_src swift -r -n :eval no
import SwiftUI
  ...

struct ContentView: View {
    ....
    var body: some View {
        NavigationView {
            List(books) { book in
                ...
                }
            .navigationBarTitle(Text("æ›¸å–®"))
            .navigationBarTitleDisplayMode(.large)
            }
        }
    }
}
...
#+end_src
#+CAPTION: Navigation bar
#+LABEL:fig:Navigation-1
#+name: fig:Navigation-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/navigation-1.jpg]]

*** Hide Navigation Bar
ä½¿ç”¨ Hide èˆ‡ä¸è¨­å®š BarTitle çš„å·®ç•°åœ¨æ–¼ï¼šå¾Œè€…ä»æœƒä½”æ‰ Bar çš„ç©ºé–“
#+begin_src swift -r -n :results output :exports nil
import SwiftUI
  ...

struct ContentView: View {
    ....
    var body: some View {
        NavigationView {
            List(books) { book in
                ...
                }
            .navigationBarTitle(Text("æ›¸å–®"))
            .navigationBarTitleDisplayMode(.large)
            .navigationBarHidden(true)
            }
        }
    }
}
...
#+end_src

**** NavigationLink
***** Create
***** èªæ³•:
#+begin_src swift -r -n :results output :exports both
NavigationLink(<title: StringProtocol, destination:)
#+end_src
***** æ–¹å¼
1. Attach link in NavigationLink()
 #+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink("JumpToSecond", destination: SecondView())
                Text("Hello, world!")
                    .padding()
            }
            .navigationTitle("Book List")
            .navigationBarTitleDisplayMode(.large)
        }
    }
}
#+end_src
2. Attach link to other object(Text in this example)
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: SecondView()) {
                    Text("TextLink")
                        .padding()
                }
            }
            .navigationTitle("Book List")
            .navigationBarTitleDisplayMode(.large)
        }
    }
}
#+end_src
è‹¥æ˜¯å°‡ link attach è‡³ imageï¼Œå‰‡è¦åŠ ä¸Š renderingModeï¼Œå¦å‰‡æœƒçœ‹ä¸åˆ°åœ–ï¼Œä¾‹ï¼š
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: SecondView()) {
                    Image(systemName: "myImage")
                        .renderingMode(.original)
                }
            }
            .navigationTitle("Book List")
        }
    }
}
#+end_src

**** Reading
- [[https://www.youtube.com/watch?v=nA6Jo6YnL9g][The Complete Guide to NavigationView in SwiftUI]]
** Create New Views
*** in same file
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct BookDetailView: View {
    var body: some View {
        Text("This is the Book Detail View")
    }
}

struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: BookDetailView()) {
                    Text("GoToDetail")
                }
            }
              .navigationTitle("Book List")

        }
    }
}
#+end_src
**** class exercise
ç‚ºä¸Šè¿° NavigationView åŠ å…¥å¦å¤–å…©å€‹ subView: OrderView, AboutView
*** in new file
å°‡ä¸Šè¿°å°ˆæ¡ˆä¸­çš„æ¯å€‹ subView æ”¹ç‚ºç¨ç«‹ View
** Passing parameter(å–®ç´”åƒæ•¸å‚³é)
Single way, Just pass variable from A to B.
#+begin_src swift -r -n :results output :exports nil
struct BookDetailView: View {
    var operation: String
    var body: some View {
        Text("å·²ç‚ºä½ \(operation)é€™æœ¬æ›¸")
    }
}

struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: BookDetailView(operation: "å€Ÿé–±")) { Text("Loan")
                }
                NavigationLink(destination: BookDetailView(operation: "çºŒå€Ÿ")) { Text("Renew")
                }
                NavigationLink(destination: BookDetailView(operation: "æ­¸é‚„")) { Text("Return")
                }
            }
              .navigationTitle("Book List")

        }
    }
}
#+end_src
** Version-1: Navigation v.s. List v.s. NavigationLink
#+begin_src swift -r -n :eval no
//
//  ContentView.swift
//  navigation
//
//  Created by yen yung chin on 2020/9/27.
//

import SwiftUI

struct Book: Identifiable {
    var id = UUID()
    var title: String
    var author: String
}

struct ContentView: View {
    var books = [
        Book(title:"Xçš„æ‚²åŠ‡", author: "è‰¾å‹’é‡Œï¼æ˜†æ©"),
        Book(title:"åœ°ç„è—èª¿", author: "ææŸ¥å¾·"),
        Book(title:"æ±æ–¹åˆ—è»Šè¬€æ®ºæ¡ˆ", author: "é˜¿å˜‰èâ€§å…‹è‰çµ²è’‚"),
        Book(title:"å…«ç™¾è¬ç¨®æ­»æ³•", author: "å‹å€«æ–¯.åœæ´›å…‹"),
        Book(title:"è¡€å­—ç ”ç©¶", author: "æŸ¯å—é“çˆ¾")
    ]

    var body: some View {
        NavigationView {
            List(books) { book in
                NavigationLink(destination: DetailView(book: book) ){
                        bookRow(book: book)
                    }
                }
            .navigationTitle("æ›¸å–®")
        }
    }
}

struct bookRow: View {
    var book: Book
    var body: some View {
        VStack {
            Text(book.title)
            Text(book.author)
        }
    }
}

struct DetailView: View {
    var book: Book
    var body: some View {
        VStack {
            Text(book.title)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

#+end_src
** Version-2:
å°‡è¨˜éŒ„æ¶æ§‹(Book.swift)ã€List(ContentView.swift)ä»¥åŠ Detail(DetailView.swift)å„è‡ªä»¥ç¨ç«‹æª”æ¡ˆè¨­è¨ˆã€‚
*** Book.swift
#+begin_src swift -r -n :eval no
// ä¸æ¶‰åŠä½¿ç”¨è€…ç•Œé¢

import Foundation

// å»ºç«‹ä¸€å€‹æ›¸ç±çš„åŸºæœ¬çµæ§‹
// åŠ ä¸ŠIdentifiableä»¥åŠUUID()æ˜¯ç‚ºäº†å¯ä»¥å°‡æ›¸ç±é€éListä¾†å‘ˆç¾

struct Book: Identifiable {
    var id = UUID() //ç”¢ç”Ÿä¸€å€‹å”¯ä¸€(unique)çš„äº‚æ•¸
    var title: String
    var author: String
    var image: String
}
#+end_src
*** ContentView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct ContentView: View {
    // åœ¨é€™è£¡è‡¨ç”Ÿç”¢ç”Ÿä¸€å€‹Booké™£åˆ—ï¼Œç„¶å¾Œåœ¨Listç§€å‡ºä¾†
    var books = [
        Book(id: UUID(), title: "åœ°ç„è—èª¿", author: "ææŸ¥å¾·", image: "b1"),
        Book(id: UUID(), title: "è‡³æ­»æ–¹ä¼‘", author: "ææŸ¥å¾·", image: "b2"),
        Book(id: UUID(), title: "ä¸€è§¸å³ç™¼", author: "ææŸ¥å¾·", image: "b3"),
        Book(id: UUID(), title: "ç´¢å‘½è¨ªå®¢", author: "ææŸ¥å¾·", image: "b4")
    ]

    var body: some View {
        NavigationView {
            List(books) { book in
                NavigationLink(destination: DetailView(thisbook: book)) {
                    VStack(alignment: .leading) {
                        Text(book.title)
                            .font(.title)
                        Text(book.author)
                            .font(.subheadline)
                    }
                .navigationBarTitle("æˆ‘çš„æ›¸å–®")
                }
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#+end_src
#+CAPTION: ä¸»é¸å–®
#+LABEL:fig:Navi-List-1
#+name: fig:Navi-List-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/Navi-List-1.png]]
*** DetailView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct DetailView: View {
    //æˆ‘å¸Œæœ›ç­‰ä¸€ä¸‹æœ‰ä»»ä½•äººå‘¼å«æˆ‘ï¼Œä¸€å®šè¦å‚³æ›¸æœ¬çš„è³‡æ–™çµ¦æˆ‘
    var thisbook: Book
    var body: some View {
        VStack {
            Image(thisbook.image)
            Text(thisbook.title)
            Text(thisbook.author)
        }

    }
}

struct DetailView_Previews: PreviewProvider {
    static var previews: some View {
        // è‡¨æ™‚çµ¦å€‹è³‡æ–™ï¼Œè®“previewå¯ä»¥ç§€å‡ºä¾†å°±å¥½

        DetailView(thisbook: Book(id: UUID(), title: "ç´¢å‘½è¨ªå®¢", author: "ææŸ¥å¾·", image: "b4"))
    }
}
#+end_src
#+CAPTION: Detail
#+LABEL:fig:Navi-List-2
#+name: fig:Navi-List-
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/Navi-List-2.png]]

#+latex:\newpage
* Dynamic List
:PROPERTIES:
:CUSTOM_ID: DynamicList
:END:** DataModel
*** BookMOdel.swift (Model)
#+begin_src swift -r -n :results output :exports nil
import Foundation

struct BookModel: Identifiable {
    var id = UUID()
    var title: String
    var author: String
}


#+end_src
** New Item (Single View)
*** ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct ContentView: View {
    @State var books = [
        BookModel(title:"Xçš„æ‚²åŠ‡", author: "è‰¾å‹’é‡Œï¼æ˜†æ©"),
        BookModel(title:"åœ°ç„è—èª¿", author: "ææŸ¥å¾·"),
        BookModel(title:"æ±æ–¹åˆ—è»Šè¬€æ®ºæ¡ˆ", author: "é˜¿å˜‰èâ€§å…‹è‰çµ²è’‚"),
        BookModel(title:"å…«ç™¾è¬ç¨®æ­»æ³•", author: "å‹å€«æ–¯.åœæ´›å…‹"),
        BookModel(title:"è¡€å­—ç ”ç©¶", author: "æŸ¯å—é“çˆ¾")
    ]
    @State var title: String
    @State var author: String

    var body: some View {
        VStack {
            NavigationView {
                List(books) { book in
                    NavigationLink(destination: DetailView(book: book) ){
                        bookRow(book: book)
                    }
                }
                .navigationTitle("æ›¸å–®")
            }
            TextField("æ›¸å", text: self.$title)
            TextField("ä½œè€…", text: self.$author)
            Button("Done") {
                books.append(BookModel(title: self.title, author: self.author))
            }
        }
    }
}

struct bookRow: View {
    var book: BookModel
    var body: some View {
        VStack(alignment: .leading) {
            Text(book.title)
            Text(book.author)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(title: "", author: "")
    }
}

#+end_src
** New Item (isolated View)
*** BookMV.swift (ViewModel)
#+begin_src swift -r -n :results output :exports nil
//
//  BookMV.swift
//  navigation
//
//  Created by yen yung chin on 2020/12/3.
//

import Foundation

class Book: ObservableObject{
    @Published var list: [BookModel]
    init(){
        self.list = [
            BookModel(title:"Xçš„æ‚²åŠ‡", author: "è‰¾å‹’é‡Œï¼æ˜†æ©"),
            BookModel(title:"åœ°ç„è—èª¿", author: "ææŸ¥å¾·"),
            BookModel(title:"æ±æ–¹åˆ—è»Šè¬€æ®ºæ¡ˆ", author: "é˜¿å˜‰èâ€§å…‹è‰çµ²è’‚"),
            BookModel(title:"å…«ç™¾è¬ç¨®æ­»æ³•", author: "å‹å€«æ–¯.åœæ´›å…‹"),
            BookModel(title:"è¡€å­—ç ”ç©¶", author: "æŸ¯å—é“çˆ¾")
        ]
    }
}

#+end_src
*** ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct ContentView: View {
    @ObservedObject var book = Book()
    @State var showNewBook = false
    var body: some View {
        NavigationView {
            List(book.list) { book in
                NavigationLink(destination: DetailView(book: book) ){
                    bookRow(book: book)
                }
            }
            .navigationBarItems(trailing: Button("New"){
                self.showNewBook = true
            }.sheet(isPresented: self.$showNewBook, content: {
                AddNewBook(book: book, showThisView: $showNewBook, title: "", author: "")
            }))
        }
    }
}


struct bookRow: View {
    var book: BookModel
    var body: some View {
        VStack(alignment: .leading) {
            Text(book.title)
            Text(book.author)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

#+end_src
*** AddNewBook.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI
import Combine

struct AddNewBook: View {
    @ObservedObject var book = Book()
    @Binding var showThisView: Bool
    @State  var title: String
    @State  var author: String

    var body: some View {
        VStack {
            Text("Adding New Book....")
            TextField("æ›¸å", text: self.$title)
            TextField("ä½œè€…", text: self.$author)
            Button("Done") {
                book.list.append(BookModel(title: self.title, author: self.author))
                showThisView.toggle()
            }
        }
        Text("TEST")
    }
}

struct AddNewBook_Previews: PreviewProvider {
    static var previews: some View {
        AddNewBook(showThisView: .constant(true), title: "", author: "")
    }
}

#+end_src
* Passing data between Views #2: @EnvironmentObject
:PROPERTIES:
:CUSTOM_ID: EnvironmentObject
:END:
Create once, access everywhere, é©ç”¨æƒ…å¢ƒï¼šapp ä¸­æŸäº› property éœ€è¦æ–¼å¾ˆå¤š View ä¸­å­˜å–ï¼Œä¾‹å¦‚ï¼Œapp çš„ setting.

** @ObservedObject
- Can be shared across views
- More complex properties (e.g custom type)
- External reference type that has to be managed (Create an instance of the class, create its own properties, ...)
- Class should confrom to *ObservableObject*
- *@Published* property wrapper used to mark properties that should force a view to refresh
- The wrappedValue is: anything that implements the OvservableObject protocol (ViewModels basicly).
- What is does: invalidates the View when wrappedValue does objectWillChange.send().
- Projected value (i.e. %): a Binding (to the vars of the wrappedValue (a ViewModel)). You can bind a variable in your View to the variable in your ViewModel with @ObservedObject.
- @ObservedObject çš„ç”¨è™•å’Œ @State éå¸¸ç›¸ä¼¼ï¼Œå¾åå­—çœ‹ä¾†å®ƒæ˜¯ä¾†ä¿®é£¾ä¸€å€‹å°è±¡çš„ï¼Œé€™å€‹å°è±¡å¯ä»¥çµ¦å¤šå€‹ç¨ç«‹çš„ View ä½¿ç”¨ã€‚å¦‚æœä½ ç”¨ @ObservedObject ä¾†ä¿®é£¾ä¸€å€‹å°è±¡ï¼Œé‚£éº¼é‚£å€‹å°è±¡å¿…é ˆè¦å¯¦ç¾ ObservableObject å”è­°ï¼Œç„¶å¾Œç”¨ @Published ä¿®é£¾å°è±¡è£¡å±¬æ€§ï¼Œè¡¨ç¤ºé€™å€‹å±¬æ€§æ˜¯éœ€è¦è¢« SwiftUI ç›£è½çš„ã€‚[fn:10]
** @EnvironmentObject
- Similar to @ObservedObject
- Possibility to make it available to all views through the application itself
- If one view changes the model all views updatezz
- ThewrappedValue is: ObservvableObject obtained via .environemntObject() sent to the View.
- What is does: invalidates the View when wrappedValue does objectWillChange.send().
- Projected value (i.e. $): a Binding (to the vars of the wrappedValue (a ViewModel)).
** Demo #1: ObservaleObject
*** UserStats.swift
#+begin_src swift -r -n :eval no
import Foundation
import SwiftUI
import Combine

class UserStats: ObservableObject {
    var objectWillChange = ObservableObjectPublisher()

    var score = 0 {
        willSet {
            self.objectWillChange.send()
        }
    }
}
#+end_src
*** ScoreView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct ScoreView: View {
    @ObservedObject var userStats = UserStats()

    var body: some View {
        VStack {
            Text("\self.userStats.score")
            Button(action: {self.userStats.score += 1}
                  , label: {
                        Text("Add Point")
                    })
        }
    }
}
#+end_src
** Demo #2: EnvironmentObject
*** UserSettings.swift (ObservableObject)
#+begin_src swift -r -n :eval no
import SwiftUI

class UserSettings: ObservableObject {
    @Published var name = ""
    // use this ObservableObject as an environment object
}
#+end_src
*** SceneDeleate.swift
add new var in SceneDelegate
#+begin_src swift -r -n :eval no
//....

var settings: UserSettings()
func scene(.......) {
    //....
    //let tabbedView = TabbedView()
    let tabbedView = TabbedView().environemntObject(settings)
}
//....
#+end_src
and now the settings is universally available throughtout the tabbed views
*** UserSettingsView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct UserSettingsView: View {
    @EnvironmentObject var settings: UserSettings
    var body: some View {
        VStack {
            Text("My anme: \(settings.name)")
            EditView()
        }
    }
}
#+end_src
*** EditView.swift
#+begin_src swift -r -n :eval no
import SwiftUI

struct EditView: View {
    @EnvironmentObject var settings: UserSettings
    var body: some Veiw {
        TextField("Type in your name:", text: $settings.name)
    }
}
#+end_src
** Demo #3
:PROPERTIES:
:CUSTOM_ID: passingData
:END:

*** with @ObservableObject, @EnvironmentObject and @ObservedObject
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

class User: ObservableObject {
    @Published var score = 0
}

struct BuyBookView: View {
    @EnvironmentObject var user: User

    var body: some View {
        Button("åŠ è³¼! æ•¸é‡\(self.user.score)") {
            self.user.score += 1
        }
    }
}

struct ContentView: View {
    @ObservedObject var user = User()

    var body: some View {
        NavigationView {
            VStack {
                Text("mount: \(user.score)")
                NavigationLink(destination: BuyBookView() ){ (ref:buybook)
                                                             Text("Show amount, now")
                }
            }
              .navigationTitle("Book List")
        }
          .environmentObject(user) (ref:envobj)
    }
}
#+end_src
ç¬¬[[(envobj)]]è¡Œçš„ modifier attach æ–¼ NavigationViewï¼Œæ‰€ä»¥æ‰€æœ‰ä»¥ Navigation é€£æ¥çš„ View å‡å¯å…±äº«æ­¤è®Šæ•¸ã€‚è‹¥å°‡æ­¤ modifier attach åœ¨ BuyBookView()å¾Œ(ç¬¬[[(buybook)]]è¡Œ)ï¼Œå‰‡åªæœ‰é€™å€‹ View å¯å­˜å–æ­¤ä¸€è®Šæ•¸ã€‚
** Demo #4
*** ContentView
æƒ…å¢ƒèªªæ˜ï¼šåœ¨ app ä¸­å»ºç«‹ä¸€å€‹ ShoppingCart é¡åˆ¥ï¼Œé€™å€‹ class ä¹Ÿå¯ä»¥ç¨ç«‹å­˜åœ¨æ–¼ä¸€å€‹æª”æ¡ˆä¸­ï¼Œä¸¦è®“é€™å€‹ class confirm ObservableObject protocolï¼Œæ–¼ class ä¸­å°‡è¦åœ¨å„ View ä¸­ share çš„ property ä»¥@Published æ¨™ç¤ºå‡ºä¾†ã€‚

åœ¨æ¯ä¸€å€‹è¦ä½¿ç”¨åˆ°é€™å€‹ EnvironmentObject çš„ View ä¸­ä»¥@EnvironmentObject ä¾†å»ºç«‹è©² class çš„ instance(ç¬¬[[(environmentObject)]]è¡Œ)ï¼ŒåŒæ™‚ï¼Œåœ¨ previews ä¸­ä¹Ÿè¦åŠ å…¥ environmentObject()çš„ modifier(ç¬¬[[(emptyConstructor)]]è¡Œ)ã€‚

#+begin_src swift -r -n :results output :exports nil
import SwiftUI

class ShoppingCart: ObservableObject {
    @Published var Title = "Testing"
    @Published var items = 0
}

struct ContentView: View {

    @State private var showCart: Bool = false
    @EnvironmentObject var cart: ShoppingCart (ref:EnvironmentObject)


    var body: some View {
        VStack {
            Text(cart.Title)
            Spacer()
            Button("ä¸‹å–®") {
                self.showCart = true
            }.sheet(isPresented: self.$showCart, content: {
                                                     SecondView()
                                                 })

            Text("ç›®å‰æ•¸é‡\(self.cart.items)")
            Spacer()
            TextField("Change Title", text: $cart.Title)
              .textFieldStyle(RoundedBorderTextFieldStyle())
              .padding()
            Spacer()
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environmentObject(ShoppingCart()) (ref:emptyConstructor)
    }
}
#+end_src
*** SecondView
åŒæ¨£çš„ï¼Œåœ¨ SecondView ä¸­è¦ä½¿ç”¨åˆ° environment object ä¹Ÿè¦ä»¥@EnvironmentObject ä¾†å®£å‘Šåˆ©ç”¨è©² class æ‰€å»ºç«‹çš„ instance(ç¬¬[[(useEnv)]]è¡Œ)ï¼Œè€Œ SecondView çš„ preview ä¹Ÿè¦åŠ ä¸ŠåŒæ¨£çš„ modifier(å‚³å…¥åƒæ•¸)ã€‚
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct SecondView: View {
    @EnvironmentObject var cart: ShoppingCart (ref:useEnv)

    var body: some View {
        Text("\(cart.Title)")
        Spacer()
        Button("åŠ è³¼! æ•¸é‡\(self.cart.items)") {
            self.cart.items += 1
        }
        Spacer()
    }
}

struct SecondView_Previews: PreviewProvider {
    static var previews: some View {
        SecondView().environmentObject(ShoppingCart())
    }
}
#+end_src
é€™è£¡çš„ cart.items åœ¨è®Šæ›´å¾Œï¼ŒContentView çš„æ•¸é‡æœƒå³æ™‚æ›´æ–°ï¼ŒåŒæ¨£çš„ï¼ŒContentView ä¸­è¢«è®Šæ›´çš„ Title ä¹Ÿæœƒå³æ™‚åœ¨ SecondView ä¸­çœ‹å‡ºçµæœã€‚

#+LATEX: \newpage
** Ways to share Data between Views
Three ways for sharing data in SwiftUI[fn:14]
+------------------------------+------------------------------+------------------------------+
|@State                        |@ObservedObject               |@EnvironmentObject            |
+------------------------------+------------------------------+------------------------------+
|Simple properties like String |Can be shared across views    |Similar to @ObservedObject    |
|or Int                        |                              |                              |
+------------------------------+------------------------------+------------------------------+
|Belongs to a specific view    |More complex properties (e.g. |Possiblity to make it         |
|                              |custom type)                  |available to all views through|
|                              |                              |the application itself        |
+------------------------------+------------------------------+------------------------------+
|Never used outside that view  |External reference type that  |If one view changes the model |
|                              |has to be managed (Create an  |all views update              |
|                              |instance of the class, create |                              |
|                              |its own properties, ...)      |                              |
+------------------------------+------------------------------+------------------------------+
|                              |Class should conform to       |                              |
|                              |ObservableObject              |                              |
+------------------------------+------------------------------+------------------------------+
|                              |@Published property wrapper   |                              |
|                              |used to mark properties that  |                              |
|                              |should force a view to refresh|                              |
+------------------------------+------------------------------+------------------------------+
** Further Reading
- [[https://www.youtube.com/watch?v=iH88uJcdzDM][SwiftUI Reactive Intro - Understanding State and Binding in SwiftUI in Xcode 11 (2019)]]
- [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E7%94%A8%E7%8B%80%E6%85%8B%E8%A8%AD%E8%A8%88-swiftui-%E7%95%AB%E9%9D%A2-%E8%AA%8D%E8%AD%98-state-property-binding-27fea6885ead][ç”¨ç‹€æ…‹è¨­è¨ˆ SwiftUI ç•«é¢ â€” èªè­˜ @State propertyï¼Œbinding & Toggle]]
- [[https://www.youtube.com/watch?v=stSB04C4iS4][SwiftUI Tutorial: What's the difference between @State, @ObjectBinding, and @EnvironmentObject?]]

#+LATEX: \newpage
* UserDefaults
:PROPERTIES:
:CUSTOM_ID: UserDefaults
:END:
** å¹¾ç¨®å¯ä»¥åœ¨ iOS app æ°¸ä¹…å„²å­˜è³‡æ–™çš„æ–¹å¼:
- Filesystem: FileManager
- SQL database: CoreData(è‡ªå­¸)
- Cloud: ClodKit, Firebase(ä¸‹å­¸æœŸé€²åº¦)
- UserDefualts
** UserDefautls
æˆ‘å€‘å¯ä»¥å°‡UserDefaultsè¦–ç‚º persistent dictionaryã€‚UserDefaults å¯ä»¥å„²å­˜ Property List é¡å‹çš„è³‡æ–™ã€‚Property List is not a protocol or a struct or anything tangible or Swift-like. It is any combination of String, Int, Bool, Floating point, Date, Array or Dictionary.

A powerful way to do this is using the *Codable* protocol inf Swift. Codable converts structs into Data objects.
** Using userDefaults
#+begin_src swift -r -n :eval no
let defaults = UserDefaults.standard
#+end_src

*** Storing Data
#+begin_src swift -r -n :eval no
defaults.set(object, forKey: "SomeKey")
defautls.setDouble(37.5, forKey: "MyDouble")
#+end_src

*** Retrieving Data
#+begin_src swift -r -n :eval no
let i: Int = defaults.integer(forKey: "MyInt")
let u: URL? = defaults.url(forKey: "MyURL")
let strings: [String]? = defaults.stringArray(forKey: "MyString")
#+end_src
** Demo
*** Create UserDefault.swift
#+begin_src swift -r -n :results output :exports nil
import Foundation
import Combine

class UserSettings: ObservableObject {
    @Published var username: String {
        didSet {
            UserDefaults.standard.set(username, forKey: "username")
        }
    }
    @Published var isVIP: Bool {
        didSet {
            UserDefaults.standard.set(isVIP, forKey: "isAccountVIP")
        }
    }
    init() {
        self.username = UserDefaults.standard.object(forKey: "username") as? String ?? ""
        self.isVIP = UserDefaults.standard.object(forKey: "isAccountVIP") as? Bool ?? true
    }
}
#+end_src
*** use userSetting in ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct settingsView: View {
    @ObservedObject var userSettings = UserSettings()
    var body: some View {
        List {
            HStack {
                Text("Username")
                TextField("Username", text:$userSettings.username)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }
            Toggle(isOn: $userSettings.isVIP) {
                Text("VIP Account")
            }.padding()
        }
    }
}

struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                Text("BALABALA")
                NavigationLink("Settings", destination: settingsView())
                Spacer()
            }.navigationTitle("ä¸»ç•«é¢")
            .padding()
        }
    }
}
#+end_src
#+CAPTION: UserDefault for Settings
#+LABEL:fig:UserDefaults
#+name: fig:UserDefaults
#+ATTR_LATEX: :width 500
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 500
[[file:images/UserDefaults.jpg]]
** Reading Resources
- [[https://www.simpleswiftguide.com/how-to-use-userdefaults-in-swiftui/][How to use UserDefaults in SwiftUI]]

#+latex:\newpage
* Passing data between Views #3: Property Wrappers
:PROPERTIES:
:CUSTOM_ID: Wrappers
:END:
All of these @Something statements are property wrappers. A property wrapper is actually a struct. These structs encapsulate some "template" behavior applied to the vars they wrap.

The property wrapper feature adds *"syntactic sugar"* to make these structs easy to create/use." [fn:15]
** SwiftUIçš„ç‹€æ…‹ç®¡ç†
[[https://onevcat.com/2020/06/stateobject/][è³‡æ–™ä¾†æº:@StateObject å’Œ @ObservedObject çš„åŒºåˆ«å’Œä½¿ç”¨]]
åœ¨2019å¹´SwiftUIå‰›å•ä¸–æ™‚ï¼Œé™¤å»å°ˆé–€ç”¨ä¾†ç®¡ç†æ‰‹å‹¢çš„@GestureStateä»¥å¤–ï¼Œæœ‰ä¸‰å€‹å¸¸ç”¨çš„å’Œç‹€æ…‹ç®¡ç†ç›¸é—œçš„property wrapperï¼Œå®ƒå€‘åˆ†åˆ¥æ˜¯@Stateï¼Œ@ObservedObjectå’Œ@EnvironmentObjectã€‚æ ¹æ“šè·è²¬å’Œä½œç”¨ç¯„åœä¸åŒï¼Œå®ƒå€‘å„è‡ªçš„é©ç”¨å ´æ™¯ä¹Ÿæœ‰å€åˆ¥[fn:16]ã€‚ä¸€èˆ¬ä¾†èªªï¼š
- @Stateç”¨æ–¼Viewä¸­çš„ç§æœ‰ç‹€æ…‹å€¼ï¼Œä¸€èˆ¬ä¾†èªªå®ƒæ‰€ä¿®é£¾çš„éƒ½æ‡‰è©²æ˜¯structå€¼ï¼Œä¸¦ä¸”ä¸æ‡‰è©²è¢«å…¶ä»–çš„viewçœ‹åˆ°ã€‚å®ƒä»£è¡¨äº†SwiftUIä¸­ä½œç”¨ç¯„åœæœ€å°ï¼Œæœ¬èº«ä¹Ÿæœ€ç°¡å–®çš„ç‹€æ…‹ï¼Œæ¯”å¦‚ä¸€å€‹Boolï¼Œä¸€å€‹Intæˆ–è€…ä¸€å€‹Stringã€‚ç°¡å–®èªªï¼Œå¦‚æœä¸€å€‹ç‹€æ…‹èƒ½å¤ è¢«æ¨™è¨˜ç‚ºprivateä¸¦ä¸”å®ƒæ˜¯å€¼é¡å‹ï¼Œé‚£éº¼@Stateæ˜¯é©åˆçš„ã€‚
- å°æ–¼æ›´è¤‡é›œçš„ä¸€çµ„ç‹€æ…‹ï¼Œæˆ‘å€‘å¯ä»¥å°‡å®ƒçµ„ç¹”åœ¨ä¸€å€‹classä¸­ï¼Œä¸¦è®“å…¶å¯¦ç¾ObservableObjectå”è­°ã€‚å°æ–¼é€™æ¨£çš„classé¡å‹ï¼Œå…¶ä¸­è¢«æ¨™è¨˜ç‚º@Publishedçš„å±¬æ€§ï¼Œå°‡æœƒåœ¨è®Šæ›´æ™‚è‡ªå‹•ç™¼å‡ºäº‹ä»¶ï¼Œé€šçŸ¥å°å®ƒæœ‰ä¾è³´çš„Viewé€²è¡Œæ›´æ–°ã€‚Viewä¸­å¦‚æœéœ€è¦ä¾è³´é€™æ¨£çš„ObservableObjectå°è±¡ï¼Œåœ¨è²æ˜æ™‚å‰‡ä½¿ç”¨@ObservedObjectä¾†è¨‚é–±ã€‚
- @EnvironmentObjecté‡å°é‚£äº›éœ€è¦å‚³éåˆ°æ·±å±¤æ¬¡çš„å­Viewä¸­çš„ObservableObjectå°è±¡ï¼Œæˆ‘å€‘å¯ä»¥åœ¨çˆ¶å±¤ç´šçš„Viewä¸Šç”¨.environmentObjectä¿®é£¾å™¨ä¾†å°‡å®ƒæ³¨å…¥åˆ°ç’°å¢ƒä¸­ï¼Œé€™æ¨£ä»»æ„å­Viewéƒ½å¯ä»¥é€šé@EnvironmentObjectä¾†ç²å–å°æ‡‰çš„å°è±¡ã€‚

é€™åŸºæœ¬å°±æ˜¯åˆç‰ˆSwiftUI ç‹€æ…‹ç®¡ç†çš„å…¨éƒ¨äº†ã€‚çœ‹èµ·ä¾†å°æ–¼ç‹€æ…‹ç®¡ç†ï¼ŒSwiftUIçš„è¦†è“‹å·²ç¶“å¾ˆå…¨é¢äº†ï¼Œé‚£ç‚ºä»€éº¼è¦æ–°åŠ ä¸€å€‹@StateObjectproperty wrapperå‘¢ï¼Ÿ
** @StateObject v.s. @ObservedObject
@ObservedObjectä¸ç®¡å­˜å„²ï¼Œæœƒéš¨è‘—Viewçš„å‰µå»ºè¢«å¤šæ¬¡å‰µå»ºã€‚è€Œ@StateObjectä¿è­‰å°åƒåªæœƒè¢«å‰µå»ºä¸€æ¬¡ã€‚å› æ­¤ï¼Œå¦‚æœæ˜¯åœ¨Viewè£¡è‡ªè¡Œå‰µå»ºçš„ObservableObjectmodelå°è±¡ï¼Œå¤§æ¦‚ç‡ä¾†èªªä½¿ç”¨@StateObjectæœƒæ˜¯æ›´æ­£ç¢ºçš„é¸æ“‡ã€‚@StateObjectåŸºæœ¬ä¸Šä¾†èªªå°±æ˜¯ä¸€å€‹é‡å°classçš„@Stateå‡ç´šç‰ˆ[fn:16]
*** ç¨‹å¼ç¯„ä¾‹
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {
    @State private var showRealName = false
    var body: some View {
        VStack {
            Button("å­¸è™Ÿ/å§“å") {
                showRealName.toggle()
            }
            Text("å­¸ç”Ÿ: \(showRealName ? "202010101" : "ç‹å°æ˜")")
            ScoreBoad().padding(.top, 10)
        }
    }
}

class ScoreModel: ObservableObject {
    init() {print("ScoreModel Created")}
    @Published var score: Int = 40
}

struct ScoreBoad: View {
    @ObservedObject var scoreModel = ScoreModel()
    @State private var pass = false

    var body: some View {
        VStack {
            Button("åŠ 10åˆ†") {
                scoreModel.score += 10
                if scoreModel.score >= 60 {
                    pass = true
                }
            }
            Text("åˆ†æ•¸: \(scoreModel.score)")
            Text("åŠæ ¼? \(pass ? "YES" : "NO")")
            GradeText(scoreModel: scoreModel).padding(.top, 10)
        }
    }
}

struct GradeText: View {
    @ObservedObject var scoreModel: ScoreModel

    var body: some View {
        if scoreModel.score >= 90 {
            return Text("ç­‰ç´š:A")
        } else if scoreModel.score >= 80 {
            return Text("ç­‰ç´š:B")
        } else {
            return Text("ç­‰ç´š:QQ")
        }
    }
}
#+end_src
#+CAPTION: @ObservableObject v.s. @StateObject
#+NAME: fig: ObserveState
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/observeState.jpg]]

ä¸Šä¾‹ä¸­ï¼ŒæŒ‰åŠ åˆ†å¾Œï¼ŒåŠæ ¼èˆ‡ç­‰ç´šçš„åˆ¤æ–·éƒ½èƒ½æ­£å¸¸é‹ä½œï¼Œç„¶è€Œä¸€æ—¦åˆ‡æ›å­¸ç”Ÿå§“åèˆ‡å­¸è™Ÿï¼ŒscoreModelçš„åˆ†æ•¸å°±æœƒè¢«é‡ç½®ç‚º60åˆ†ã€‚åŸå› åœ¨æ–¼æŒ‰ä¸‹ã€ŒåŠ åˆ†ã€buttonå°è‡´ContentViewçš„ç‹€æ…‹ç™¼ç”Ÿè®ŠåŒ–ï¼ŒContentView.bodyè¢«é‡æ–°æ±‚å€¼ï¼Œé€£å¸¶scoreBoardé€™å€‹Viewä¹Ÿè¢«é‡å»ºï¼Œè€Œå…¶ä¸­çš„scoreModelä¹Ÿä¸€èµ·é‡æ–°ç”Ÿæˆï¼Œæ–¼æ˜¯ä¹‹å‰æ‰€åšçš„æ”¹è®Š(ç‹€æ…‹)å°±æ¶ˆå¤±äº†ã€‚
*** Create once
åªè¦ç†è§£äº†@ObservedObjectå­˜åœ¨çš„å•é¡Œï¼Œ@StateObjectçš„æ„ç¾©ä¹Ÿå°±å¾ˆæ˜é¡¯äº†ã€‚@StateObjectå°±æ˜¯@Stateçš„å‡ç´šç‰ˆï¼š@Stateæ˜¯é‡å°structç‹€æ…‹æ‰€å‰µå»ºçš„å­˜å„²ï¼Œ@StateObjectå‰‡æ˜¯é‡å°ObservableObjectclassçš„å­˜å„²ã€‚å®ƒä¿è­‰é€™å€‹classå¯¦ä¾‹ä¸æœƒéš¨è‘—Viewè¢«é‡æ–°å‰µå»ºã€‚å¾è€Œè§£æ±ºå•é¡Œ[fn:16]ã€‚

è§£æ±ºæ–¹æ¡ˆï¼šæŠŠscoreBoardä¸­çš„@ObservedObjectæ”¹ç‚º@StateObject
#+begin_src swift -r -n :results output :exports nil
...
struct ScoreBoad: View {
    @ObservedObject var scoreModel = ScoreModel()
    @State private var pass = false

    var body: some View {
        ....
    }
}
#+end_src
** ä½¿ç”¨@EnvironmentObjectä¿æŒç‹€æ…‹
é™¤äº†@StateObjectå¤–ï¼Œå¦ä¸€ç¨®è®“ç‹€æ…‹objectä¿æŒä½çš„æ–¹å¼ï¼Œæ˜¯åœ¨æ›´å¤–å±¤ä½¿ç”¨.environmentObjectï¼š
#+begin_src swift -r -n :results output :exports nil
struct SwiftUINewApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView().environmentObject(scoreModel())
        }
    }
}
#+end_src
é€™æ¨£ï¼ŒscoreModelå°è±¡å°‡è¢«æ³¨å…¥åˆ°ç’°å¢ƒä¸­ï¼Œä¸å†éš¨è‘—ContentViewçš„åˆ·æ–°è€Œè®Šæ›´ã€‚åœ¨ä½¿ç”¨æ™‚ï¼Œåªéœ€è¦éµå¾ªæ™®é€šçš„environmentæ–¹å¼ï¼ŒæŠŠModelè²æ˜ç‚º@EnvironmentObjectå°±è¡Œäº†ï¼š
#+begin_src swift -r -n :results output :exports nil
struct ScoreBoard: View {
    @EnvironmentObject var scoreModel: ScoreModel
    // ...

    // ScoreText(model: model).padding(.top, 20)
    ScoreText().padding(.top, 20)
}

struct GradeText: View {
    @EnvironmentObject var scoreModel: ScofeModel
    // ...
}
#+end_src
** Property wrapper syntactic Sugar
#+begin_src swift -r -n :eval no
@Published var dice: Dice = Dice()
#+end_src
ä¸Šè¿°å®£å‘Šå¯¦éš›åŒä»¥ä¸‹ struct
#+begin_src swift -r -n :eval no
struct Published {
    var wrappedValue: Dice
    var projectedValue: Publisher<Dice, Never>
}
#+end_src
æ¥ä¸‹ä¾† Swift ç”¢ç”Ÿä»¥ä¸‹è®Šæ•¸
#+begin_src swift -r -n :eval no
var _dice: Published = Published(wrappedValue: Dice())
var dice: Dice {
    get { _dice.wrappedValue  }
    set { _dice.wrappedValue = newValue }
}
#+end_src

#+latex:\newpage
* MVVM
:PROPERTIES:
:CUSTOM_ID: SW-MVVM
:END:
** Design pattern
MVVMçš„æ¦‚å¿µæœ€æ—©æ‡‰è©²æ˜¯åœ¨2005å¹´ç”±Microsoftçš„[[https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/][John Gossman]]æå‡ºä¾†çš„ï¼Œå®ƒçš„æ¦‚å¿µæ˜¯ï¼Œæ•´å€‹Swift projectæœƒæ‹†åˆ†æˆä¸‰å€‹éƒ¨ä»½: Viewã€ViewModelã€Modelï¼Œå…¶ä¸­Viewçš„è§’è‰²å°±æ˜¯å–®ç´”çš„è¦–è¦ºå…ƒä»¶ï¼Œåƒæ˜¯æŒ‰éˆ•ã€æ–‡å­—æ¨™ç±¤ç­‰ç­‰ï¼Œåœ¨Viewè£¡é¢ä¸æœƒæœ‰é‚è¼¯ã€ç‹€æ…‹ç­‰ç­‰ï¼Œå–®ç´”å°±æ˜¯å€‹å‘ˆç¾è³‡æ–™çš„å…ƒä»¶ã€‚è€Œè¦è®“Viewå‘ˆç¾è³‡æ–™ï¼Œæœ€ç›´è¦ºçš„æ–¹å¼ï¼Œå°±æ˜¯æŠŠViewè·ŸModelåšç¶å®šï¼Œè®“Viewçš„å…ƒä»¶è·Ÿè‘—Modelä¸€èµ·åšè®ŠåŒ–ã€‚ä½†é€™æ¨£æœƒæœ‰å€‹å•é¡Œï¼Œå°±æ˜¯é€šå¸¸Modelä¾†çš„è³‡æ–™ï¼Œä¸¦ä¸æ˜¯ç°¡å–®å°±èƒ½è½‰æ›æˆViewçš„æ¨£å¼çš„ï¼Œé€™æ™‚å€™å°±éœ€è¦æœ‰å€‹ç‰©ä»¶ï¼Œä»‹åœ¨Viewè·ŸModelçš„ä¸­é–“ï¼Œé€™å€‹ç‰©ä»¶æœƒæŒç®¡é€™äº›è·ŸViewé«˜åº¦ç›¸é—œçš„é‚è¼¯çš„æ“ä½œï¼Œåƒæ˜¯è½‰æ›Dateç‰©ä»¶è®Šæˆäººçœ‹å¾—æ‡‚çš„æ–‡å­—æ ¼å¼ç­‰ï¼Œç¨±ä¹‹ç‚ºViewModelã€‚ä¸Šé¢çš„æ¦‚å¿µå¯ä»¥ç•«æˆé€™æ¨£çš„è³‡æ–™æµï¼š

#+CAPTION: MVVM Architecture
#+NAME: fig: MVVMPNG
#+ATTR_LATEX: :width 500
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 600
[[file:images/MVVM-Basic.jpg]]

åœ¨iOSé–‹ç™¼ä¸Šï¼Œä¾ç…§ä¸Šè¿°MVVMçš„å®šç¾©ï¼ŒContentViewè®Šæˆä¸€å€‹å–®ç´”çš„Viewï¼Œè€Œæˆ‘å€‘æœƒå¦å¤–ç”¢ç”Ÿä¸€å€‹ViewModelä¾†è² è²¬presentational logicè·Ÿéƒ¨ä»½çš„controller logicã€‚æ‰€ä»¥åœ¨ContentViewè£¡é¢ï¼Œå°±åªæœƒæœ‰ï¼š
1. View logicï¼Œæ‰€æœ‰è·Ÿå‘ˆç¾æœ‰é—œçš„Code
1. ç¶å®šViewModel
è€Œåœ¨ViewModelè£¡é¢ï¼Œå‰‡æ˜¯è² è²¬å…©å€‹éƒ¨ä»½ï¼š
1. Controller logicï¼Œå¦‚pagination, error handling,â€¦ etc
1. Presentation logicï¼Œæä¾›æ¥å£è®“Viewç¶å®š(binding)
é–‹ç™¼ä¸Šï¼Œä¸€æ—¦Viewç¶å®šå¥½ViewModelçš„è³‡æ–™ï¼Œåœ¨æ’°å¯«å•†æ¥­é‚è¼¯çš„æ™‚å€™ï¼Œå°±å¯ä»¥ä¸ç”¨ç®¡åŒ…æ‹¬å‹•ç•«ã€è½‰å ´ã€main threadç­‰ç­‰è·ŸViewç›¸é—œçš„å•é¡Œï¼Œå› ç‚ºåˆ†å·¥æ˜ç¢ºæ‰€ä»¥å°±ä¸æœƒæœ‰å¯«èµ·ä¾†ç¶æ‰‹ç¶è…³çš„æ„Ÿè¦ºã€‚æ›´æ£’çš„æ˜¯ï¼Œä¸¦ä¸”å› ç‚ºViewModelæ˜¯ä¸€å€‹å–®ç´”çš„ã€æ²’æœ‰ç›¸ä¾æ–¼Viewçš„ç‰©ä»¶ï¼Œæ‰€ä»¥è¦åšæ¸¬è©¦ç°¡å–®å¤šäº†ï¼
[[https://www.codementor.io/@koromiko/mvvm-app-cl1wvw2sh][è³‡æ–™ä¾†æº: æ­¡è¿ä¾†åˆ°çœŸå¯¦ä¸–ç•Œ - åŸä¾†æ˜¯é‚£å€‹å‚³èªªä¸­çš„MVVMé˜¿]]
** What is the idea behind MVVM
*** Model
- Business logic
- UI Independent
*** View
- Presentation
- User interaction
*** ViewModel
- Presentation logic
- Glue between Model and View
*** ç‚ºä»€éº¼è¦æ‹†æˆä¸‰éƒ¨ä»½(What does it solve?)
- MVC - Massive View Controller
- Testability
- Code organization
- Code reusability
*** Limitations / Cons
- Requires binding
- Potential for boilerplate code
- Overkill for simple views and logic
- Doesn't cover every case
** DEMO
ä»¥"æ¨è–¦æ›¸å–®"çš„ APP ç‚ºä¾‹:
- Model: åŒ…å«æ›¸åã€ä½œè€…ã€å‡ºç‰ˆç¤¾....ï¼Œè€Œå¯¦éš›çš„è³‡æ–™ä¾†æºå¯èƒ½æ˜¯é›²ç«¯è³‡æ–™åº«(Firebase)ã€Web APIã€æœ¬æ©Ÿè³‡æ–™åº«(Core data)ã€‚
    #+begin_src swift -r -n :eval no
struct Book {
    let title: String
    let author: String
    let dateReleased: String
    let publishCamp: String
    let publishCity: String
    let isFavorite: Bool
}
  #+end_src
- View: åœ¨ APP ç•«é¢ä¸Šå‘ˆç¾ Model ä¸­è³‡æ–™çš„å…ƒä»¶ï¼Œå¦‚ Text, Image, Button, List.....
- ViewModel: å°‡ Model ä¸­çš„è³‡æ–™å–å‡ºï¼Œä¾› View å‘ˆç¾ï¼Œæˆ–æ˜¯æ¥å— View è¼¸å…¥çš„è³‡æ–™ï¼Œå­˜å› Modelã€‚ä»¥"æ¨è–¦æ›¸å–® APP"ç‚ºä¾‹ï¼Œå…¶ ViewModel å¯èƒ½åŒ…å«å¦‚ä¸‹ struct:
  #+begin_src swift -r -n :eval no
struct BookDetailViewModel {
    var book: Book

    var isFavorite: Bool

    init(book: Book) {
        self.book = book
        self.isFavorite = false
    }

    var title: String {
        return self.book.title
    }

    var author: String {
        return self.book.author
    }

    var dateReleased: String {
        return self.book.dateReleased
    }

    // å‘ˆç¾æ™‚è¦æ±‚ä»¥ é æµå‡ºç‰ˆç¤¾(å°åŒ—å¸‚) çš„æ ¼å¼ä¾†å‘ˆç¾
    var publisher: String {
        let output = self.book.publishCamp + "(" + self.book.publishCity + ")"
        return output
    }
}
  #+end_src
  å¾Modelä¸­å¯ä»¥çœ‹åˆ°æ›¸ç±çš„è¨˜éŒ„æ¬„ä½åªæœ‰"å‡ºç‰ˆç¤¾"(publishCamp)å’Œ"å‡ºç‰ˆåœ°é»"(publishCity)ï¼Œä½†è‹¥appå°é¡¯ç¤ºçµæœçš„æ ¼å¼è¦æ±‚ç‚º"å‡ºç‰ˆç¤¾(å‡ºç‰ˆåœ°é»)"ï¼Œå‰‡å¯ä»¥åœ¨ViewModelä¸­ä¾†è™•ç†ã€‚
  æ­¤å¤–ï¼Œå¦‚æœåœ¨ View ä¸Šæœ‰ä¸€å€‹ Favorite Buttonï¼Œå‰‡ç•¶ user é»äº† Favorite å¾Œï¼ŒViewModel æ‡‰è² è²¬å°‡ struct ä¸­çš„ isFavorite æ”¹å­˜ Trueï¼Œä¸¦å›å­˜è‡³ Model ä¸­ã€‚Model çš„è³‡æ–™åªèƒ½é€é ViewModel ä¾†æ–°å¢åˆªé™¤ï¼ŒView ç„¡æ³•ç›´æ¥æŸ“æŒ‡ã€‚
  Model èˆ‡ UI å®Œå…¨ç„¡é—œï¼Œå–®ç´”ç”¨ä¾†å„²å­˜è³‡æ–™ï¼ŒViewModel ç‚º Model èˆ‡ View æºé€šçš„æ©‹æ¨‘ã€‚
** Modelè¦ç”¨Structæˆ–æ˜¯Class
[[https://www.appcoda.com.tw/swift-class/][è³‡æ–™ä¾†æº:Swift Class vs Structï¼šè¨­è¨ˆ Model æ™‚ï¼Œè©²ç”¨ Struct é‚„æ˜¯ Class å‘¢ï¼Ÿ]]
*** Struct èˆ‡ Class çš„ä¸åŒæ€§è³ª
é¦–å…ˆï¼Œç•¶æˆ‘å€‘æŒ‡æ´¾ (assign) ä¸€å€‹å¯¦é«”çµ¦ä¸€å€‹è¾¨è­˜ç¬¦ï¼ˆidentifierï¼Œä¹Ÿå°±æ˜¯è®Šæ•¸ï¼å¸¸æ•¸åï¼‰çš„æ™‚å€™ï¼Œå¦‚æœè©²å¯¦é«”æ˜¯ struct çš„è©±ï¼Œè©²è¾¨è­˜ç¬¦æ‰€å®¹ç´çš„æœƒæ˜¯è©²å¯¦é«”çš„æ‰€æœ‰å…§å®¹ï¼›ä½†å¦‚æœå®ƒæ˜¯ class çš„è©±ï¼Œé€™å€‹è¾¨è­˜ç¬¦å°±åªæœƒå®¹ç´å­˜æ”¾è©²å¯¦é«”çš„ä½å€ï¼š
#+begin_src swift -r -n :results output :exports nil
// ç”¨ struct å®šç¾© Dogã€‚
struct Dog {
    var name = "Bart"
}
// æ•´å€‹ Dog å¯¦é«”éƒ½æœƒè¢«å­˜åˆ° myDog è£¡ã€‚
var myDog = Dog()
// ç”¨ class å®šç¾© Catã€‚
class Cat {
    var name = "Mimi"
}
// myCat åªæœƒå„²å­˜ Cat å¯¦é«”çš„ä½å€ã€‚Cat å¯¦é«”æœ¬èº«æœƒè¢«å­˜åˆ°åˆ¥çš„åœ°æ–¹ã€‚
var myCat = Cat()
#+end_src
ä¹Ÿå°±æ˜¯èªªï¼Œç•¶æˆ‘å€‘ä½¿ç”¨è¾¨è­˜ç¬¦çš„æ™‚å€™ï¼Œå¦‚æœå®ƒçš„å‹åˆ¥æ˜¯ struct çš„è©±ï¼Œæˆ‘å€‘åœ¨æ“ä½œçš„å¯¦é«”éƒ½æœƒæ˜¯æœ¬åœ°çš„ã€‚ä½†æ˜¯ç•¶æˆ‘å€‘åœ¨æ“ä½œ class å‹åˆ¥çš„è¾¨è­˜ç¬¦çš„è©±ï¼Œé‚£éº¼æˆ‘å€‘å¯¦éš›ä¸Šæ˜¯é€éè¾¨è­˜ç¬¦åœ¨æ“ä½œä¸€å€‹é ç«¯çš„å¯¦é«”ã€‚æ‰€ä»¥ï¼Œç•¶æˆ‘å€‘æ›´æ”¹é€™äº›å¯¦é«”çš„å±¬æ€§çš„æ™‚å€™ï¼Œå®ƒå€‘çš„è¡Œç‚ºå°±ä¸å¤ªä¸€æ¨£äº†ï¼š
#+begin_src swift -r -n :results output :exports nil
// ä½¿ç”¨ structã€‚
var herDog = Dog() {
    // å¦‚æœ herDog æœ‰è®Šå‹•çš„è©±å°±é¡¯ç¤ºè¨Šæ¯ã€‚
    didSet {
        print("Her dog is changed!")
    }
}
herDog.name = "Starlord"
// Her dog is changed!
// ä½¿ç”¨ classã€‚
var herCat = Cat() {
    didSet {
        print("Her cat is changed!")
    }
}
herCat.name = "Mumu"
// æ²’æœ‰è¨Šæ¯ã€‚
#+end_src
æ€éº¼æœƒæœ‰é€™æ¨£çš„å·®åˆ¥å‘¢ï¼Ÿå› ç‚º herDog å„²å­˜äº†æ‰€æœ‰çš„ Dog å¯¦é«”å…§å®¹ï¼Œæ‰€ä»¥ä»»ä½• Dog å¯¦é«”çš„å±¬æ€§çš„è®Šå‹•ï¼Œå°±ç­‰æ–¼èªª herDog æœ¬èº«æœ‰è®Šå‹•ã€‚ç„¶è€Œï¼ŒherCat ä¸¦æ²’æœ‰å„²å­˜ Cat å¯¦é«”çš„å…§å®¹ï¼Œæ‰€ä»¥ Cat å¯¦é«”å±¬æ€§çš„è®Šå‹•æ˜¯åœ¨åˆ¥çš„åœ°æ–¹ç™¼ç”Ÿçš„ï¼Œä¸” herCat æœ¬èº«æ‰€å„²å­˜çš„ Cat å¯¦é«”ä½å€ä¸¦æ²’æœ‰ä»»ä½•çš„æ”¹è®Šã€‚
ç”±åœ–[[fig: MVVMPNG]]å¯çœ‹å‡ºï¼Œ
*** MMVMä¸­çš„Model
** DICE DEMO
** Further Reading Resources
- [[https://www.youtube.com/watch?v=1IlUBHvgY8Q&t=29s][SwiftUI MVVM Programming with ObservableObject @Published @ObservedObject]]
- [[https://www.youtube.com/watch?v=LntH6moCuo0][SwiftUI 2.0: MVVM - A Practical Approach]]
- [[https://www.youtube.com/watch?v=gkAV4D1nopA][SwiftUI Tip Calculator Using MVVM Design Pattern]]
- [[https://www.youtube.com/watch?v=cbqMkIG6Qeg][Understanding MVVM Design Pattern]]: è¬›çš„è¶…æ¸…æ¥š
- Video: [[https://www.youtube.com/watch?v=EhtK_H9LsYQ][MVVM SwiftUI - Model View ViewModel Pattern - Getting Started]]
- Video: [[https://www.youtube.com/watch?v=LntH6moCuo0]]
- Video: [[https://www.youtube.com/watch?v=sWx8TtRBOfk][MVVM in Practice - RWDevCon Session - raywenderlich.com]]
- GitHub: https://github.com/rebeloper/SwiftUIMVVM.git
#+latex:\newpage
* Web API: URLSession v.s. JSONDecoder
** Demo 1
*** ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct Todo: Codable, Identifiable {
    public var id: Int
    public var title: String
    public var completed: Bool
}

class FetchToDo: ObservableObject {
  // 1.
  @Published var todos = [Todo]()

    init() {
        let url = URL(string: "https://jsonplaceholder.typicode.com/todos")!
        // 2.
        URLSession.shared.dataTask(with: url) {(data, response, error) in
            do {
                if let todoData = data {
                    // 3.
                    let decodedData = try JSONDecoder().decode([Todo].self, from: todoData)
                    DispatchQueue.main.async {
                        self.todos = decodedData
                    }
                } else {
                    print("No data")
                }
            } catch {
                print("Error")
            }
        }.resume()
    }
}

struct ContentView: View {
    // 1.
    @ObservedObject var fetch = FetchToDo()
    var body: some View {
        VStack {
            // 2.
            List(fetch.todos) { todo in
                VStack(alignment: .leading) {
                    // 3.
                    Text(todo.title)
                    Text("\(todo.completed.description)") // print boolean
                        .font(.system(size: 11))
                        .foregroundColor(Color.gray)
                }
            }
        }
    }
}
#+end_src
#+LABEL:fig:JSON-1
#+name: fig:JSON-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/json-1.jpg]]
** Demo 2
*** MVVM
- Model: FlowModel.swift
- View: ContentView.swift
- ViewModel: Flow.swift
*** FlowModel.swift
#+begin_src swift -r -n :results output :exports nil
import Foundation

struct FlowModel: Decodable, Hashable {
    var å¹´: Int? = nil
    var æœˆ: Int? = nil
    var ç¸½é‹é‡: Int? = nil
    var æ—¥å‡é‹é‡: Int? = nil
    var å‡æ—¥å‡é‹é‡: Int? = nil
    var æœˆå°ä¸Šåˆ·å¡æ—¥å‡ç­†æ•¸: Double? = nil
    var è»Šä¸Šåˆ·å¡æ—¥å‡ç­†æ•¸: Double? = nil
    var å”®ç¥¨æ©Ÿæ—¥å‡ç­†æ•¸: Double? = nil
    var è£œç¥¨æ—¥å‡ç­†æ•¸: Double? = nil
    var åœ˜é«”ç¥¨æ—¥å‡ç­†æ•¸: Double? = nil
}
#+end_src

#+RESULTS:
*** ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct ContentView: View {
    @ObservedObject var flow = FetchFlow()

    var body: some View {
        NavigationView {
            List() {
                ForEach(flow.flows, id: \.self) {(item) in
                    NavigationLink(destination: Text("ç¸½é‹é‡: \(item.ç¸½é‹é‡!)")) {
                        HStack {
                            Text("\(item.å¹´!)å¹´\(item.æœˆ!)æœˆ")
                            Text("\(item.æ—¥å‡é‹é‡!)")
                        }
                    }
                }
            }.navigationTitle("")
        }
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

#+end_src
*** Flow.swift
#+begin_src swift -r -n :results output :exports nil
import Foundation
class FetchFlow: ObservableObject {
    @Published var flows = [FlowModel]()
    init() {
        let urlstr = "https://data.kcg.gov.tw/dataset/6f29f6f4-2549-4473-aa90-bf60d10895dc/resource/30dfc2cf-17b5-4a40-8bb7-c511ea166bd3/download/lightrailtraffic.json"
        guard let url = URL(string: urlstr) else {
            print("Invalid json url")
            return
        }
        URLSession.shared.dataTask(with: url) {(data, response, error) in
            do {
                if let flowData = data {
                    let decodeData = try JSONDecoder().decode([FlowModel].self, from: flowData)

                    DispatchQueue.main.async {
                        self.flows = decodeData
                    }
                } else {
                    print("No data")
                }
            } catch {
                print("\(error)")
            }
        }.resume()
    }
}
#+end_src
*** Result
#+LABEL:fig:JSON-2
#+name: fig:JSON-2
#+ATTR_LATEX: :width 500
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 600
[[file:images/json-2.jpg]]
** å…¬é–‹è³‡æ–™å¹³å°
- [[https://data.gov.tw/][æ”¿åºœè³‡æ–™é–‹æ”¾å¹³å°]]
- [[https://data.kcg.gov.tw/dataset][é«˜é›„å¸‚æ”¿åºœé–‹æ”¾è³‡æ–™é›†]]
- [[https://data.tainan.gov.tw/dataset][å°å—å¸‚æ”¿åºœé–‹æ”¾è³‡æ–™é›†]]
- [[https://ptx.transportdata.tw/PTX/Service][å…¬å…±é‹è¼¸æ•´åˆè³‡è¨Š]]
- [[https://kaleidosblog.s3-eu-west-1.amazonaws.com/json/tutorial.json][country/code JSON sample]]
** Further Reading
- [[https://www.youtube.com/watch?v=tdxKIPpPDAI][iOS Swift Tutorial: Use Web APIs and JSON Data with Swift 5]]- [[https://www.ioscreator.com/tutorials/swiftui-json-list-tutorial][SwiftUI Fetch JSON Data into List]]
- [[https://programmingwithswift.com/parse-json-from-file-and-url-with-swift/][Parse JSON from file and URL with Swift]]
- [[https://www.youtube.com/watch?v=1en4JyW3XSI][Making an API call and fetch JSON data in SwiftUI]]
- [[https://benoitpasquier.com/encoding-decoding-json-swift4/][The best way to encode and decode JSON in Swift4 ]]
- [[https://www.reddit.com/r/swift/comments/emw0i3/jsondecoder_fails_if_i_dont_have_an_id_for_each/][JSONDecoder fails if I don't have an "id" for each item... why doesn't UUID work?]]
- [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E8%A7%A3%E6%B1%BAjson-key%E4%B8%8D%E5%9B%BA%E5%AE%9A%E6%99%82%E5%87%BA%E7%8F%BE-no-value-associated-with-key-codingkeys-%E7%8B%80%E6%B3%81-720d7d09486a][è§£æ±ºJson Keyä¸å›ºå®šæ™‚å‡ºç¾â€œNo value associated with key CodingKeysâ€ ç‹€æ³]]
#+latex: \newpage
* STRT Protocols
:PROPERTIES:
:CUSTOM_ID: SW-Protocols
:END:
- Protocols are a fundamental feature of Swift. They play a leading role in the structure of the Swift standard library and are a common method of abstraction. They provide a similar experience to interfaces that some other languages have. An advantage of protocols in Swift is that objects can conform to multiple protocols.[fn:17]
- Protocolæ˜¯ä¸€å€‹åªå®£å‘Šä¸å®šç¾©çš„å‹åˆ¥ï¼Œç„¶è€Œé€™å€‹ç‰¹æ€§å¯ä»¥è®“æˆ‘å€‘çš„ç¨‹å¼æ›´æœ‰å½ˆæ€§ï¼Œåƒåœ¨IOS SDKè£¡é¢ï¼Œè€³ç†Ÿèƒ½è©³çš„Delegateï¼Œå°±å¤§é‡çš„é‹ç”¨Potocolï¼Œæ–¹ä¾¿æˆ‘å€‘å®¢è£½åŒ–äº‹ä»¶ç™¼ç”Ÿæ™‚è¦è™•ç†çš„äº‹æƒ…ã€‚[fn:18]

- å°ä»»ä½•ç¨‹å¼é–‹ç™¼ä¾†èªªï¼Œæ¸›å°‘é‡è¦†çš„ codeï¼ŒæŠŠæ¬Šè²¬æ˜ç¢ºåˆ†é–‹ï¼Œè®“ code ç¶­è­·æ€§è®Šå¥½ï¼Œæ˜¯éå¸¸é‡è¦çš„èª²é¡Œã€‚è€Œåœ¨ç¾ä»Šçš„è»Ÿé«”é–‹ç™¼æ¨¡å¼ä¸­ï¼Œæœ‰è¨±å¤šæ–¹æ³•å¯ä»¥åšåˆ°é€™é»ï¼Œæœ€ç‚ºäººæ‰€çŸ¥çš„ä¸€å€‹æ¨¡å¼ï¼Œå°±æ˜¯åˆ©ç”¨ç¹¼æ‰¿ (Inheritance)ï¼ŒæŠŠæœƒé‡è¦†åˆ©ç”¨çš„éƒ¨ä»½æ”¾åœ¨æ¯é¡åˆ¥ï¼Œè®“å…¶å®ƒå­é¡åˆ¥å»ç¹¼æ‰¿ã€‚å¦å¤–ä¸€ç¨®åšæ³•ï¼Œå‰‡æ˜¯åˆ©ç”¨ Composition Patternï¼Œå°‡åŠŸèƒ½åšæˆçµ„ä»¶åˆ†å‡ºä¾†ï¼Œè®“éœ€è¦çš„æ¨¡çµ„å»çµ„åˆå–ç”¨ã€‚[fn:19]
#+begin_verse
A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol. [fn:20]
#+end_verse

- å”å®šæä¾›é¡å‹å¯ä»¥åšçš„è³‡è¨Šï¼ŒClasses å’Œ structs å‰‡æä¾›ç‰©ä»¶çš„è³‡è¨Šï¼Œå”å®šå‰‡æä¾›ç‰©ä»¶å°‡æœƒåŸ·è¡Œçš„å‹•ä½œã€‚[fn:21]
#+begin_verse
å”å®šæ˜¯ Swift ä¸€å€‹é‡è¦çš„ç‰¹æ€§ï¼Œå®ƒæœƒå®šç¾©å‡ºç‚ºäº†å®ŒæˆæŸé …ä»»å‹™æˆ–åŠŸèƒ½æ‰€éœ€çš„æ–¹æ³•ã€å±¬æ€§ï¼Œä½†æ˜¯æœ¬èº«ä¸æœƒå¯¦ä½œé€™äº›ä»»å‹™è·ŸåŠŸèƒ½ï¼Œè€Œåƒ…åƒ…åªæ˜¯è¡¨é”å‡ºè©²ä»»å‹™æˆ–åŠŸèƒ½çš„åç¨±ã€‚å”å®šç‚ºæ–¹æ³•ã€å±¬æ€§ã€ä»¥åŠå…¶ä»–ç‰¹å®šçš„ä»»å‹™éœ€æ±‚æˆ–åŠŸèƒ½å®šç¾©è—åœ–ã€‚å”å®šå¯è¢« classã€structã€æˆ– enum é¡å‹æ¡ç´ä»¥æä¾›æ‰€éœ€åŠŸèƒ½çš„å…·é«”å¯¦ç¾ã€‚æ»¿è¶³äº†å”å®šä¸­éœ€æ±‚çš„ä»»æ„é¡å‹éƒ½å«åšéµå¾ªäº†è©²å”å®šã€‚
#+end_verse

é™¤äº†æŒ‡å®šéµå¾ªé¡å‹å¿…é ˆå¯¦ç¾çš„è¦æ±‚å¤–ï¼Œä½ å¯ä»¥æ“´å±•ä¸€å€‹å”å®šä»¥å¯¦ç¾å…¶ä¸­çš„ä¸€äº›éœ€æ±‚æˆ–å¯¦ç¾ä¸€å€‹ç¬¦åˆé¡å‹çš„å¯ä»¥åˆ©ç”¨çš„é™„åŠ åŠŸèƒ½ã€‚[fn:22]
- ä¾‹å¦‚ï¼Œä½ å¯èƒ½æœ‰ä¸€å€‹åç‚ºstrçš„è®Šé‡ï¼Œå…¶é¡å‹ç‚ºStringã€‚èº«ç‚ºä¸€å€‹é–‹ç™¼äººå“¡ï¼Œä½ æ‡‰è©²çŸ¥é“strä»£è¡¨Stringï¼Œå¦‚æœæˆ‘å€‘å®šç¾©äº†ä¸€å€‹åç‚ºStringProtocolçš„å”å®šï¼Œå®ƒå…·æœ‰æ‰€æœ‰çš„Stringçš„APIï¼Œæˆ‘å€‘å¯ä»¥æ“´å±•ä»»ä½•é¡å‹å»éµå¾ªStringProtocolï¼ˆæ„æ€æ˜¯æ»¿è¶³å…¶æ‰€æœ‰è¦æ±‚ï¼‰ï¼Œå¦‚æ­¤ä¸€ä¾†ï¼Œå³å¯ä»¥ä½¿ç”¨è©²å°è±¡ï¼Œè®“å®ƒå°±åƒæ˜¯ä¸€å€‹Stringï¼Œå„˜ç®¡æˆ‘å€‘ä¸çŸ¥é“å®ƒæ˜¯ä»€éº¼ï¼å¦‚æœçœ‹èµ·ä¾†åƒä¸€éš»é´¨å­ï¼Œæ¸¸æ³³åƒä¸€éš»é´¨å­ï¼Œå«è²åƒä¸€éš»é´¨å­ï¼Œé‚£å°±æ˜¯ä¸€éš»é´¨å­ã€‚æˆ‘å€‘æ–°çš„StringProtocolå¯ä»¥å‘Šè¨´é‚£äº›éµå®ˆå®ƒå”å®šçš„é¡å‹èƒ½å¤ åšä»€éº¼ï¼Œä¸”ä¸éœ€è¦çŸ¥é“é€™äº›é¡å‹çš„è³‡è¨Šã€‚[fn:21]
** Protocol Syntax
*** Syntax
#+begin_src swift -r -n :results output :exports nil
protocol SomeProtocol {
    // protocol definition goes here
}
#+end_src
Classes , structs, enums can adopt these protocol by placing protocolâ€™s name after the typeâ€™s name, separated by a colon, as part of their definition. Multiple protocols can be listed, and are separated by commas:[fn:23]
#+begin_src swift -r -n :results output :exports nil
struct SomeStructure: FirstProtocol, AnotherProtocol {
    //structure definition goes here
}
#+end_src
*** DEMO
#+begin_src swift -r -n :results output :exports nil
protocol Polite {
    func sayHello()
}

struct Teacher: Polite {
    var name: String
    func sayHello() {
        print("åŒå­¸å¥½")
    }
}

struct Student: Polite {
    var name: String
    func sayHEllo() {
        print("è€å¸«å¥½")
    }
}

var aPolitePerson: Polite = Teacher()
aPolitePerson.name = "Mr. Yen"
aPolitePerson.sayHellow()
aPolitePerson = Student()
aPolitePerson.sayHello()
#+end_src
*** Adding property requirements
source: [[https://abhimuralidharan.medium.com/all-about-protocols-in-swift-11a72d6ea354][All about protocols in swift]]
- A protocol can have properties as well as methods that a class, enum or struct conforming to this protocol can implement.
- A protocol declaration only specifies the required property name and type. It doesnâ€™t say anything about whether the property should be a stored one or a computed one.
- A protocol also specifies whether each property must be gettable or gettable and settable.
- Property requirements are always declared as variable properties, prefixed with the var keyword.
- Gettable and settable properties are indicated by writing { get set } after their type declaration, and gettable properties are indicated by writing { get }.
#+begin_src swift -r -n :results output :exports nil
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
#+end_src
*** Protocols with mutating methods
Mutating methods are methods that we use on value types like structs and enums. These methods are allowed to modify the instance it belongs to and any properties of that instance. A small example:

Consider a simple struct Rectangle:
#+begin_src swift -r -n :results output :exports nil
struct Rectangle {
    var width = 1
    var height = 1

    func area() -> Int {
        return width * height
    }

    mutating func scaleBy(value: Int) {
        width *= value
        height *= value
    }
}
#+end_src
The scaleBy(value:) method modifies the value of width and height. So it should be marked as mutating. Otherwise the compiler will throw error at you.

#+begin_verse
If you mark a protocol instance method requirement as mutating, you do not need to write the mutatingkeyword when writing an implementation of that method for a class. The mutating keyword is only used by structures and enumerations.
#+end_verse
Consider an enum and class implementing a protocol with mutating function:
#+begin_src swift -r -n :results output :exports nil
protocol Togglable {
    mutating func toggle()
}

enum OnOffSwitch: Toggglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}

var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()

class ToggleClass: Togglable {
    var someBool = false
    func toggle() {
        someBool = true
    }
}

let toggleClassObj = ToggleClass()
toggleClassObj.toggle()
#+end_src
*** Initializer Requirements
Protocols can have specific initializers like normal methods which the conforming types can implement.
#+begin_src swift -r -n :results output :exports nil
protocol SomeProtocol {
    init(someParameter: Int)
}
#+end_src
** DEMO
#+begin_src swift -r -n :results output :exports nil
protocol Sound {
    func makeSound()
}

struct Dog: Sound {
    func makeSound() {
        print("Woof")
    }
}

struct Tree: Sound {
    func makeSound() {
        print("Susrrate")
    }
}

struct iPhone: Sound {
    func makeSound() {
        print("Ring")
    }
}
#+end_src
** ç¯„ä¾‹
*** ç‰ˆæœ¬ 1
æœ¬ä¾‹ä¸­æœ‰å…©å€‹ struct: Song, Album ä»¥åŠä¸€å€‹ class ç”¨ä¾†æ’­æ”¾ Song æˆ– Albumï¼ŒåŸæœ¬çš„ Player è¦ç‚ºä¸åŒçš„ struct å¯«ä¸åŒçš„ funcï¼Œè€Œä¸”ç¨‹å¼ç¢¼å¤§å¤šé‡è¤‡ã€‚
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

struct Song {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

class Player {
    private let avPlayer = AVPlayer()

    func play(_ song: Song) {
        let item = AVPlayerItem(url: song.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }

    func play(_ album: Album) {
        let item = AVPlayerItem(url: album.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }
}
#+end_src
*** ç‰ˆæœ¬ 2
å®£å‘Šä¸€å€‹ protocolï¼Œå®šç¾© audioURL è®Šæ•¸(read only)ï¼Œç„¶å¾Œä»¤å…©å€‹ struct çš†éµå¾ªè©² protocol(æ–¹å¼æœ‰äºŒ)ï¼Œå¦‚æ­¤ï¼ŒåŸæœ¬çš„ Player class ä¸­çš„ play func å°±èƒ½åªå¯«ä¸€æ¬¡ã€‚
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol Playable {
    var audioURL: URL { get }
}

struct Song: Playable {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

extension Album: Playable {}
class Player {
    private let avPlayer = AVPlayer()

    func play(_ resource: Playable) {
        let item = AVPlayerItem(url: resource.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }
}
#+end_src
*** ç‰ˆæœ¬ 3
åŸæœ¬ protocol çš„çœŸæ­£æ„æ€å…¶å¯¦åªæ˜¯åœ¨ç¢ºå®š audioURL æ˜¯å¦èƒ½æ­£ç¢ºè½‰æ›æˆ Audioï¼Œæ‰€ä»¥å…¶å¯¦å°‡ protocol name ç”± Playable æ”¹ç‚º AudioURLConvertable æœƒæ›´è²¼è¿‘äº‹å¯¦ã€‚
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol AudioURLConvertable {
    var audioURL: URL { get }
}

struct Song: AudioURLConvertable {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album: AudioURLConvertable {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

class Player {
    private let avPlayer = AVPlayer()

    func play(_ resource: AudioURLConvertable) {
        let item = AVPlayerItem(url: resource.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }
}

#+end_src
** mutating
protocol é™¤äº†å¯ä»¥æä¾›å‚³å›å€¼å‹æ…‹çš„å½ˆæ€§ï¼Œä¹Ÿå¯ä»¥ç”¨ä¾†è®Šæ›´ class/struct ä¸­çš„å±¬æ€§ã€‚å¦‚ï¼š
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol Likeable {
    mutating func markAsLiked()
}

struct Song {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

extension Song: Likeable {
    mutating func markAsLiked() {
        isLiked = true
    }
}
#+end_src
å¯ä»¥åœ¨ä¸æ”¹è®ŠåŸ struct Album çš„æƒ…æ³ä¸‹ï¼Œè—‰ç”± extension ä¾†æ“´å…… Songï¼Œä½¿å…¶éµå¾ª Likeable protocolï¼Œæä¾›è®Šä¾›å±¬æ€§ isLiked çš„å€¼ï¼Œ*é€™åœ¨æ“´å…… API åŠŸèƒ½æ™‚ç‰¹åˆ¥æœ‰ç”¨*ã€‚
** æ“´å…… protocol
é™¤äº†æ“´å……ç¾æœ‰ structï¼Œprotocol ä¹Ÿå¯ä»¥ç”¨ä¾†æ“´å…… protocolï¼Œå¦‚ï¼š
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol Likeable {
    var isLiked: Bool {get set}
}

extension Likeable {
    mutating func markAsLiked() {
        isLiked = true
    }
}

struct Song {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

extension Song: Likeable {}
extension Album: Likeable {}
#+end_src
** Further Reading
- [[https://docs.swift.org/swift-book/LanguageGuide/Protocols.html][Protocol]]
- [[https://appcoda.com.tw/swift-protocol/][Swifté–‹ç™¼æŒ‡å—ï¼šProtocolsèˆ‡Protocol Extensionsçš„ä½¿ç”¨å¿ƒæ³•]]
- [[https://abhimuralidharan.medium.com/all-about-protocols-in-swift-11a72d6ea354][All about protocols in SWIFT]]
- [[https://blog.csdn.net/XunCiy/article/details/107367571][Swift5 14.Protocols]]

#+latex:\newpage
* Struct v.s. Class
[[https://www.hackingwithswift.com/books/ios-swiftui/why-does-swiftui-use-structs-for-views][è³‡æ–™ä¾†æº:Why does SwiftUI use structs for views?]]
If you ever programmed for UIKit or AppKit (Appleâ€™s original user interface frameworks for iOS and macOS) youâ€™ll know that they use classes for views rather than structs. SwiftUI does not: we prefer to use structs for views across the board, and there are a couple of reasons why.[fn:24]
- Structs are simpler and faster than classes.
  In SwiftUI, all our views are trivial structs and are almost free to create. Think about it: if you make a struct that holds a single integer, the entire size of your struct isâ€¦ that one integer. Nothing else. No surprise extra values inherited from parent classes, or grandparent classes, or great-grandparent classes, etc â€“ they contain exactly what you can see and nothing more.

- You can see this in action when you look at the kinds of things that can be a view. We already used Color.red and LinearGradient as views â€“ trivial types that hold very little data. In fact, you canâ€™t get a great deal simpler than using Color.red as a view: it holds no information other than â€œfill my space with redâ€.

- In comparison, Appleâ€™s documentation for UIView lists about 200 properties and methods that UIView has, all of which get passed on to its subclasses whether they need them or not.
** What is in class/struct
[[https://www.avanderlee.com/swift/struct-class-differences/][è³‡æ–™ä¾†æº:Struct vs classes in Swift: The differences explained]]
*** What is a class in Swift?
A class in Swift is a reference type which can contain:
- properties
- methods
- subscripts
- initializers
- protocol conformances
- extensions

Itâ€™s often described as a template definition of an object, like in the following Article instance definition:
#+begin_src swift -r -n :results output :exports nil
class ArticleClass {
    let title: String
    let url: URL
    var readCount: Int = 0

    init(title: String, url: URL) {
        self.title = title
        self.url = url
    }
}
#+end_src
*** What is a struct in Swift?
A struct in Swift is a value type which, just like classes, can contain:
- properties
- methods
- subscripts
- initializers
- protocol conformances
- extensions

It can also be seen as a template definition of an object, like in the following Article instance definition:
#+begin_src swift -r -n :results output :exports nil
struct ArticleStruct {
    let title: String
    let url: URL
    var readCount: Int = 0
}
#+end_src
*** What are the differences between a struct and a class?
**** Value vs reference types
One of the most important differences is that a struct is a value type while a class is a reference type. References to a class instance share single data which means that any changes in that class will be available to each reference.
#+begin_src swift -r -n :results output :exports nil
let articleClass = ArticleClass(title: "Struct vs Class", url: URL(string: "www.avanderlee.com")!)
let articleClassCopy = articleClass

articleClass.readCount = 10
print(articleClassCopy.readCount) // Prints: 10
#+end_src

A struct is a value type and will create a unique copy for each new reference.
#+begin_src swift -r -n :results output :exports nil
var articleStruct = ArticleStruct(title: "Struct vs Class", url: URL(string: "www.avanderlee.com")!, readCount: 0)
var articleStructCopy = articleStruct

articleStruct.readCount = 10
print(articleStructCopy.readCount) // Prints: 0
#+end_src
**** The benefit of mutation in safety
With this, structs have the benefit of mutation in safety as you can trust that no other part of your app is changing the data at the same time. This makes it easier to reason about your code and is especially helpful in multi-threaded environments where a different thread could alter your data at the same time.
**** Structs get an initializer for free
If you go back and compare the above code examples you can see that the ArticleClass has a defined initializer which is required for classes. Structs, however, get an initializer for free.
#+begin_src swift -r -n :results output :exports nil
// Before Swift 5.1 Memberwise initializers:
// Generated memberwise init: init(title: String, url: URL, readCount: Int)
let article = ArticleStruct(title: "", url: URL(string: "")!, readCount: 0)

// After Swift 5.1 Memberwise initializers, using the default 0 for read count
// Generated memberwise init: init(title: String, url: URL, readCount: Int = 0)
let article = ArticleStruct(title: "", url: URL(string: "")!)
#+end_src
**** Classes allow inheritance
Classes can inherit the characteristics of another class and with that, act like abstract classes. A common example is a custom view controller which inherit from UIViewController.

With protocols in Swift, this is often no longer needed and replaceable with protocols. Protocols can be used with both classes and structs while inheritance is only possible with classes.
Classes can be deinitialized

A class allows executing code just before it gets destroyed by using a deinit method. When you define the same deinit method in a struct youâ€™ll get the following error:
#+begin_verse
Deinitializers may only be declared within a class
#+end_verse
** when should I go for a struct and when for a class?
A simple bullet point list will make it a lot easier to decide.
You should use a class when:
- Comparing instance identity is needed by using ===
- Shared mutable state is required
- Objective-C interoperability is required

You should use a struct when:
- Comparing instance data is needed by using ==
- Unique copies with an independent state are required
- The data is used in multiple threads
** Try to go for a struct by default. 
Structs make your code easier to reason about and make it easier to work in multithreaded environments which we often have while developing in Swift.
** Two important differences between struct and class
- Structs always have unique owners, whereas with classes multiple things can point to the same value.
- Classes donâ€™t need the *mutating* keyword before methods that change their properties, because you can change properties of constant classes.
In practice, what this means is that if we have two SwiftUI views and we send them both the same struct to work with, they actually each have a unique copy of that struct; if one changes it, the other wonâ€™t see that change. On the other hand, if we create an instance of a class and send that to both views, they will share changes.[fn:25]
** DEMO
ä»¥ä¸‹é€™å€‹Viewå¯æ­£å¸¸é‹ä½œï¼Œæ–¼TextFieldä¸­æ‰€åšçš„ç·¨è¼¯ä¿®æ”¹éƒ½æœƒå³æ™‚é¡¯ç¤ºæ–¼Textä¸­ã€‚
#+begin_src swift -r -n :results output :exports nil
struct User {
    var firstName" = Bilbo"
    var lastName = "Baggins"
}

struct ContentView: View {
    @State private var user = User()

    var body: some View {
        VStack {
            Text("Your name is \(user.firstName) \(user.lastName).")

            TextField("First name", text: $user.firstName)
            TextField("Last name", text: $user.lastName)
        }
    }
}
#+end_src
ä½†è‹¥å°‡structæ”¹ç‚ºclassï¼Œé›–ç¨‹å¼ä»å¯åŸ·è¡Œï¼Œä½†Textä¸­çš„å§“åå»ä¸å†éš¨TextFieldçš„ä¿®æ”¹è€Œé€£å‹•ã€‚
To fix this, we need to tell SwiftUI when interesting parts of our class have changed. By â€œinteresting partsâ€ I mean parts that should cause SwiftUI to reload any views that are watching our class â€“ itâ€™s possible you might have lots of properties inside your class, but only a few should be exposed to the wider world in this way.[fn:26]
è‹¥è¦å°‡structæ”¹ç‚ºclassï¼Œå‰‡ç¨‹å¼è¦æ”¹æˆï¼š
#+begin_src swift -r -n :results output :exports nil
class User: ObservableObject{
    @Published var firstName = "Bilbo"
    @Published var lastName = "Baggins"
}

struct ContentView: View {
    @ObservedObject var user = User()

    var body: some View {
        VStack {
            Text("Your name is \(user.firstName) \(user.lastName).")

            TextField("First name", text: $user.firstName)
            TextField("Last name", text: $user.lastName)
        }
    }
}
#+end_src
Our User class has two properties: firstName and lastName. Whenever either of those two changes, we want to notify any views that are watching our class that a change has happened so they can be reloaded. We can do this using the @Published property observer.

@Published is more or less half of @State: it tells Swift that whenever either of those two properties changes, it should send an announcement out to any SwiftUI views that are watching that they should reload.

How do those views know which classes might send out these notifications? Thatâ€™s another property wrapper, @ObservedObject, which is the other half of @State â€“ it tells SwiftUI to watch a class for any change announcements.

The @ObservedObject property wrapper can only be used on types that conform to the ObservableObject protocol. This protocol has no requirements, and really all it means is â€œwe want other things to be able to monitor this for changes.â€

As youâ€™ve seen, rather than just using @State to declare local state, we now take three steps:

- Make a class that conforms to the ObservableObject protocol.
- Mark some properties with @Published so that any views using the class get updated when they change.
- Create an instance of our class using the @ObservedObject property wrapper.

The end result is that we can have our state stored in an external object, and, even better, we can now use that object in multiple views and have them all point to the same values.
#+latex: \newpage
* TODO some
:PROPERTIES:
:CUSTOM_ID: some
:END:
#+begin_verse
Adding the keyword some in front of a return type indicates that the return type is opaque. [fn:27]
#+end_verse
** Generics
*** å•é¡Œ
Generics å…è¨±é–‹ç™¼è€…åœ¨ä¸åŒé¡å‹ä¸­è¤‡ç”¨ä½ çš„ç¨‹å¼ç¢¼ï¼Œç”¨ä¾†è§£æ±ºä¸‹åˆ—å•é¡Œï¼š
#+begin_src swift -r -n :eval no
func swapInts(_ a: inout Int, _ b: inout Int) {
    let temporaryB = b
    b = a
    a = temporaryB
}

var num1 = 10
var num2 = 20

swapInts(&num1, &num2)
print(num1)   // 20
print(num2)   // 10
#+end_src
ä½†è‹¥æƒ³äº¤æ›å­—ä¸²ï¼Œå‰‡è¦å¯«æˆ
#+begin_src swift -r -n :eval no
func swapStrings(_ a: inout String, _ b: inout String) {
    let temporaryB = b
    b = a
    a = temporaryB
}
#+end_src
å¯ä»¥ç™¼ç¾é™¤äº†åƒæ•¸ä¹‹å¤–ï¼Œé‡è¤‡çš„ code å¯¦åœ¨å¤ªå¤š
*** è§£æ±ºæ–¹æ¡ˆ
å°‡å›ºå®šå‹æ…‹çš„åƒæ•¸è½‰ç‚º Generic type
#+begin_src swift -r -n :eval no
import Cocoa

func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}


var num1 = 10
var num2 = 20

swapTwoValues(&num1, &num2)
print(num1)   // 20
print(num2)   // 10
#+end_src
å¦ä¸€å€‹ä¾‹å­ç‚º Stack çš„å¯¦ä½œï¼š
åŸæœ¬åªèƒ½å„²å­˜ Int çš„ Stack å¦‚ä¸‹ï¼Œè‹¥è¦å„²å­˜å­—ä¸²å‰‡è¦å†å¦è¡Œå®šç¾©ã€‚
#+begin_src swift -r -n :eval no
struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
#+end_src
æ”¹ç‚º Generic type å¾Œå¯å‹•æ…‹è®Šæ›´ç‚ºæ•´æ•¸ stack æˆ–å­—ä¸² stackï¼Œå¦‚ï¼š
#+begin_src swift -r -n :eval no
struct Stack<Element> {
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}

var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// the stack now contains 4 strings

#+end_src
** opaque
å¸¶æœ‰ä¸é€æ˜ï¼ˆopaqueï¼‰è¿”å›é¡å‹çš„å‡½æ•¸æˆ–æ–¹æ³•ï¼Œå°‡æœƒéš±è—å…¶è¿”å›å€¼çš„é¡å‹[fn:28]
#+latex:\newpage
* TODO é€²éšä¸»é¡Œ
:PROPERTIES:
:CUSTOM_ID: advanced
:END:
- [[https://developer.apple.com/design/human-interface-guidelines/][Human Interface Guidelines]]: Apple çš„äººæ©Ÿè¨­è¨ˆç•Œé¢æŒ‡å—
- [[https://developer.apple.com/documentation][Apple Developer Documentation]]: Apple é–‹ç™¼è€…æ–‡ä»¶
- [[https://www.appcoda.com.tw/protocol-extension/][åˆ©ç”¨ Protocol Extension æ¸›å°‘é‡è¦†çš„ Codeã€€å¤§å¤§å¢å¼· Code çš„ç¶­è­·æ€§]]
- [[https://appcoda.com.tw/mastering-swift/][ç²¾é€šSwiftï¼šåˆ—èˆ‰ã€é–‰åŒ…ã€æ³›å‹ã€Protocolså’Œé«˜éšå‡½æ•¸]]
#+latex:\newpage
* Firebase
- [[https://medium.com/flawless-app-stories/how-to-build-a-firebase-app-with-swiftui-5919d2d8a396][How To Build A Firebase App With SwiftUI]]
- [[https://benmcmahen.com/authentication-with-swiftui-and-firebase/][Using Firebase Authentication with SwiftUI]]
- [[https://www.youtube.com/watch?v=4RUeW5rUcww][Building a to-do list app with SwiftUI and Firebase - Part 1 | Firebase Semi-live]]
#+latex: \newpage

* Footnotes

[fn:1] [[https://medium.com/@mikru168/swiftui-%E6%B7%BA%E7%8E%A9-swiftui-%E7%94%A8%E5%85%B6%E5%BB%BA%E6%A7%8B%E4%B8%80%E7%B0%A1%E5%96%AE%E7%9A%84-app-2f2477bd49d7][ç°¡ä»‹ SwiftUI & ç”¨å…¶å»ºæ§‹ä¸€ç°¡å–®çš„ APP ]]

[fn:2] [[https://medium.com/@SteelKiwiDev/swiftui-vs-uikit-benefits-and-drawbacks-6a540cced684][SwiftUI vs UIKit: Benefits and Drawbacks]]

[fn:3] [[https://www.appcoda.com.tw/swiftui-introduction/][SwiftUI åˆé«”é©—ï¼š å»ºæ§‹ä¸€å€‹ç°¡å–® Appã€€è®“ä½ äº†è§£ SwiftUI æœ‰å¤šå¼·å¤§ï¼]]

[fn:4] [[https://stackoverflow.com/questions/56514998/find-all-available-images-for-imagesystemname-in-swiftui][Find all available images for Image(systemName:) in SwiftUI]]

[fn:5] [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E7%94%A8%E7%8B%80%E6%85%8B%E8%A8%AD%E8%A8%88-swiftui-%E7%95%AB%E9%9D%A2-%E8%AA%8D%E8%AD%98-state-property-binding-27fea6885ead][ç”¨ç‹€æ…‹è¨­è¨ˆ SwiftUI ç•«é¢ â€” èªè­˜ @State propertyï¼Œbinding & Toggle]]

[fn:6] [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%AE%A2%E8%A3%BD-ui-%E5%85%83%E4%BB%B6%E6%A8%A3%E5%BC%8F%E7%9A%84-swiftui-modifier-b31ff65c1f0d][å®¢è£½ UI å…ƒä»¶æ¨£å¼çš„ SwiftUI modifier]]

[fn:7] [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/swiftui-%E8%A3%81%E5%88%87%E5%BD%A2%E7%8B%80%E7%9A%84-clipshape-mask-4fc49b34141][SwiftUI è£åˆ‡å½¢ç‹€çš„ clipShape & mask]]

[fn:8] [[https://www.appcoda.com.tw/swiftui-border/][SwiftUI å°æŠ€å·§ï¼šåˆ©ç”¨ border ä¿®é£¾ç¬¦ã€€è¼•é¬†ç‚ºæŒ‰éˆ•æˆ–æ–‡æœ¬ç¹ªè£½é‚Šæ¡†]]

[fn:9] [[https://www.hackingwithswift.com/quick-start/swiftui/how-to-create-a-list-of-dynamic-items][How to create a list of dynamic items]]

[fn:10] [[https://juejin.cn/post/6844903924084768776][[è­¯]ç†è§£ SwiftUI è£¡çš„å±¬æ€§è£é£¾å™¨]]

[fn:11] [[https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-binding-property-wrapper][What is the @Binding property wrapper?]]

[fn:12] [[https://medium.com/@nwyyy/swift%E7%AD%86%E8%A8%98-tab-bar-2ddba7d56587][iOSç­†è¨˜ï¼šTab Bar]]

[fn:13] [[https://www.appcoda.com/swiftui-tabview/][Introducing SwiftUI TabView and Working with Tab Bar Customization]]

[fn:14] [[https://www.youtube.com/watch?v=cc23YTGZVbQ][iOS 13 SwiftUI Tutorial: Interactively Transition and Share Data between Views with SwiftUI]]

[fn:15] [[https://www.youtube.com/watch?v=0i152oA3T3s][Lecture 9: Data Flow]]

[fn:16] [[https://onevcat.com/2020/06/stateobject/][@StateObject å’Œ @ObservedObject çš„åŒºåˆ«å’Œä½¿ç”¨]]

[fn:17] [[https://www.raywenderlich.com/6742901-protocol-oriented-programming-tutorial-in-swift-5-1-getting-started][Protocol-Oriented Programming Tutorial in Swift 5.1: Getting Started]]

[fn:18] [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E7%B0%A1%E6%98%93%E8%AA%AA%E6%98%8Eswift-4-protocol-919b7f9cbaee][ã€ç°¡æ˜“èªªæ˜Swift 4ã€Protocol]]

[fn:19] [[https://www.appcoda.com.tw/protocol-extension/][åˆ©ç”¨ Protocol Extension æ¸›å°‘é‡è¦†çš„ Codeã€€å¤§å¤§å¢å¼· Code çš„ç¶­è­·æ€§]]

[fn:20] [[https://docs.swift.org/swift-book/LanguageGuide/Protocols.html][Protocols]]

[fn:21] [[https://www.appcoda.com.tw/swift-protocol/][Swifté–‹ç™¼æŒ‡å—ï¼šProtocolsèˆ‡Protocol Extensionsçš„ä½¿ç”¨å¿ƒæ³•]]

[fn:22] [[https://ithelp.ithome.com.tw/articles/10197366][Day-29 Swift èªæ³•(25) - å”å®š Protocol]]

[fn:23] [[https://abhimuralidharan.medium.com/all-about-protocols-in-swift-11a72d6ea354][All about protocols in swift]]

[fn:24] [[https://www.hackingwithswift.com/books/ios-swiftui/why-does-swiftui-use-structs-for-views][Why does SwiftUI use structs for views?]]

[fn:25] [[https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs][Why @State only works with structs]]

[fn:26] [[https://www.hackingwithswift.com/books/ios-swiftui/sharing-swiftui-state-with-observedobject][Sharing SwiftUI state with @ObservedObject]]

[fn:27] [[https://medium.com/@PhiJay/whats-this-some-in-swiftui-34e2c126d4c4][Whatâ€™s this â€œsomeâ€ in SwiftUI?]]

[fn:28] [[https://medium.com/jeremy-xue-s-blog/swift-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80-opaque-types-600ad5758b91][Swift ç¨‹å¼èªè¨€ â€” Opaque Types]]

[fn:33] [[https://stackoverflow.com/questions/56437335/go-to-a-new-view-using-swiftui][Go to a new view using SwiftUI]]

[fn:32] [[https://www.appcoda.com.tw/swift-class/][Swift Class vs Structï¼šè¨­è¨ˆ Model æ™‚ï¼Œè©²ç”¨ Struct é‚„æ˜¯ Class å‘¢ï¼Ÿ]]

[fn:31] [[https://appcoda.com.tw/mastering-swift/][ç²¾é€šSwiftï¼šåˆ—èˆ‰ã€é–‰åŒ…ã€æ³›å‹ã€Protocolså’Œé«˜éšå‡½æ•¸]]

[fn:30] [[https://ithelp.ithome.com.tw/articles/10220520][ Day 10: [Swift] çµæ§‹å’Œé¡ (Struct and Class) ]]

[fn:29] [[https://levelup.gitconnected.com/demystifying-struct-class-and-enum-in-swift-5-43dde089e96a][Demystifying Struct, Class, and Enum in Swift 5]]
