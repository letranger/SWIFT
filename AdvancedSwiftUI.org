#+TITLE: Advanced Swift Ui

#+INCLUDE: ../purpleweb.org

#+latex:\newpage

* MVVM
:PROPERTIES:
:CUSTOM_ID: SW-MVVM
:END:
** Design pattern
MVVM çš„æ¦‚å¿µæœ€æ—©æ‡‰è©²æ˜¯åœ¨ 2005 å¹´ç”± Microsoftçš„[[https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/][John Gossman]]æå‡ºä¾†çš„ï¼Œå®ƒçš„æ¦‚å¿µæ˜¯ï¼Œæ•´å€‹ Swift project æœƒæ‹†åˆ†æˆä¸‰å€‹éƒ¨ä»½: Viewã€ViewModelã€Modelï¼Œå…¶ä¸­ View çš„è§’è‰²å°±æ˜¯å–®ç´”çš„è¦–è¦ºå…ƒä»¶ï¼Œåƒæ˜¯æŒ‰éˆ•ã€æ–‡å­—æ¨™ç±¤ç­‰ç­‰ï¼Œåœ¨ View è£¡é¢ä¸æœƒæœ‰é‚è¼¯ã€ç‹€æ…‹ç­‰ç­‰ï¼Œå–®ç´”å°±æ˜¯å€‹å‘ˆç¾è³‡æ–™çš„å…ƒä»¶ã€‚è€Œè¦è®“ View å‘ˆç¾è³‡æ–™ï¼Œæœ€ç›´è¦ºçš„æ–¹å¼ï¼Œå°±æ˜¯æŠŠ View è·Ÿ Model åšç¶å®šï¼Œè®“ View çš„å…ƒä»¶è·Ÿè‘— Model ä¸€èµ·åšè®ŠåŒ–ã€‚ä½†é€™æ¨£æœƒæœ‰å€‹å•é¡Œï¼Œå°±æ˜¯é€šå¸¸ Model ä¾†çš„è³‡æ–™ï¼Œä¸¦ä¸æ˜¯ç°¡å–®å°±èƒ½è½‰æ›æˆ View çš„æ¨£å¼çš„ï¼Œé€™æ™‚å€™å°±éœ€è¦æœ‰å€‹ç‰©ä»¶ï¼Œä»‹åœ¨ View è·Ÿ Model çš„ä¸­é–“ï¼Œé€™å€‹ç‰©ä»¶æœƒæŒç®¡é€™äº›è·Ÿ View é«˜åº¦ç›¸é—œçš„é‚è¼¯çš„æ“ä½œï¼Œåƒæ˜¯è½‰æ› Date ç‰©ä»¶è®Šæˆäººçœ‹å¾—æ‡‚çš„æ–‡å­—æ ¼å¼ç­‰ï¼Œç¨±ä¹‹ç‚º ViewModelã€‚ä¸Šé¢çš„æ¦‚å¿µå¯ä»¥ç•«æˆé€™æ¨£çš„è³‡æ–™æµï¼š

#+CAPTION: MVVM Architecture
#+NAME: fig: MVVMPNG
#+ATTR_LATEX: :width 500
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 600
[[file:images/MVVM-Basic.jpg]]

åœ¨ iOS é–‹ç™¼ä¸Šï¼Œä¾ç…§ä¸Šè¿° MVVM çš„å®šç¾©ï¼ŒContentView è®Šæˆä¸€å€‹å–®ç´”çš„ Viewï¼Œè€Œæˆ‘å€‘æœƒå¦å¤–ç”¢ç”Ÿä¸€å€‹ ViewModel ä¾†è² è²¬ presentational logic è·Ÿéƒ¨ä»½çš„ controller logicã€‚æ‰€ä»¥åœ¨Viewè£¡é¢ï¼Œå°±åªæœƒæœ‰ï¼š
1. View logicï¼Œæ‰€æœ‰è·Ÿå‘ˆç¾æœ‰é—œçš„ Code
1. ç¶å®š ViewModel
è€Œåœ¨ ViewModel è£¡é¢ï¼Œå‰‡æ˜¯è² è²¬å…©å€‹éƒ¨ä»½ï¼š
1. Controller logicï¼Œå¦‚ pagination, error handling,â€¦ etc
1. Presentation logicï¼Œæä¾›æ¥å£è®“ View ç¶å®š(binding)(æä¾›é©åˆåœ¨Viewä¸­å‘ˆç¾çš„è³‡æ–™)
é–‹ç™¼ä¸Šï¼Œä¸€æ—¦ View ç¶å®šå¥½ ViewModel çš„è³‡æ–™ï¼Œåœ¨æ’°å¯«å•†æ¥­é‚è¼¯çš„æ™‚å€™ï¼Œå°±å¯ä»¥ä¸ç”¨ç®¡åŒ…æ‹¬å‹•ç•«ã€è½‰å ´ã€main thread ç­‰ç­‰è·Ÿ View ç›¸é—œçš„å•é¡Œï¼Œå› ç‚ºåˆ†å·¥æ˜ç¢ºæ‰€ä»¥å°±ä¸æœƒæœ‰å¯«èµ·ä¾†ç¶æ‰‹ç¶è…³çš„æ„Ÿè¦ºã€‚æ›´æ£’çš„æ˜¯ï¼Œä¸¦ä¸”å› ç‚º ViewModel æ˜¯ä¸€å€‹å–®ç´”çš„ã€æ²’æœ‰ç›¸ä¾æ–¼ View çš„ç‰©ä»¶ï¼Œæ‰€ä»¥è¦åšæ¸¬è©¦ç°¡å–®å¤šäº†ï¼
[[https://www.codementor.io/@koromiko/mvvm-app-cl1wvw2sh][è³‡æ–™ä¾†æº: æ­¡è¿ä¾†åˆ°çœŸå¯¦ä¸–ç•Œ - åŸä¾†æ˜¯é‚£å€‹å‚³èªªä¸­çš„MVVMé˜¿]]
** What is the idea behind MVVM
*** Model
- Business logic
- UI Independent
*** View
- Presentation
- User interaction
*** ViewModel
- Presentation logic
- Glue between Model and View
*** ç‚ºä»€éº¼è¦æ‹†æˆä¸‰éƒ¨ä»½(What does it solve?)
- MVC - Massive View Controller
- Testability
- Code organization
- Code reusability
*** Limitations / Cons
- Requires binding
- Potential for boilerplate code
- Overkill for simple views and logic
- Doesn't cover every case
** DEMO
ä»¥"æ¨è–¦æ›¸å–®"çš„ APP ç‚ºä¾‹:
- Model: åŒ…å«æ›¸åã€ä½œè€…ã€å‡ºç‰ˆç¤¾....ï¼Œè€Œå¯¦éš›çš„è³‡æ–™ä¾†æºå¯èƒ½æ˜¯é›²ç«¯è³‡æ–™åº«(Firebase)ã€Web APIã€æœ¬æ©Ÿè³‡æ–™åº«(Core data)ã€‚
    #+begin_src swift -r -n :eval no
struct Book {
    let title: String
    let author: String
    let dateReleased: String
    let publishCamp: String
    let publishCity: String
    let isFavorite: Bool
}
  #+end_src
- View: åœ¨ APP ç•«é¢ä¸Šå‘ˆç¾ Model ä¸­è³‡æ–™çš„å…ƒä»¶ï¼Œå¦‚ Text, Image, Button, List.....
- ViewModel: å°‡ Model ä¸­çš„è³‡æ–™å–å‡ºï¼Œä¾› View å‘ˆç¾ï¼Œæˆ–æ˜¯æ¥å— View è¼¸å…¥çš„è³‡æ–™ï¼Œå­˜å› Modelã€‚ä»¥"æ¨è–¦æ›¸å–® APP"ç‚ºä¾‹ï¼Œå…¶ ViewModel å¯èƒ½åŒ…å«å¦‚ä¸‹ struct:
  #+begin_src swift -r -n :eval no
struct BookDetailViewModel {
    var book: Book

    var isFavorite: Bool

    init(book: Book) {
        self.book = book
        self.isFavorite = false
    }

    var title: String {
        return self.book.title
    }

    var author: String {
        return self.book.author
    }

    var dateReleased: String {
        return self.book.dateReleased
    }

    // å‘ˆç¾æ™‚è¦æ±‚ä»¥ é æµå‡ºç‰ˆç¤¾(å°åŒ—å¸‚) çš„æ ¼å¼ä¾†å‘ˆç¾
    var publisher: String {
        let output = self.book.publishCamp + "(" + self.book.publishCity + ")"
        return output
    }
}
  #+end_src
  å¾ Model ä¸­å¯ä»¥çœ‹åˆ°æ›¸ç±çš„è¨˜éŒ„æ¬„ä½åªæœ‰"å‡ºç‰ˆç¤¾"(publishCamp)å’Œ"å‡ºç‰ˆåœ°é»"(publishCity)ï¼Œä½†è‹¥ app å°é¡¯ç¤ºçµæœçš„æ ¼å¼è¦æ±‚ç‚º"å‡ºç‰ˆç¤¾(å‡ºç‰ˆåœ°é»)"ï¼Œå‰‡å¯ä»¥åœ¨ ViewModel ä¸­ä¾†è™•ç†ã€‚
  æ­¤å¤–ï¼Œå¦‚æœåœ¨ View ä¸Šæœ‰ä¸€å€‹ Favorite Buttonï¼Œå‰‡ç•¶ user é»äº† Favorite å¾Œï¼ŒViewModel æ‡‰è² è²¬å°‡ struct ä¸­çš„ isFavorite æ”¹å­˜ Trueï¼Œä¸¦å›å­˜è‡³ Model ä¸­ã€‚Model çš„è³‡æ–™åªèƒ½é€é ViewModel ä¾†æ–°å¢åˆªé™¤ï¼ŒView ç„¡æ³•ç›´æ¥æŸ“æŒ‡ã€‚
  Model èˆ‡ UI å®Œå…¨ç„¡é—œï¼Œå–®ç´”ç”¨ä¾†å„²å­˜è³‡æ–™ï¼ŒViewModel ç‚º Model èˆ‡ View æºé€šçš„æ©‹æ¨‘ã€‚
** Model è¦ç”¨ Struct æˆ–æ˜¯ Class
[[https://www.appcoda.com.tw/swift-class/][è³‡æ–™ä¾†æº:Swift Class vs Structï¼šè¨­è¨ˆ Model æ™‚ï¼Œè©²ç”¨ Struct é‚„æ˜¯ Class å‘¢ï¼Ÿ]]
*** Struct èˆ‡ Class çš„ä¸åŒæ€§è³ª
é¦–å…ˆï¼Œç•¶æˆ‘å€‘æŒ‡æ´¾ (assign) ä¸€å€‹å¯¦é«”çµ¦ä¸€å€‹è¾¨è­˜ç¬¦ï¼ˆidentifierï¼Œä¹Ÿå°±æ˜¯è®Šæ•¸ï¼å¸¸æ•¸åï¼‰çš„æ™‚å€™ï¼Œå¦‚æœè©²å¯¦é«”æ˜¯ struct çš„è©±ï¼Œè©²è¾¨è­˜ç¬¦æ‰€å®¹ç´çš„æœƒæ˜¯è©²å¯¦é«”çš„æ‰€æœ‰å…§å®¹ï¼›ä½†å¦‚æœå®ƒæ˜¯ class çš„è©±ï¼Œé€™å€‹è¾¨è­˜ç¬¦å°±åªæœƒå®¹ç´å­˜æ”¾è©²å¯¦é«”çš„ä½å€ï¼š
#+begin_src swift -r -n :results output :exports nil
// ç”¨ struct å®šç¾© Dogã€‚
struct Dog {
    var name = "Bart"
}
// æ•´å€‹ Dog å¯¦é«”éƒ½æœƒè¢«å­˜åˆ° myDog è£¡ã€‚
var myDog = Dog()
// ç”¨ class å®šç¾© Catã€‚
class Cat {
    var name = "Mimi"
}
// myCat åªæœƒå„²å­˜ Cat å¯¦é«”çš„ä½å€ã€‚Cat å¯¦é«”æœ¬èº«æœƒè¢«å­˜åˆ°åˆ¥çš„åœ°æ–¹ã€‚
var myCat = Cat()
#+end_src
ä¹Ÿå°±æ˜¯èªªï¼Œç•¶æˆ‘å€‘ä½¿ç”¨è¾¨è­˜ç¬¦çš„æ™‚å€™ï¼Œå¦‚æœå®ƒçš„å‹åˆ¥æ˜¯ struct çš„è©±ï¼Œæˆ‘å€‘åœ¨æ“ä½œçš„å¯¦é«”éƒ½æœƒæ˜¯æœ¬åœ°çš„ã€‚ä½†æ˜¯ç•¶æˆ‘å€‘åœ¨æ“ä½œ class å‹åˆ¥çš„è¾¨è­˜ç¬¦çš„è©±ï¼Œé‚£éº¼æˆ‘å€‘å¯¦éš›ä¸Šæ˜¯é€éè¾¨è­˜ç¬¦åœ¨æ“ä½œä¸€å€‹é ç«¯çš„å¯¦é«”ã€‚æ‰€ä»¥ï¼Œç•¶æˆ‘å€‘æ›´æ”¹é€™äº›å¯¦é«”çš„å±¬æ€§çš„æ™‚å€™ï¼Œå®ƒå€‘çš„è¡Œç‚ºå°±ä¸å¤ªä¸€æ¨£äº†ï¼š
#+begin_src swift -r -n :results output :exports nil
// ä½¿ç”¨ structã€‚
var herDog = Dog() {
    // å¦‚æœ herDog æœ‰è®Šå‹•çš„è©±å°±é¡¯ç¤ºè¨Šæ¯ã€‚
    didSet {
        print("Her dog is changed!")
    }
}
herDog.name = "Starlord"
// Her dog is changed!
// ä½¿ç”¨ classã€‚
var herCat = Cat() {
    didSet {
        print("Her cat is changed!")
    }
}
herCat.name = "Mumu"
// æ²’æœ‰è¨Šæ¯ã€‚
#+end_src
æ€éº¼æœƒæœ‰é€™æ¨£çš„å·®åˆ¥å‘¢ï¼Ÿå› ç‚º herDog å„²å­˜äº†æ‰€æœ‰çš„ Dog å¯¦é«”å…§å®¹ï¼Œæ‰€ä»¥ä»»ä½• Dog å¯¦é«”çš„å±¬æ€§çš„è®Šå‹•ï¼Œå°±ç­‰æ–¼èªª herDog æœ¬èº«æœ‰è®Šå‹•ã€‚ç„¶è€Œï¼ŒherCat ä¸¦æ²’æœ‰å„²å­˜ Cat å¯¦é«”çš„å…§å®¹ï¼Œæ‰€ä»¥ Cat å¯¦é«”å±¬æ€§çš„è®Šå‹•æ˜¯åœ¨åˆ¥çš„åœ°æ–¹ç™¼ç”Ÿçš„ï¼Œä¸” herCat æœ¬èº«æ‰€å„²å­˜çš„ Cat å¯¦é«”ä½å€ä¸¦æ²’æœ‰ä»»ä½•çš„æ”¹è®Šã€‚
ç”±åœ–[[fig: MVVMPNG]]å¯çœ‹å‡ºï¼Œ
*** MVVM ä¸­çš„ Model
** DICE DEMO
** Further Reading Resources
- [[https://www.youtube.com/watch?v=1IlUBHvgY8Q&t=29s][SwiftUI MVVM Programming with ObservableObject @Published @ObservedObject]]
- [[https://www.youtube.com/watch?v=LntH6moCuo0][SwiftUI 2.0: MVVM - A Practical Approach]]
- [[https://www.youtube.com/watch?v=gkAV4D1nopA][SwiftUI Tip Calculator Using MVVM Design Pattern]]
- [[https://www.youtube.com/watch?v=cbqMkIG6Qeg][Understanding MVVM Design Pattern]]: è¬›çš„è¶…æ¸…æ¥š
- Video: [[https://www.youtube.com/watch?v=EhtK_H9LsYQ][MVVM SwiftUI - Model View ViewModel Pattern - Getting Started]]
- Video: [[https://www.youtube.com/watch?v=LntH6moCuo0]]
- Video: [[https://www.youtube.com/watch?v=sWx8TtRBOfk][MVVM in Practice - RWDevCon Session - raywenderlich.com]]
- GitHub: https://github.com/rebeloper/SwiftUIMVVM.git
#+latex:\newpage

* Review
:PROPERTIES:
:CUSTOM_ID: SW-Review
:END:
- Functions: Tasks management project: task listing, adding, removing, editing
- Technoloties: View navigation, variable sharing, data model
åƒè€ƒè³‡æ–™: [[https://medium.com/better-programming/replicating-the-ios-reminders-app-part1-44211a7b7029][Building a To-Do List App with SwiftUI, Combine, and Firebase]]
** Data Model
#+begin_src swift :results output :exports nil
//
//  Task.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/18.
//

import Foundation


struct Task: Identifiable {
    var id = UUID()
    var title: String
    var completed: Bool
}

#if DEBUG
let testDataTasks = [
    Task(title: "Implement UI", completed: true),
    Task(title: "Share data", completed: false),
    Task(title: "Create Chart", completed: false),
    Task(title: "Connect to Firebase", completed: false),
    Task(title: "PROFIT!!!", completed: false)
]
#endif
#+end_src
** Basic UI
*** Change struct name (ContentView.swift)
   1) right click on struct ContentView
   2) Refactor
   3) Rename...: to *TaskListView*
   4) The file name on navigator (left panel in Xcode) will be renamed to *TaskListView.swift*
*** classify files into the following group
   - App
   - View
   - Model
     #+CAPTION: Rename struct in Xcode
#+LABEL:fig:RenameStructName
#+name: fig:RenameStructName
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width
[[file:images/renameStruct.jpg]]
*** Create basic UI
**** TaskListView.swift
#+begin_src swift -r -n :results output :exports nil
//
//  ContentView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/16.
//

import SwiftUI

struct TaskListView: View {
    let tasks = testDataTasks
    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10, content: {
                List(tasks) { task in
                    Image(systemName: "circle")
                    Text(task.title)
                }
                HStack(alignment: .center, spacing: 10, content: {
                    Image(systemName: "plus.circle.fill")
                    Text("New Task")
                }).padding()

            }).navigationTitle("Tasks")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        TaskListView()
    }
}

#+end_src
**** Extract the task cell
1. Grouping the Image and Text with HStack
2. cmd+click Htack
3. Extract SubView
4. Fix the compile error(inject needed variable)
#+begin_src swift -r -n :results output :exports nil
//
//  ContentView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/16.
//

import SwiftUI

struct TaskListView: View {
    let tasks = testDataTasks
    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10, content: {
                List(tasks) { task in
                    TaskCell(task: task)
                }
                HStack(alignment: .center, spacing: 10, content: {
                    Image(systemName: "plus.circle.fill")
                    Text("New Task")
                }).padding()

            }).navigationTitle("Tasks")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        TaskListView()
    }
}

struct TaskCell: View {
    var task: Task
    var body: some View {
        HStack {
            Image(systemName: "circle")
            Text(task.title)
        }
    }
}

#+end_src
** MVVM
ä»¥MVVMæ¶æ§‹ä¾†é–‹ç™¼project
*** ViewModel
**** Diagram for now
#+BEGIN_SRC ditaa :file images/mvvm-d1.png
    +---------+                  +-------------+            +------------+
    |         +-------uses------>|             |            |            |
    |   View  |<-=-Configures-=--+  View Model +---owns---->|   Model    |
    |         |                  |             |            |            |
    +---------+                  +-------------+            +------------+
#+END_SRC

#+RESULTS:
[[file:images/mvvm-d1.png]]

**** Model for the future
#+BEGIN_SRC ditaa :file images/mvvm-d2.png
   +-----------+
   |           |
   |    View   |
   |           |
   +-+---------+
     |     ^
   uses    |
     |     |
     | configures
     |     |
     v     :
   +-------+-----+                         +------------+               +-----------+
   |             +-----request updates---->+            +-----store---->|           |
   |  View Model |                         | Repository |               |  Storage  |
   |             |<-=---publish updates-=--|            |<-=-retrieve-=-+           |
   +------+------+                         +------+-----+               +-----------+
          |                                       :
         owns                +----------+       returns
          |                  |          |         |
          +----------------->|   Model  |<--------+
                             |          |
                             +----------+
#+END_SRC

#+RESULTS:
[[file:images/mvvm-d2.png]]

**** TaskCellViewModel
#+begin_src swift -r -n :results output :exports nil
//
//  TaskCellViewModel.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/20.
//

import Foundation
import Combine

class TaskCellViewModel: ObservableObject, Identifiable  {
    @Published var task: Task

    @Published var completionStateIconName = ""
    private var cancellables = Set<AnyCancellable>()
    init(task: Task) {
        self.task = task
        $task
            .map { task in
                return task.completed ? "checkmark.circle.fill" : "circle"
            }
            .assign(to: \.completionStateIconName, on: self)
            .store(in: &cancellables)
    }
}

#+end_src
**** TaskListViewModel
#+begin_src swift -r -n :results output :exports nil
//
//  TaskListViewModel.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/20.
//

import Foundation
import Combine

class TaskListMiewModel: ObservableObject {
    @Published var taskCellViewModels = [TaskCellViewModel]()

    init() {
        self.taskCellViewModels = testDataTasks.map { task in
            TaskCellViewModel(task: task)
        }
    }

}

#+end_src
*** View
TaskListView.swift
#+begin_src swift -r -n :results output :exports nil
//
//  ContentView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/16.
//

import SwiftUI

struct TaskListView: View {
    @ObservedObject var taskListVM = TaskListMiewModel()

    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10, content: {
                List(taskListVM.taskCellViewModels) { task in
                    TaskCell(taskCellVM: task)
                }
                HStack(alignment: .center, spacing: 10, content: {
                    Image(systemName: "plus.circle.fill")
                    Text("New Task")
                }).padding()

            }).navigationTitle("Tasks")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        TaskListView()
    }
}

struct TaskCell: View {
    @ObservedObject var taskCellVM: TaskCellViewModel

    var body: some View {
        HStack {
            Image(systemName: taskCellVM.completionStateIconName)
            Text(taskCellVM.task.title)
        }
    }
}

#+end_src
** New task
åŠ å…¥æ–°å¢taskåŠŸèƒ½ï¼ŒçœŸæ­£çš„æ–°å¢åŠŸèƒ½ç”±ViewModelå¯¦ä½œï¼ŒViewè² è²¬ç•Œé¢åŠå‘¼å«è©²åŠŸèƒ½
*** View
**** NewTaskView.swift
#+begin_src swift -r -n :results output :exports nil
//
//  NewTaskView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/20.
//

import SwiftUI

struct NewTaskView: View {
    @ObservedObject var taskListVM = TaskListMiewModel()
    @State var taskTitle: String = ""

    @Environment(\.presentationMode) var presentation

    var body: some View {
        VStack {
            Text("New Task")
                .font(.largeTitle)
            TextField("Enter task name", text: self.$taskTitle)
            Button(action: {
                taskListVM.addTask(task: Task(title: self.taskTitle, completed: false))
                self.presentation.wrappedValue.dismiss()
            }, label: {
                Text("Done")
            })
            Spacer()
        }.padding()
    }
}

struct NewTaskView_Previews: PreviewProvider {
    static var previews: some View {
        NewTaskView()
    }
}

#+end_src
**** TaskListView.swift
#+begin_src swift -r -n :results output :exports nil
//
//  ContentView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/16.
//

import SwiftUI

struct TaskListView: View {
    @ObservedObject var taskListVM = TaskListMiewModel()
    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10, content: {
                List(taskListVM.taskCellViewModels) { task in
                    TaskCell(taskCellVM: task)
                }


                HStack(alignment: .center, spacing: 10, content: {
                    Image(systemName: "plus.circle.fill")
                    Button(action: /*@START_MENU_TOKEN@*/{}/*@END_MENU_TOKEN@*/, label: {
                        /*@START_MENU_TOKEN@*/Text("Button")/*@END_MENU_TOKEN@*/
                    })
                    Text("New Task")
                }).padding()

                .navigationBarTitle("Tasks", displayMode: .inline)

                .navigationBarItems(trailing: NavigationLink(
                                        destination: NewTaskView(taskListVM: taskListVM, taskTitle: ""),
                                        label: {
                                            Text("New Task")
                                        }))

            })
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        TaskListView()
    }
}

struct TaskCell: View {
    @ObservedObject var taskCellVM: TaskCellViewModel

    var body: some View {
        HStack {
            Image(systemName: taskCellVM.completionStateIconName)
            Text(taskCellVM.task.title)
        }
    }
}

#+end_src
*** ViewModel
**** TaskListViewModel.swift
#+begin_src swift -r -n :results output :exports nil
//
//  TaskListViewModel.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/20.
//

import Foundation
import Combine

class TaskListMiewModel: ObservableObject {
    @Published var taskCellViewModels = [TaskCellViewModel]()

    init() {
        self.taskCellViewModels = testDataTasks.map { task in
            TaskCellViewModel(task: task)
        }
    }

    func addTask(task: Task) {
        let task = TaskCellViewModel(task: task)
        self.taskCellViewModels.append(task)
    }
}

#+end_src
** Delete task
åŠ å…¥swipeé€²è¡Œåˆªé™¤çš„åŠŸèƒ½ï¼ŒçœŸæ­£åˆªé™¤çš„åŠŸèƒ½ç”±ViewModelå¯¦ä½œï¼ŒViewè² è²¬å‘¼å«
*** View
**** TaskListView.swift
#+begin_src swift -r -n :results output :exports nil
//
//  ContentView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/16.
//

import SwiftUI

struct TaskListView: View {
    @ObservedObject var taskListVM = TaskListMiewModel()
    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10, content: {
                List {
                    ForEach(taskListVM.taskCellViewModels) { task in
                        TaskCell(taskCellVM: task)

                    }
                    .onDelete(perform: { indexSet in
                        taskListVM.deleteTask(indexSet: indexSet)
                    })
                }

                HStack(alignment: .center, spacing: 10, content: {
                    Image(systemName: "plus.circle.fill")
                    Button(action: /*@START_MENU_TOKEN@*/{}/*@END_MENU_TOKEN@*/, label: {
                        /*@START_MENU_TOKEN@*/Text("Button")/*@END_MENU_TOKEN@*/
                    })
                    Text("New Task")
                }).padding()

                .navigationBarTitle("Tasks", displayMode: .inline)

                .navigationBarItems(trailing: NavigationLink(
                                        destination: NewTaskView(taskListVM: taskListVM, taskTitle: ""),
                                        label: {
                                            Text("New Task")
                                        }))

            })
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        TaskListView()
    }
}

struct TaskCell: View {
    @ObservedObject var taskCellVM: TaskCellViewModel

    var body: some View {
        HStack {
            Image(systemName: taskCellVM.completionStateIconName)
            Text(taskCellVM.task.title)
        }
    }
}

#+end_src
*** ViewModel
**** TaskListViewModel.swift
#+begin_src swift -r -n :results output :exports nil

#+end_src
#+begin_src swift -r -n :results output :exports nil
//
//  TaskListViewModel.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/20.
//

import Foundation
import Combine

class TaskListMiewModel: ObservableObject {
    @Published var taskCellViewModels = [TaskCellViewModel]()

    init() {
        self.taskCellViewModels = testDataTasks.map { task in
            TaskCellViewModel(task: task)
        }
    }

    func addTask(task: Task) {
        let task = TaskCellViewModel(task: task)
        self.taskCellViewModels.append(task)
    }

    func deleteTask(indexSet: IndexSet) {
        self.taskCellViewModels.remove(atOffsets: indexSet)
    }
}

#+end_src
** enum v.s. picker
åŠ å…¥taskçš„priorityé¡å‹
*** Model
ä»¥enumä¾†è¡¨ç¤ºtaskçš„ä¸åŒå„ªå…ˆæ¬Š
**** Model.swift
#+begin_src swift -r -n :results output :exports nil
//
//  Task.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/18.
//

import Foundation

enum TaskPriority: String, CaseIterable  {
    case high
    case medium
    case low
}

struct Task: Identifiable {
    var id = UUID()
    var title: String
    var priority: TaskPriority
    var completed: Bool
}

#if DEBUG
let testDataTasks = [
    Task(title: "Implement UI", priority: .medium, completed: true),
    Task(title: "Share data", priority: .high, completed: false),
    Task(title: "Create Chart", priority: .medium, completed: false),
    Task(title: "Connect to Firebase", priority: .high, completed: false),
    Task(title: "PROFIT!!!", priority: .high, completed: false)
]
#endif

#+end_src
*** View
ä»¥Pickerä¾†é¸å–enumä¸­çš„å­é¡åˆ¥[fn:14]
**** TaskListView.swift
#+begin_src swift -r -n :results output :exports nil
//
//  ContentView.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/16.
//

import SwiftUI

struct TaskListView: View {
    @ObservedObject var taskListVM = TaskListMiewModel()
    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10, content: {
                List {
                    ForEach(taskListVM.taskCellViewModels) { task in
                        TaskCell(taskCellVM: task)

                    }
                    .onDelete(perform: { indexSet in
                        taskListVM.deleteTask(indexSet: indexSet)
                    })
                }

                .navigationBarTitle("Tasks", displayMode: .inline)

                .navigationBarItems(trailing: NavigationLink(
                                        destination: NewTaskView(taskListVM: taskListVM, taskTitle: "", priority: TaskPriority.low),
                                        label: {
                                            Text("New Task")
                                        }))

            })
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        TaskListView()
    }
}

struct TaskCell: View {
    @ObservedObject var taskCellVM: TaskCellViewModel

    var body: some View {
        HStack {
            Image(systemName: taskCellVM.completionStateIconName)
            Image(systemName: taskCellVM.priorityStateIconName)
                .foregroundColor(/*@START_MENU_TOKEN@*/.blue/*@END_MENU_TOKEN@*/)
            Text(taskCellVM.task.title)
        }
    }
}
#+end_src
*** ViewModel
**** TaskCellViewModel.swift
#+begin_src swift -r -n :results output :exports nil
//
//  TaskCellViewModel.swift
//  taskManagement
//
//  Created by yen yung chin on 2021/2/20.
//

import Foundation
import Combine

class TaskCellViewModel: ObservableObject, Identifiable  {
    @Published var task: Task

    @Published var completionStateIconName = ""
    @Published var priorityStateIconName = ""
    private var cancellables = Set<AnyCancellable>()
    init(task: Task) {
        self.task = task
        $task
            .map { task in
                return task.completed ? "checkmark.circle.fill" : "circle"
            }
            .assign(to: \.completionStateIconName, on: self)
            .store(in: &cancellables)
        $task
            .map { task in
                return self.priorityIconName(task: self.task)
            }
            .assign(to: \.priorityStateIconName, on: self)
            .store(in: &cancellables)
    }

    func priorityIconName(task: Task) -> String {
        switch task.priority {
        case .low:
            return "l.circle.fill"
        case .medium:
            return "m.circle.fill"
        case .high:
            return "h.circle.fill"
        }
    }
}

#+end_src

Developing iOS App with Swift #1
iOS-Swift-1
31/08

* Advance function
:PROPERTIES:
:CUSTOM_ID: SW-AdvFuncs
:END:
** filter()
filter() å®£å‘Šå¦‚ä¸‹ï¼š
#+begin_src swift -r -n :results output :exports nil
func filter(includeElement: (T) -> Bool) -> Array<T>
#+end_src
- includeElement è¡¨ç¤ºå‚³å…¥çš„ function æˆ– closureï¼Œç”¨ä¾†åˆ¤æ–·é™£åˆ—å€‹å…ƒç´ æ˜¯å¦ç¬¦åˆæ¢ä»¶ã€‚
- filter() å›å‚³çµæœç‚ºé™£åˆ—ã€‚
*** åœ¨ closure å›å‚³æ¯å€‹å…ƒç´ ä½¿å¦ç¬¦åˆåˆ¤æ–·å¼çš„çµæœï¼Œæ±ºå®šæœ€å¾Œ filter() å›å‚³çš„å…ƒç´ é›†åˆã€‚[fn:14]
#+begin_src swift -r -n :results output :exports nil
var numbers = Array(1...8)

var evenNumbers = numbers.filter { (x) -> Bool in
    x % 2 == 0
}

var oddNumbers = numbers.filter { (x) -> Bool in
    x % 2 != 0
}

numbers         //return: [1, 2, 3, 4, 5, 6, 7, 8]
evenNumbers     //return: [2, 4, 6, 8]
oddNumbers      //return: [1, 3, 5, 7]

#+end_src
*** å°‡ä¸€ã€ä¸‰è±¡é™çš„é»éæ¿¾å‡ºä¾†[fn:14]
#+begin_src swift -r -n :results output :exports nil
struct Point {
    var x: Int
    var y: Int
}

var p1 = Point(x: 1, y: 1)
var p2 = Point(x: -1, y: 1)
var p3 = Point(x: -1, y: -1)
var p4 = Point(x: 1, y: -1)
var points = [p1, p2, p3, p4]

var quadrant_1 = points.filter { (p) -> Bool in
    return p.x > 0 && p.y > 0
}

var quadrant_3 = points.filter { (p) -> Bool in
    return p.x < 0 && p.y < 0
}

points          //return: [{x 1, y 1}, {x -1, y 1}, {x -1, y -1}, {x 1, y -1}]
quadrant_1      //return: [{x 1, y 1}]
quadrant_3      //return: [{x -1, y -1}]

#+end_src
** map()
map() å®£å‘Šå¦‚ä¸‹ï¼š
#+begin_src swift -r -n :results output :exports nil
func map<U>(transform: (T) -> U) -> Array<U>
#+end_src
- transform è¡¨ç¤ºå‚³å…¥çš„ function æˆ– closureï¼Œç”¨ä¾†è½‰æ›æ¯å€‹é™£åˆ—çš„å…ƒç´ ã€‚è¼¸å…¥åƒæ•¸èˆ‡å›å‚³çµæœå‹åˆ¥å¯ä»¥ä¸åŒã€‚
- map() å›å‚³çµæœç‚ºé™£åˆ—ã€‚
*** é€émap()å°‡æ•´æ•¸é™£åˆ—è½‰åŒ–æˆå…©å€æ•¸å€¼èˆ‡å­—ä¸²çš„é™£åˆ—ã€‚[fn:14]
#+begin_src swift -r -n :results output :exports nil
var numbers = Array(1...8)

var doubles = numbers.map { (n) -> Int in
    return n*2
}

var strings = numbers.map { (n) -> String in
    let digital = [0:"é›¶", 1:"å£¹", 2:"è²³", 3:"å‚", 4:"è‚†", 5:"ä¼", 6:"é™¸", 7:"æŸ’", 8:"æŒ", 9:"ç–"]
    return digital[n] ?? "å•¥"
}

numbers     //return: [1, 2, 3, 4, 5, 6, 7, 8]
doubles     //return: [2, 4, 6, 8, 10, 12, 14, 16]
strings     //return: ["å£¹", "è²³", "å‚", "è‚†", "ä¼", "é™¸", "æŸ’", "æŒ"]

#+end_src
**** map()å¦‚ä½•å°‡ä¸€çµ„äºŒåº¦ç©ºé–“çš„é»å° X è»¸èˆ‡ Y è»¸åšé¡å°„ã€‚[fn:14]
#+begin_src swift -r -n :results output :exports nil
struct Point {
    var x: Int
    var y: Int
}
var points = [Point(x: 1, y: 2), Point(x: -2, y: -1)]

var mirror_x = points.map { (p) -> Point in
    return Point(x: -p.x, y: p.y)
}

var mirror_y = points.map { (p) -> Point in
    return Point(x: p.x, y: -p.y)
}

points      //return: [{x 1, y 2}, {x -2, y -1}]
mirror_x    //return: [{x -1, y 2}, {x 2, y -1}]
mirror_y    //return: [{x 1, y -2}, {x -2, y 1}]

#+end_src
** debounce
What is debounce? Its a function which forces the execution to wait a certain amount of time before running again.[fn:15]
*** Example
source: [[https://peterfriese.dev/swift-combine-love/][SwiftUI + Combine = â¤ï¸]]
**** UI
#+begin_src swift -r -n :results output :exports nil
struct ContentView: View {

  @ObservedObject private var userViewModel = UserViewModel()

  var body: some View {
    Form {
      Section {
        TextField("Username", text: $userViewModel.username)
          .autocapitalization(.none)
        }
        Section {
          SecureField("Password", text: $userViewModel.password)
          SecureField("Password again", text: $userViewModel.passwordAgain)
       }
       Section {
         Button(action: { }) {
           Text("Sign up")
         }.disabled(!userViewModel.valid)
       }
     }
  }
}

struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    ContentView()
  }
}
#+end_src
**** ViewModel
#+begin_src swift -r -n :results output :exports nil
class UserViewModel: ObservableObject {
  // Input
  @Published var username = ""
  @Published var password = ""
  @Published var passwordAgain = ""

  // Output
  @Published var isValid = false

  $username
  .debounce(for: 0.8, scheduler: RunLoop.main)
  .removeDuplicates()
  .map { input in
    return input.count >= 3
  }
  .assign(to: \.valid, on: self)
  .store(in: &cancellableSet)
}
#+end_src

* Web API: URLSession v.s. JSONDecoder
** Demo 1
*** ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct Todo: Codable, Identifiable {
    public var id: Int
    public var title: String
    public var completed: Bool
}

class FetchToDo: ObservableObject {
  // 1.
  @Published var todos = [Todo]()

    init() {
        let url = URL(string: "https://jsonplaceholder.typicode.com/todos")!
        // 2.
        URLSession.shared.dataTask(with: url) {(data, response, error) in
            do {
                if let todoData = data {
                    // 3.
                    let decodedData = try JSONDecoder().decode([Todo].self, from: todoData)
                    DispatchQueue.main.async {
                        self.todos = decodedData
                    }
                } else {
                    print("No data")
                }
            } catch {
                print("Error")
            }
        }.resume()
    }
}

struct ContentView: View {
    // 1.
    @ObservedObject var fetch = FetchToDo()
    var body: some View {
        VStack {
            // 2.
            List(fetch.todos) { todo in
                VStack(alignment: .leading) {
                    // 3.
                    Text(todo.title)
                    Text("\(todo.completed.description)") // print boolean
                        .font(.system(size: 11))
                        .foregroundColor(Color.gray)
                }
            }
        }
    }
}
#+end_src
#+LABEL:fig:JSON-1
#+name: fig:JSON-1
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/json-1.jpg]]
** Demo 2
*** MVVM
- Model: FlowModel.swift
- View: ContentView.swift
- ViewModel: Flow.swift
*** FlowModel.swift
#+begin_src swift -r -n :results output :exports nil
import Foundation

struct FlowModel: Decodable, Hashable {
    var å¹´: Int? = nil
    var æœˆ: Int? = nil
    var ç¸½é‹é‡: Int? = nil
    var æ—¥å‡é‹é‡: Int? = nil
    var å‡æ—¥å‡é‹é‡: Int? = nil
    var æœˆå°ä¸Šåˆ·å¡æ—¥å‡ç­†æ•¸: Double? = nil
    var è»Šä¸Šåˆ·å¡æ—¥å‡ç­†æ•¸: Double? = nil
    var å”®ç¥¨æ©Ÿæ—¥å‡ç­†æ•¸: Double? = nil
    var è£œç¥¨æ—¥å‡ç­†æ•¸: Double? = nil
    var åœ˜é«”ç¥¨æ—¥å‡ç­†æ•¸: Double? = nil
}
#+end_src

#+RESULTS:
*** ContentView.swift
#+begin_src swift -r -n :results output :exports nil
import SwiftUI

struct ContentView: View {
    @ObservedObject var flow = FetchFlow()

    var body: some View {
        NavigationView {
            List() {
                ForEach(flow.flows, id: \.self) {(item) in
                    NavigationLink(destination: Text("ç¸½é‹é‡: \(item.ç¸½é‹é‡!)")) {
                        HStack {
                            Text("\(item.å¹´!)å¹´\(item.æœˆ!)æœˆ")
                            Text("\(item.æ—¥å‡é‹é‡!)")
                        }
                    }
                }
            }.navigationTitle("")
        }
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

#+end_src
*** Flow.swift
#+begin_src swift -r -n :results output :exports nil
import Foundation
class FetchFlow: ObservableObject {
    @Published var flows = [FlowModel]()
    init() {
        let urlstr = "https://data.kcg.gov.tw/dataset/6f29f6f4-2549-4473-aa90-bf60d10895dc/resource/30dfc2cf-17b5-4a40-8bb7-c511ea166bd3/download/lightrailtraffic.json"
        guard let url = URL(string: urlstr) else {
            print("Invalid json url")
            return
        }
        URLSession.shared.dataTask(with: url) {(data, response, error) in
            do {
                if let flowData = data {
                    let decodeData = try JSONDecoder().decode([FlowModel].self, from: flowData)

                    DispatchQueue.main.async {
                        self.flows = decodeData
                    }
                } else {
                    print("No data")
                }
            } catch {
                print("\(error)")
            }
        }.resume()
    }
}
#+end_src
*** Result
#+LABEL:fig:JSON-2
#+name: fig:JSON-2
#+ATTR_LATEX: :width 500
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 600
[[file:images/json-2.jpg]]
** å…¬é–‹è³‡æ–™å¹³å°
- [[https://data.gov.tw/][æ”¿åºœè³‡æ–™é–‹æ”¾å¹³å°]]
- [[https://data.kcg.gov.tw/dataset][é«˜é›„å¸‚æ”¿åºœé–‹æ”¾è³‡æ–™é›†]]
- [[https://data.tainan.gov.tw/dataset][å°å—å¸‚æ”¿åºœé–‹æ”¾è³‡æ–™é›†]]
- [[https://ptx.transportdata.tw/PTX/Service][å…¬å…±é‹è¼¸æ•´åˆè³‡è¨Š]]
- [[https://kaleidosblog.s3-eu-west-1.amazonaws.com/json/tutorial.json][country/code JSON sample]]
** Further Reading
- [[https://www.youtube.com/watch?v=HvfE4G9PfeU][SwiftUI Tutorial - Using an API and Decoding JSON Data]]
- [[https://www.youtube.com/watch?v=tdxKIPpPDAI][iOS Swift Tutorial: Use Web APIs and JSON Data with Swift 5]]- [[https://www.ioscreator.com/tutorials/swiftui-json-list-tutorial][SwiftUI Fetch JSON Data into List]]
- [[https://programmingwithswift.com/parse-json-from-file-and-url-with-swift/][Parse JSON from file and URL with Swift]]
- [[https://www.youtube.com/watch?v=1en4JyW3XSI][Making an API call and fetch JSON data in SwiftUI]]
- [[https://benoitpasquier.com/encoding-decoding-json-swift4/][The best way to encode and decode JSON in Swift4 ]]
- [[https://www.reddit.com/r/swift/comments/emw0i3/jsondecoder_fails_if_i_dont_have_an_id_for_each/][JSONDecoder fails if I don't have an "id" for each item... why doesn't UUID work?]]
- [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E8%A7%A3%E6%B1%BAjson-key%E4%B8%8D%E5%9B%BA%E5%AE%9A%E6%99%82%E5%87%BA%E7%8F%BE-no-value-associated-with-key-codingkeys-%E7%8B%80%E6%B3%81-720d7d09486a][è§£æ±ºJson Keyä¸å›ºå®šæ™‚å‡ºç¾â€œNo value associated with key CodingKeysâ€ ç‹€æ³]]
#+latex: \newpage

* Protocols
:PROPERTIES:
:CUSTOM_ID: SW-Protocols
:END:
- Protocols are a fundamental feature of Swift. They play a leading role in the structure of the Swift standard library and are a common method of abstraction. They provide a similar experience to interfaces that some other languages have. An advantage of protocols in Swift is that objects can conform to multiple protocols.[fn:1]
- Protocol æ˜¯ä¸€å€‹åªå®£å‘Šä¸å®šç¾©çš„å‹åˆ¥ï¼Œç„¶è€Œé€™å€‹ç‰¹æ€§å¯ä»¥è®“æˆ‘å€‘çš„ç¨‹å¼æ›´æœ‰å½ˆæ€§ï¼Œåƒåœ¨ IOS SDK è£¡é¢ï¼Œè€³ç†Ÿèƒ½è©³çš„ Delegateï¼Œå°±å¤§é‡çš„é‹ç”¨ Potocolï¼Œæ–¹ä¾¿æˆ‘å€‘å®¢è£½åŒ–äº‹ä»¶ç™¼ç”Ÿæ™‚è¦è™•ç†çš„äº‹æƒ…ã€‚[fn:2]

- å°ä»»ä½•ç¨‹å¼é–‹ç™¼ä¾†èªªï¼Œæ¸›å°‘é‡è¦†çš„ codeï¼ŒæŠŠæ¬Šè²¬æ˜ç¢ºåˆ†é–‹ï¼Œè®“ code ç¶­è­·æ€§è®Šå¥½ï¼Œæ˜¯éå¸¸é‡è¦çš„èª²é¡Œã€‚è€Œåœ¨ç¾ä»Šçš„è»Ÿé«”é–‹ç™¼æ¨¡å¼ä¸­ï¼Œæœ‰è¨±å¤šæ–¹æ³•å¯ä»¥åšåˆ°é€™é»ï¼Œæœ€ç‚ºäººæ‰€çŸ¥çš„ä¸€å€‹æ¨¡å¼ï¼Œå°±æ˜¯åˆ©ç”¨ç¹¼æ‰¿ (Inheritance)ï¼ŒæŠŠæœƒé‡è¦†åˆ©ç”¨çš„éƒ¨ä»½æ”¾åœ¨æ¯é¡åˆ¥ï¼Œè®“å…¶å®ƒå­é¡åˆ¥å»ç¹¼æ‰¿ã€‚å¦å¤–ä¸€ç¨®åšæ³•ï¼Œå‰‡æ˜¯åˆ©ç”¨ Composition Patternï¼Œå°‡åŠŸèƒ½åšæˆçµ„ä»¶åˆ†å‡ºä¾†ï¼Œè®“éœ€è¦çš„æ¨¡çµ„å»çµ„åˆå–ç”¨ã€‚[fn:3]
#+begin_verse
A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol. [fn:4]
#+end_verse

- å”å®šæä¾›é¡å‹å¯ä»¥åšçš„è³‡è¨Šï¼ŒClasses å’Œ structs å‰‡æä¾›ç‰©ä»¶çš„è³‡è¨Šï¼Œå”å®šå‰‡æä¾›ç‰©ä»¶å°‡æœƒåŸ·è¡Œçš„å‹•ä½œã€‚[fn:5]
#+begin_verse
å”å®šæ˜¯ Swift ä¸€å€‹é‡è¦çš„ç‰¹æ€§ï¼Œå®ƒæœƒå®šç¾©å‡ºç‚ºäº†å®ŒæˆæŸé …ä»»å‹™æˆ–åŠŸèƒ½æ‰€éœ€çš„æ–¹æ³•ã€å±¬æ€§ï¼Œä½†æ˜¯æœ¬èº«ä¸æœƒå¯¦ä½œé€™äº›ä»»å‹™è·ŸåŠŸèƒ½ï¼Œè€Œåƒ…åƒ…åªæ˜¯è¡¨é”å‡ºè©²ä»»å‹™æˆ–åŠŸèƒ½çš„åç¨±ã€‚å”å®šç‚ºæ–¹æ³•ã€å±¬æ€§ã€ä»¥åŠå…¶ä»–ç‰¹å®šçš„ä»»å‹™éœ€æ±‚æˆ–åŠŸèƒ½å®šç¾©è—åœ–ã€‚å”å®šå¯è¢« classã€structã€æˆ– enum é¡å‹æ¡ç´ä»¥æä¾›æ‰€éœ€åŠŸèƒ½çš„å…·é«”å¯¦ç¾ã€‚æ»¿è¶³äº†å”å®šä¸­éœ€æ±‚çš„ä»»æ„é¡å‹éƒ½å«åšéµå¾ªäº†è©²å”å®šã€‚
#+end_verse

é™¤äº†æŒ‡å®šéµå¾ªé¡å‹å¿…é ˆå¯¦ç¾çš„è¦æ±‚å¤–ï¼Œä½ å¯ä»¥æ“´å±•ä¸€å€‹å”å®šä»¥å¯¦ç¾å…¶ä¸­çš„ä¸€äº›éœ€æ±‚æˆ–å¯¦ç¾ä¸€å€‹ç¬¦åˆé¡å‹çš„å¯ä»¥åˆ©ç”¨çš„é™„åŠ åŠŸèƒ½ã€‚[fn:6]
- ä¾‹å¦‚ï¼Œä½ å¯èƒ½æœ‰ä¸€å€‹åç‚º str çš„è®Šé‡ï¼Œå…¶é¡å‹ç‚º Stringã€‚èº«ç‚ºä¸€å€‹é–‹ç™¼äººå“¡ï¼Œä½ æ‡‰è©²çŸ¥é“ str ä»£è¡¨ Stringï¼Œå¦‚æœæˆ‘å€‘å®šç¾©äº†ä¸€å€‹åç‚º StringProtocol çš„å”å®šï¼Œå®ƒå…·æœ‰æ‰€æœ‰çš„ String çš„ APIï¼Œæˆ‘å€‘å¯ä»¥æ“´å±•ä»»ä½•é¡å‹å»éµå¾ª StringProtocolï¼ˆæ„æ€æ˜¯æ»¿è¶³å…¶æ‰€æœ‰è¦æ±‚ï¼‰ï¼Œå¦‚æ­¤ä¸€ä¾†ï¼Œå³å¯ä»¥ä½¿ç”¨è©²å°è±¡ï¼Œè®“å®ƒå°±åƒæ˜¯ä¸€å€‹ Stringï¼Œå„˜ç®¡æˆ‘å€‘ä¸çŸ¥é“å®ƒæ˜¯ä»€éº¼ï¼å¦‚æœçœ‹èµ·ä¾†åƒä¸€éš»é´¨å­ï¼Œæ¸¸æ³³åƒä¸€éš»é´¨å­ï¼Œå«è²åƒä¸€éš»é´¨å­ï¼Œé‚£å°±æ˜¯ä¸€éš»é´¨å­ã€‚æˆ‘å€‘æ–°çš„ StringProtocol å¯ä»¥å‘Šè¨´é‚£äº›éµå®ˆå®ƒå”å®šçš„é¡å‹èƒ½å¤ åšä»€éº¼ï¼Œä¸”ä¸éœ€è¦çŸ¥é“é€™äº›é¡å‹çš„è³‡è¨Šã€‚[fn:5]
** Protocol Syntax
*** Syntax
#+begin_src swift -r -n :results output :exports nil
protocol SomeProtocol {
    // protocol definition goes here
}
#+end_src
Classes , structs, enums can adopt these protocol by placing protocolâ€™s name after the typeâ€™s name, separated by a colon, as part of their definition. Multiple protocols can be listed, and are separated by commas:[fn:7]
#+begin_src swift -r -n :results output :exports nil
struct SomeStructure: FirstProtocol, AnotherProtocol {
    //structure definition goes here
}
#+end_src
*** DEMO
#+begin_src swift -r -n :results output :exports nil
protocol Polite {
    func sayHello()
}

struct Teacher: Polite {
    var name: String
    func sayHello() {
        print("åŒå­¸å¥½")
    }
}

struct Student: Polite {
    var name: String
    func sayHEllo() {
        print("è€å¸«å¥½")
    }
}

var aPolitePerson: Polite = Teacher()
aPolitePerson.name = "Mr. Yen"
aPolitePerson.sayHellow()
aPolitePerson = Student()
aPolitePerson.sayHello()
#+end_src
*** Adding property requirements
source: [[https://abhimuralidharan.medium.com/all-about-protocols-in-swift-11a72d6ea354][All about protocols in swift]]
- A protocol can have properties as well as methods that a class, enum or struct conforming to this protocol can implement.
- A protocol declaration only specifies the required property name and type. It doesnâ€™t say anything about whether the property should be a stored one or a computed one.
- A protocol also specifies whether each property must be gettable or gettable and settable.
- Property requirements are always declared as variable properties, prefixed with the var keyword.
- Gettable and settable properties are indicated by writing { get set } after their type declaration, and gettable properties are indicated by writing { get }.
#+begin_src swift -r -n :results output :exports nil
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
#+end_src
*** Protocols with mutating methods
Mutating methods are methods that we use on value types like structs and enums. These methods are allowed to modify the instance it belongs to and any properties of that instance. A small example:

Consider a simple struct Rectangle:
#+begin_src swift -r -n :results output :exports nil
struct Rectangle {
    var width = 1
    var height = 1

    func area() -> Int {
        return width * height
    }

    mutating func scaleBy(value: Int) {
        width *= value
        height *= value
    }
}
#+end_src
The scaleBy(value:) method modifies the value of width and height. So it should be marked as mutating. Otherwise the compiler will throw error at you.

#+begin_verse
If you mark a protocol instance method requirement as mutating, you do not need to write the mutatingkeyword when writing an implementation of that method for a class. The mutating keyword is only used by structures and enumerations.
#+end_verse
Consider an enum and class implementing a protocol with mutating function:
#+begin_src swift -r -n :results output :exports nil
protocol Togglable {
    mutating func toggle()
}

enum OnOffSwitch: Toggglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}

var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()

class ToggleClass: Togglable {
    var someBool = false
    func toggle() {
        someBool = true
    }
}

let toggleClassObj = ToggleClass()
toggleClassObj.toggle()
#+end_src
*** Initializer Requirements
Protocols can have specific initializers like normal methods which the conforming types can implement.
#+begin_src swift -r -n :results output :exports nil
protocol SomeProtocol {
    init(someParameter: Int)
}
#+end_src
** DEMO
#+begin_src swift -r -n :results output :exports nil
protocol Sound {
    func makeSound()
}

struct Dog: Sound {
    func makeSound() {
        print("Woof")
    }
}

struct Tree: Sound {
    func makeSound() {
        print("Susrrate")
    }
}

struct iPhone: Sound {
    func makeSound() {
        print("Ring")
    }
}
#+end_src
** ç¯„ä¾‹
*** ç‰ˆæœ¬ 1
æœ¬ä¾‹ä¸­æœ‰å…©å€‹ struct: Song, Album ä»¥åŠä¸€å€‹ class ç”¨ä¾†æ’­æ”¾ Song æˆ– Albumï¼ŒåŸæœ¬çš„ Player è¦ç‚ºä¸åŒçš„ struct å¯«ä¸åŒçš„ funcï¼Œè€Œä¸”ç¨‹å¼ç¢¼å¤§å¤šé‡è¤‡ã€‚
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

struct Song {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

class Player {
    private let avPlayer = AVPlayer()

    func play(_ song: Song) {
        let item = AVPlayerItem(url: song.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }

    func play(_ album: Album) {
        let item = AVPlayerItem(url: album.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }
}
#+end_src
*** ç‰ˆæœ¬ 2
å®£å‘Šä¸€å€‹ protocolï¼Œå®šç¾© audioURL è®Šæ•¸(read only)ï¼Œç„¶å¾Œä»¤å…©å€‹ struct çš†éµå¾ªè©² protocol(æ–¹å¼æœ‰äºŒ)ï¼Œå¦‚æ­¤ï¼ŒåŸæœ¬çš„ Player class ä¸­çš„ play func å°±èƒ½åªå¯«ä¸€æ¬¡ã€‚
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol Playable {
    var audioURL: URL { get }
}

struct Song: Playable {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

extension Album: Playable {}
class Player {
    private let avPlayer = AVPlayer()

    func play(_ resource: Playable) {
        let item = AVPlayerItem(url: resource.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }
}
#+end_src
*** ç‰ˆæœ¬ 3
åŸæœ¬ protocol çš„çœŸæ­£æ„æ€å…¶å¯¦åªæ˜¯åœ¨ç¢ºå®š audioURL æ˜¯å¦èƒ½æ­£ç¢ºè½‰æ›æˆ Audioï¼Œæ‰€ä»¥å…¶å¯¦å°‡ protocol name ç”± Playable æ”¹ç‚º AudioURLConvertable æœƒæ›´è²¼è¿‘äº‹å¯¦ã€‚
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol AudioURLConvertable {
    var audioURL: URL { get }
}

struct Song: AudioURLConvertable {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album: AudioURLConvertable {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

class Player {
    private let avPlayer = AVPlayer()

    func play(_ resource: AudioURLConvertable) {
        let item = AVPlayerItem(url: resource.audioURL)
        avPlayer.replaceCurrentItem(with: item)
        avPlayer.play()
    }
}

#+end_src
** mutating
protocol é™¤äº†å¯ä»¥æä¾›å‚³å›å€¼å‹æ…‹çš„å½ˆæ€§ï¼Œä¹Ÿå¯ä»¥ç”¨ä¾†è®Šæ›´ class/struct ä¸­çš„å±¬æ€§ã€‚å¦‚ï¼š
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol Likeable {
    mutating func markAsLiked()
}

struct Song {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

extension Song: Likeable {
    mutating func markAsLiked() {
        isLiked = true
    }
}
#+end_src
å¯ä»¥åœ¨ä¸æ”¹è®ŠåŸ struct Album çš„æƒ…æ³ä¸‹ï¼Œè—‰ç”± extension ä¾†æ“´å…… Songï¼Œä½¿å…¶éµå¾ª Likeable protocolï¼Œæä¾›è®Šä¾›å±¬æ€§ isLiked çš„å€¼ï¼Œ*é€™åœ¨æ“´å…… API åŠŸèƒ½æ™‚ç‰¹åˆ¥æœ‰ç”¨*ã€‚
** æ“´å…… protocol
é™¤äº†æ“´å……ç¾æœ‰ structï¼Œprotocol ä¹Ÿå¯ä»¥ç”¨ä¾†æ“´å…… protocolï¼Œå¦‚ï¼š
#+begin_src swift -r -n :eval no
import Cocoa
import AVKit

protocol Likeable {
    var isLiked: Bool {get set}
}

extension Likeable {
    mutating func markAsLiked() {
        isLiked = true
    }
}

struct Song {
    var name: String
    var album: Album
    var audioURL: URL
    var isLiked: Bool
}

struct Album {
    var name: String
    var imageURL: URL
    var audioURL: URL
    var isLiked: Bool
}

extension Song: Likeable {}
extension Album: Likeable {}
#+end_src
** Further Reading
- [[https://docs.swift.org/swift-book/LanguageGuide/Protocols.html][Protocol]]
- [[https://appcoda.com.tw/swift-protocol/][Swifté–‹ç™¼æŒ‡å—ï¼šProtocolsèˆ‡Protocol Extensionsçš„ä½¿ç”¨å¿ƒæ³•]]
- [[https://abhimuralidharan.medium.com/all-about-protocols-in-swift-11a72d6ea354][All about protocols in SWIFT]]
- [[https://blog.csdn.net/XunCiy/article/details/107367571][Swift5 14.Protocols]]

#+latex:\newpage

* Enum
:PROPERTIES:
:CUSTOM_ID: SW-enum
:END:
enumerations(æˆ–ç¨±ç‚ºenums)æ˜¯Swiftä¸­ä¸€ç¨®ç‰¹æ®Šé¡å‹ï¼Œå®ƒå…è¨±ä½ è¡¨ç¤ºå¤šå€‹ã€Œæƒ…æ³ã€æˆ–å¯èƒ½æ€§ã€‚Enums(åˆ—èˆ‰)é¡ä¼¼æ–¼Boolï¼Œä½†Boolåªèƒ½æ˜¯trueæˆ–falseï¼Œenumså¯ä»¥ç”±é–‹ç™¼è€…è‡ªè¡Œå®šç¾©å„ç¨®æƒ…æ³[fn:16]

** without enum
å‡è¨­æˆ‘å€‘è¦ç™»éŒ„å­¸ç”Ÿçš„å­¸ç¿’ç­‰ç¬¬(A, B, C, D, E, F)ï¼Œå¦‚ä¸‹
#+begin_src swift -r -n :results output :exports nil
var Tom = "A"
var John = "B"
var James = "I" //Error
print(James)
#+end_src

ä¸Šè¿°ç¨‹å¼ä¸­çš„Jameså…¶ç­‰ç¬¬æ˜é¡¯è¶…å‡ºåˆç†ç¯„åœï¼Œå°æ–¼å¾ŒçºŒè¦é€²è¡Œçš„åˆ¤æ–·å¯èƒ½æœƒå‡ºç¾å¾ˆå¤§å•é¡Œï¼Œæ­¤æ™‚ä¾¿æ˜¯enumé©ç”¨æ™‚æ©Ÿ

** with enum
#+begin_src swift -r -n :results output :exports nil
enum grade {
    case A
    case B
    case C
    case D
    case E
    case F
}

var Tome = grade.A
var John = grade.B
var James = grade.C
#+end_src
åˆ¤æ–·æª”æ¡ˆä¸‹è¼‰çµæœç‚ºå¦ä¸€é …å…¸å‹çš„enumé©ç”¨æƒ…å¢ƒ:
#+begin_src swift -r -n :results output :exports nil
enum DownloadStatus {
    case downloading
    case finished
    case failed
    case cancelled
}
var currentStatus = DownloadStatus.downloading
#+end_src
** enumçš„rawValue

é…åˆrawValueå®šç¾©enumçš„å€¼ï¼Œå¯ä»¥è®“enumè‡ªå¸¶æœ‰æ„ç¾©çš„è³‡è¨Šã€‚[fn:17]
#+begin_src swift -r -n :results output :exports nil
enum Pet: String {
    case Dog = "ğŸ¶"
    case Cat = "ğŸ±"
    case Rabbit = "R"
}

var myPet = Pet.Rabbit
print("my pet is a \(myPet.rawValue)")    //output: my pet is a ğŸ°
#+end_src

#+RESULTS:
: my pet is a R
** enum v.s. switch
enumæœ€å¤§çš„ç”¨è™•å°±æ˜¯æ­é…switchã€‚
#+begin_src swift -r -n :results output :exports nil
let currentStatus = DownloadStatus.downloading

switch currentStatus {
case .downloading:
    print("Downloading...")

case .finished:
    print("Just finished the download...")

case .failed:
    print("Failed to download the file...")

case .cancelled:
    print("The download is cancelled...")
}
#+end_src

** Swiftåˆ—èˆ‰ä¸­æœ€å¼·å¤§çš„åŠŸèƒ½ä¹‹ä¸€ï¼šassociated values
associated valuesã€‚å®ƒå…è¨±æˆ‘å€‘åœ¨åˆ—èˆ‰ä¸­å„²å­˜é¡å¤–çš„æ•¸æ“šã€‚æˆ‘å€‘å®£å‘Šä¸€å€‹æ–°çš„åˆ—èˆ‰ï¼Œç¨±ç‚ºWeatherConditionï¼Œå®ƒè®“æˆ‘å€‘åœ¨æ¯å€‹å¤©æ°£æ¢ä»¶ä¸­å¯é¡å¤–æŒ¾å¸¶ä¸€äº›è³‡è¨Šï¼š
#+begin_src swift -r -n :results output :exports nil
enum Cloud {
    case cirrus
    case cumulus
    case altocumulus
    case stratus
    case cumulonimbus
}

enum WeatherCondition {
    case sunny(temperature: Float)
    case rainy(inchesPerHour: Float)
    case cloudy(cloudType: Cloud, windSpeed: Float)
}
#+end_src
WeatherConditionçš„å®£å‘Šã€‚æˆ‘å€‘æä¾›ä¸‰å€‹æƒ…å¢ƒï¼Œåœ¨enumæ¯å€‹æƒ…å¢ƒä¸­éƒ½å­˜æœ‰é™„åŠ è³‡è¨Šã€‚åœ¨sunnyæƒ…æ³ä¸‹ï¼Œå„²å­˜ä¸€å€‹åƒæ•¸åç¨±ç‚ºtemperatureçš„Floatã€‚åœ¨rainyæƒ…æ³ä¸‹ï¼Œé™„å¸¶ä¸€å€‹Floaté¡å‹çš„åƒæ•¸ï¼Œå‘½åç‚ºinchesPerHourï¼Œå¦å¤–åœ¨cloudyæƒ…æ³ä¸‹ï¼Œæˆ‘å€‘é™„å¸¶å…©å€‹åƒæ•¸ï¼Œåˆ†åˆ¥ç‚ºCloudé¡å‹çš„cloudTypeå’ŒFloaté¡å‹çš„windSpeedã€‚
#+begin_src swift -r -n :results output :exports nil
let currentWeather = WeatherCondition.cloudy(cloudType: .cirrus, windSpeed: 4.2)

switch currentWeather {
case .sunny(let temperature):
    print("It is sunny and the temperature is \(temperature).")

case .rainy(let inchesPerHour):
    print("It is raining at a rate of \(inchesPerHour) inches per hour.")

case .cloudy(let cloudType, let windSpeed):
    print("It is cloudy; there are \(cloudType) clouds in the sky, and the wind speed is \(windSpeed).")
}
#+end_src

* Struct v.s. Class
[[https://www.hackingwithswift.com/books/ios-swiftui/why-does-swiftui-use-structs-for-views][è³‡æ–™ä¾†æº:Why does SwiftUI use structs for views?]]
If you ever programmed for UIKit or AppKit (Appleâ€™s original user interface frameworks for iOS and macOS) youâ€™ll know that they use classes for views rather than structs. SwiftUI does not: we prefer to use structs for views across the board, and there are a couple of reasons why.[fn:8]
- Structs are simpler and faster than classes.
  In SwiftUI, all our views are trivial structs and are almost free to create. Think about it: if you make a struct that holds a single integer, the entire size of your struct isâ€¦ that one integer. Nothing else. No surprise extra values inherited from parent classes, or grandparent classes, or great-grandparent classes, etc â€“ they contain exactly what you can see and nothing more.

- You can see this in action when you look at the kinds of things that can be a view. We already used Color.red and LinearGradient as views â€“ trivial types that hold very little data. In fact, you canâ€™t get a great deal simpler than using Color.red as a view: it holds no information other than â€œfill my space with redâ€.

- In comparison, Appleâ€™s documentation for UIView lists about 200 properties and methods that UIView has, all of which get passed on to its subclasses whether they need them or not.
** What is in class/struct
[[https://www.avanderlee.com/swift/struct-class-differences/][è³‡æ–™ä¾†æº:Struct vs classes in Swift: The differences explained]]
*** What is a class in Swift?
A class in Swift is a reference type which can contain:
- properties
- methods
- subscripts
- initializers
- protocol conformances
- extensions

Itâ€™s often described as a template definition of an object, like in the following Article instance definition:
#+begin_src swift -r -n :results output :exports nil
class ArticleClass {
    let title: String
    let url: URL
    var readCount: Int = 0

    init(title: String, url: URL) {
        self.title = title
        self.url = url
    }
}
#+end_src
*** What is a struct in Swift?
A struct in Swift is a value type which, just like classes, can contain:
- properties
- methods
- subscripts
- initializers
- protocol conformances
- extensions

It can also be seen as a template definition of an object, like in the following Article instance definition:
#+begin_src swift -r -n :results output :exports nil
struct ArticleStruct {
    let title: String
    let url: URL
    var readCount: Int = 0
}
#+end_src
*** What are the differences between a struct and a class?
#+CAPTION: Difference between class and struct
#+LABEL:fig:StructClass
#+name: fig:StructClass
#+ATTR_LATEX: :width 300
#+ATTR_ORG: :width 300
#+ATTR_HTML: :width 300
[[file:images/coffee.gif]]
When you pass a class object around your program, you are actually passing a reference to that object, so different parts of your program can share and modify your object. When you pass a structure [ or enum] around your program, what gets passes around is a copy of the structure. So modifications to structures donâ€™t get shared.[fn:9]

One of the major benefits of value types is that they are thread-safe not requiring any
 synchronization.[fn:9] Structs always have unique owners, whereas with classes multiple things can point to the same value.[fn:10]

Classes donâ€™t need the *mutating* keyword before methods that change their properties, because you can change properties of constant classes.
In practice, what this means is that if we have two SwiftUI views and we send them both the same struct to work with, they actually each have a unique copy of that struct; if one changes it, the other wonâ€™t see that change. On the other hand, if we create an instance of a class and send that to both views, they will share changes.[fn:10]
Value vs reference types

One of the most important differences is that a struct is a value type while a class is a reference type. References to a class instance share single data which means that any changes in that class will be available to each reference.

#+begin_src swift -r -n :results output :exports nil
let articleClass = ArticleClass(title: "Struct vs Class", url: URL(string: "www.avanderlee.com")!)
let articleClassCopy = articleClass

articleClass.readCount = 10
print(articleClassCopy.readCount) // Prints: 10
#+end_src

A struct is a value type and will create a unique copy for each new reference.
#+begin_src swift -r -n :results output :exports nil
var articleStruct = ArticleStruct(title: "Struct vs Class", url: URL(string: "www.avanderlee.com")!, readCount: 0)
var articleStructCopy = articleStruct

articleStruct.readCount = 10
print(articleStructCopy.readCount) // Prints: 0
#+end_src
**** The benefit of mutation in safety
With this, structs have the benefit of mutation in safety as you can trust that no other part of your app is changing the data at the same time. This makes it easier to reason about your code and is especially helpful in multi-threaded environments where a different thread could alter your data at the same time.
**** Structs get an initializer for free
If you go back and compare the above code examples you can see that the ArticleClass has a defined initializer which is required for classes. Structs, however, get an initializer for free.
#+begin_src swift -r -n :results output :exports nil
// Before Swift 5.1 Memberwise initializers:
// Generated memberwise init: init(title: String, url: URL, readCount: Int)
let article = ArticleStruct(title: "", url: URL(string: "")!, readCount: 0)

// After Swift 5.1 Memberwise initializers, using the default 0 for read count
// Generated memberwise init: init(title: String, url: URL, readCount: Int = 0)
let article = ArticleStruct(title: "", url: URL(string: "")!)
#+end_src
**** Classes allow inheritance
Classes can inherit the characteristics of another class and with that, act like abstract classes. A common example is a custom view controller which inherit from UIViewController.

With protocols in Swift, this is often no longer needed and replaceable with protocols. Protocols can be used with both classes and structs while inheritance is only possible with classes.
Classes can be deinitialized

A class allows executing code just before it gets destroyed by using a deinit method. When you define the same deinit method in a struct youâ€™ll get the following error:
#+begin_verse
Deinitializers may only be declared within a class
#+end_verse
** å¦‚ä½•æ±ºæ“‡? / When should I go for a struct and when for a class?
A simple bullet point list will make it a lot easier to decide.
*** You should use a class when:
- Comparing instance identity is needed by using ===
- Shared mutable state is required
- Objective-C interoperability is required
*** You should use a struct when:
- Comparing instance data is needed by using ==
- Unique copies with an independent state are required
- The data is used in multiple threads
*** Try to go for a struct by default.
Structs make your code easier to reason about and make it easier to work in multithreaded environments which we often have while developing in Swift.
** DEMO
ä»¥ä¸‹é€™å€‹ View å¯æ­£å¸¸é‹ä½œï¼Œæ–¼ TextField ä¸­æ‰€åšçš„ç·¨è¼¯ä¿®æ”¹éƒ½æœƒå³æ™‚é¡¯ç¤ºæ–¼ Text ä¸­ã€‚
#+begin_src swift -r -n :results output :exports nil
struct User {
    var firstName" = Bilbo"
    var lastName = "Baggins"
}

struct ContentView: View {
    @State private var user = User()

    var body: some View {
        VStack {
            Text("Your name is \(user.firstName) \(user.lastName).")

            TextField("First name", text: $user.firstName)
            TextField("Last name", text: $user.lastName)
        }
    }
}
#+end_src
ä½†è‹¥å°‡ struct æ”¹ç‚º classï¼Œé›–ç¨‹å¼ä»å¯åŸ·è¡Œï¼Œä½† Text ä¸­çš„å§“åå»ä¸å†éš¨ TextField çš„ä¿®æ”¹è€Œé€£å‹•ã€‚
To fix this, we need to tell SwiftUI when interesting parts of our class have changed. By â€œinteresting partsâ€ I mean parts that should cause SwiftUI to reload any views that are watching our class â€“ itâ€™s possible you might have lots of properties inside your class, but only a few should be exposed to the wider world in this way.[fn:11]
è‹¥è¦å°‡ struct æ”¹ç‚º classï¼Œå‰‡ç¨‹å¼è¦æ”¹æˆï¼š
#+begin_src swift -r -n :results output :exports nil
class User: ObservableObject{
    @Published var firstName = "Bilbo"
    @Published var lastName = "Baggins"
}

struct ContentView: View {
    @ObservedObject var user = User()

    var body: some View {
        VStack {
            Text("Your name is \(user.firstName) \(user.lastName).")

            TextField("First name", text: $user.firstName)
            TextField("Last name", text: $user.lastName)
        }
    }
}
#+end_src
Our User class has two properties: firstName and lastName. Whenever either of those two changes, we want to notify any views that are watching our class that a change has happened so they can be reloaded. We can do this using the @Published property observer.

@Published is more or less half of @State: it tells Swift that whenever either of those two properties changes, it should send an announcement out to any SwiftUI views that are watching that they should reload.

How do those views know which classes might send out these notifications? Thatâ€™s another property wrapper, @ObservedObject, which is the other half of @State â€“ it tells SwiftUI to watch a class for any change announcements.

The @ObservedObject property wrapper can only be used on types that conform to the ObservableObject protocol. This protocol has no requirements, and really all it means is â€œwe want other things to be able to monitor this for changes.â€

As youâ€™ve seen, rather than just using @State to declare local state, we now take three steps:

- Make a class that conforms to the ObservableObject protocol.
- Mark some properties with @Published so that any views using the class get updated when they change.
- Create an instance of our class using the @ObservedObject property wrapper.

The end result is that we can have our state stored in an external object, and, even better, we can now use that object in multiple views and have them all point to the same values.
#+latex: \newpage

* TODO some
:PROPERTIES:
:CUSTOM_ID: some
:END:
#+begin_verse
Adding the keyword some in front of a return type indicates that the return type is opaque. [fn:12]
#+end_verse
** Generics
*** å•é¡Œ
Generics å…è¨±é–‹ç™¼è€…åœ¨ä¸åŒé¡å‹ä¸­è¤‡ç”¨ä½ çš„ç¨‹å¼ç¢¼ï¼Œç”¨ä¾†è§£æ±ºä¸‹åˆ—å•é¡Œï¼š
#+begin_src swift -r -n :eval no
func swapInts(_ a: inout Int, _ b: inout Int) {
    let temporaryB = b
    b = a
    a = temporaryB
}

var num1 = 10
var num2 = 20

swapInts(&num1, &num2)
print(num1)   // 20
print(num2)   // 10
#+end_src
ä½†è‹¥æƒ³äº¤æ›å­—ä¸²ï¼Œå‰‡è¦å¯«æˆ
#+begin_src swift -r -n :eval no
func swapStrings(_ a: inout String, _ b: inout String) {
    let temporaryB = b
    b = a
    a = temporaryB
}
#+end_src
å¯ä»¥ç™¼ç¾é™¤äº†åƒæ•¸ä¹‹å¤–ï¼Œé‡è¤‡çš„ code å¯¦åœ¨å¤ªå¤š
*** è§£æ±ºæ–¹æ¡ˆ
å°‡å›ºå®šå‹æ…‹çš„åƒæ•¸è½‰ç‚º Generic type
#+begin_src swift -r -n :eval no
import Cocoa

func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}


var num1 = 10
var num2 = 20

swapTwoValues(&num1, &num2)
print(num1)   // 20
print(num2)   // 10
#+end_src
å¦ä¸€å€‹ä¾‹å­ç‚º Stack çš„å¯¦ä½œï¼š
åŸæœ¬åªèƒ½å„²å­˜ Int çš„ Stack å¦‚ä¸‹ï¼Œè‹¥è¦å„²å­˜å­—ä¸²å‰‡è¦å†å¦è¡Œå®šç¾©ã€‚
#+begin_src swift -r -n :eval no
struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
#+end_src
æ”¹ç‚º Generic type å¾Œå¯å‹•æ…‹è®Šæ›´ç‚ºæ•´æ•¸ stack æˆ–å­—ä¸² stackï¼Œå¦‚ï¼š
#+begin_src swift -r -n :eval no
struct Stack<Element> {
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}

var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// the stack now contains 4 strings

#+end_src
** opaque
å¸¶æœ‰ä¸é€æ˜ï¼ˆopaqueï¼‰è¿”å›é¡å‹çš„å‡½æ•¸æˆ–æ–¹æ³•ï¼Œå°‡æœƒéš±è—å…¶è¿”å›å€¼çš„é¡å‹[fn:13]
#+latex:\newpage

* TODO é€²éšä¸»é¡Œ
:PROPERTIES:
:CUSTOM_ID: advanced
:END:
- [[https://developer.apple.com/design/human-interface-guidelines/][Human Interface Guidelines]]: Apple çš„äººæ©Ÿè¨­è¨ˆç•Œé¢æŒ‡å—
- [[https://developer.apple.com/documentation][Apple Developer Documentation]]: Apple é–‹ç™¼è€…æ–‡ä»¶
- [[https://www.appcoda.com.tw/protocol-extension/][åˆ©ç”¨ Protocol Extension æ¸›å°‘é‡è¦†çš„ Codeã€€å¤§å¤§å¢å¼· Code çš„ç¶­è­·æ€§]]
- [[https://appcoda.com.tw/mastering-swift/][ç²¾é€šSwiftï¼šåˆ—èˆ‰ã€é–‰åŒ…ã€æ³›å‹ã€Protocolså’Œé«˜éšå‡½æ•¸]]
#+latex:\newpage

* Footnotes

[fn:17] [[https://hugolu.gitbooks.io/learn-swift/content/Advanced/Enum.html][Swiftå­¸ç¿’ç­†è¨˜ ]]

[fn:16] [[https://appcoda.com.tw/mastering-swift/][ç²¾é€šSwiftï¼šåˆ—èˆ‰ã€é–‰åŒ…ã€æ³›å‹ã€Protocolså’Œé«˜éšå‡½æ•¸]]

[fn:15] [[https://medium.com/tarkalabs/all-about-debounce-4-ways-to-achieve-debounce-in-swift-e8f8ce22f544][All about debounce: 4 ways to achieve debounce in Swift]]

[fn:14] [[https://hugolu.gitbooks.io/learn-swift/content/Advanced/HighOrderFunctions.html#map][ How to use Picker with enum in SwiftUI ]]

[fn:1] [[https://www.raywenderlich.com/6742901-protocol-oriented-programming-tutorial-in-swift-5-1-getting-started][Protocol-Oriented Programming Tutorial in Swift 5.1: Getting Started]]

[fn:2] [[https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E7%B0%A1%E6%98%93%E8%AA%AA%E6%98%8Eswift-4-protocol-919b7f9cbaee][ã€ç°¡æ˜“èªªæ˜Swift 4ã€Protocol]]

[fn:3] [[https://www.appcoda.com.tw/protocol-extension/][åˆ©ç”¨ Protocol Extension æ¸›å°‘é‡è¦†çš„ Codeã€€å¤§å¤§å¢å¼· Code çš„ç¶­è­·æ€§]]

[fn:4] [[https://docs.swift.org/swift-book/LanguageGuide/Protocols.html][Protocols]]

[fn:5] [[https://www.appcoda.com.tw/swift-protocol/][Swifté–‹ç™¼æŒ‡å—ï¼šProtocolsèˆ‡Protocol Extensionsçš„ä½¿ç”¨å¿ƒæ³•]]

[fn:6] [[https://ithelp.ithome.com.tw/articles/10197366][Day-29 Swift èªæ³•(25) - å”å®š Protocol]]

[fn:7] [[https://abhimuralidharan.medium.com/all-about-protocols-in-swift-11a72d6ea354][All about protocols in swift]]

[fn:8] [[https://www.hackingwithswift.com/books/ios-swiftui/why-does-swiftui-use-structs-for-views][Why does SwiftUI use structs for views?]]

[fn:9] [[https://abhimuralidharan.medium.com/difference-between-a-struct-and-a-class-in-swift-53e08df73714][Difference between a struct and a class in Swift]]

[fn:10] [[https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs][Why @State only works with structs]]

[fn:11] [[https://www.hackingwithswift.com/books/ios-swiftui/sharing-swiftui-state-with-observedobject][Sharing SwiftUI state with @ObservedObject]]

[fn:12] [[https://medium.com/@PhiJay/whats-this-some-in-swiftui-34e2c126d4c4][Whatâ€™s this â€œsomeâ€ in SwiftUI?]]

[fn:13] [[https://medium.com/jeremy-xue-s-blog/swift-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80-opaque-types-600ad5758b91][Swift ç¨‹å¼èªè¨€ â€” Opaque Types]]
