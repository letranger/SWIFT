#+TITLE: Swift Introduction
#+INCLUDE: ../web.org

#+latex:\newpage

* The Basics
:PROPERTIES:
:CUSTOM_ID: basic
:END:
Swift æ˜¯ 2014 å¹´ç”±è˜‹æœå…¬å¸åœ¨å…¶é–‹ç™¼è€…å¤§æœƒ WWDC ä¸Šæ‰€ç™¼ä½ˆçš„ç¨‹å¼èªè¨€

The Swift Programming Language ä¸€æ›¸ä¸­æåˆ°[fn:1]ï¼š
1. Swift ç”¨ä¾†æ’°å¯« iOS åŠ Mac OSX çš„ç¨‹å¼ã€‚
2. Swift å¸æ”¶äº† C å’Œ Objective-C çš„å„ªé»ï¼Œä½¿å…¶åœ¨è¨­è¨ˆæ›´å…·å½ˆæ€§ã€å®¹æ˜“ï¼Œä¸”æ’°å¯«æ™‚æœ‰æ›´å¤šæ¨‚è¶£ã€‚
3. Swift æ˜¯åŸºæ–¼æˆç†Ÿè€Œä¸”å€å—å–œæ„›çš„ Cocoa å’Œ Cocoa Touch frameworkï¼Œæ„å³ Swift å¯ä»¥ç›´æ¥ä½¿ç”¨é€™äº›ç¾æœ‰çš„æ¡†æ¶
4. Swift å…¼å…·ç·¨è­¯èªè¨€çš„æ€§èƒ½ï¼Œä»¥åŠç›´è­¯å¼èªè¨€çš„ç‰¹æ€§ã€‚

* Learning Resources
:PROPERTIES:
:CUSTOM_ID: resources
:END:
** Web sites
- [[https://swiftdoc.org/][swiftdoc.org]]
- Swift å®˜æ–¹ç·šä¸Šå­¸ç¿’æ‰‹å†Š: [[https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html][The Swift Programming Language]]
- [[https://www.cnswift.org/the-basics][Swift ç¼–ç¨‹è¯­è¨€]]
- [[https://www.hackingwithswift.com/quick-start/swiftui][SwiftUI by Example]]
- [[https://www.hackingwithswift.com/100/swiftui][https://www.hackingwithswift.com/100/swiftui]]
- [[http://swiftdeveloperblog.com/code-examples/][Swift Developer Blog]]
- [[https://gradyzhuo.gitbooks.io/meetswifttutorial/content/Episode_1/Chapter_1.html][ç¬¬ä¸€ç«  - Class, Struct and Enum çš„æŠ‰æ“‡]]
- [[https://www.hackingwithswift.com/quick-start/swiftui][Hacking with SWIFT]]
- [[https://github.com/search?q=language%3Aswift&ref=cmdform][Github#swift]]
- [[https://stackoverflow.com/questions/tagged/swift][Stack Overflow#swift]]

** Videos
- [[https://www.youtube.com/watch?v=Ulp1Kimblg0][Swift Programming Tutorial for Beginners (Full Tutorial)]]
- [[https://www.raywenderlich.com/ios][iOS & Swift Videos]]

* Swift å¸¸æ•¸èˆ‡è®Šæ•¸
:PROPERTIES:
:CUSTOM_ID: variable
:END:
** å®£å‘Šå¸¸æ•¸å’Œè®Šæ•¸
å¸¸æ•¸å’Œè®Šæ•¸å¿…é ˆåœ¨ä½¿ç”¨å‰å®£å‘Šï¼Œç”¨ let ä¾†å®£å‘Šå¸¸æ•¸ï¼Œç”¨ var ä¾†å®£å‘Šè®Šæ•¸ã€‚ä¸‹é¢çš„ç¯„ä¾‹å±•ç¤ºäº†å¦‚ä½•ç”¨å¸¸æ•¸å’Œè®Šæ•¸ä¾†è¨˜éŒ„ä½¿ç”¨è€…å˜—è©¦ç™»éŒ„çš„æ¬¡æ•¸ï¼š
#+begin_src swift -r -n :results output :exports both
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
#+end_src
ä½ å¯ä»¥åœ¨ä¸€è¡Œä¸­å®£å‘Šå¤šå€‹å¸¸æ•¸æˆ–è€…å¤šå€‹è®Šæ•¸ï¼Œç”¨é€—è™Ÿéš”é–‹ï¼š
#+begin_src swift -r -n :results output :exports both
var x = 0.0, y = 0.0, z = 0.0
var population = 8_000_000
x = 3
y = 4
#+end_src

** Swift v.s. C/C++
Swift çš„è®Šæ•¸å®£å‘Šèˆ‡ C/C++çš„å·®ç•°ä¹‹ä¸€åœ¨æ–¼å®£å‘Šæ™‚ä¸å¿…è¦å…ˆå®£å‘Šè®Šæ•¸å‹åˆ¥ï¼Œä¾‹å¦‚ï¼ŒåŒæ¨£è¦å®£å‘Šä¸€å°æ•¸è®Šæ•¸èˆ‡æ•´æ•¸è®Šæ•¸ï¼ŒC++çš„åšæ³•ç‚º
#+begin_src swift -r -n :results output :exports both
int x = 20;
double pi = 3.1416;
#+end_src
è€Œ Swift çš„å¯«æ³•ç‚ºï¼š
#+begin_src swift -r -n :results output :exports both
var x = 20
var pi = 3.1416
#+end_src

** Swift is a type-safe language
We declared the variable /numOfStudent/ and assigned 42 (ç¬¬[[(safeType)]]è¡Œ) as its initial value, Swift will assigned it the type integer. We can't change its type: it will always be an integer.
#+begin_src swift -r -n
var numOfStudent = 42 (ref:safeType)
numOfStudent = 30
numOfStudent = 25.8
numOfStudent = "fourty" // wrong
#+end_src

#+RESULTS:
#+BEGIN_EXAMPLE
: <stdin>:3:16: error: cannot assign value of type 'Double' to type 'Int'
: numOfStudent = 25.8
:                ^~~~
:                Int()
#+END_EXAMPLE

** å¸¸æ•¸èˆ‡è®Šæ•¸çš„å‘½å
æˆ‘å€‘å¯ä»¥ä½¿ç”¨å–œæ­¡çš„å­—å…ƒä½œç‚ºå¸¸æ•¸å’Œè®Šæ•¸åï¼ŒåŒ…æ‹¬ Unicode å­—å…ƒï¼š
#+begin_src swift -r -n :results output :exports both
let Ï€ = 3.14159
let ä½ å¥½ = "ä½ å¥½ä¸–ç•Œ"
let ğŸ¶ğŸ® = "dogcow"
Ï€ = 3.14 // try to change the value of constant and find out what happen
#+end_src
ä½† Swift çš„è®Šæ•¸äº¦æœ‰å…¶é™åˆ¶ï¼ŒåŒ…æ‹¬ï¼šå¸¸æ•¸èˆ‡è®Šæ•¸åä¸èƒ½åŒ…å«æ•¸å­¸ç¬¦è™Ÿã€ç®­é ­ã€ä¿ç•™çš„ï¼ˆæˆ–è€…éæ³•çš„ï¼‰Unicode ç¢¼ä½ã€é€£ç·šèˆ‡åˆ¶è¡¨å­—å…ƒï¼ˆbox-drawing charactersï¼‰ï¼Œä¹Ÿä¸èƒ½ä»¥æ•¸å­—é–‹é ­ï¼Œä½†æ˜¯å¯ä»¥åœ¨å¸¸æ•¸èˆ‡è®Šæ•¸åçš„å…¶ä»–åœ°æ–¹åŒ…å«æ•¸å­—ã€‚

** è®Šæ•¸èˆ‡å¸¸æ•¸çš„è¼¸å‡º
#+begin_src swift -r -n :results output :exports both
var x = 20
var pi = 3.1416
print(x)
print(pi)
#+end_src

#+RESULTS:
: 20
: 3.1416

** è®Šæ•¸èˆ‡å¸¸æ•¸çš„åŸºæœ¬è¦ç¯„
- ä½¿ç”¨å‰éœ€å…ˆå®£å‘Š
- ä¸èƒ½é‡è¤‡å®£å‘Š
#+begin_src swift -r -n :eval no
var x = 30
let y = 10
// invalid redeclaration of variable
var x = 40
let y = 5
#+end_src

** Stored variable v.s. Computed variable
*** computed variable
#+begin_src swift -r -n :results output :exports both
var x: Double = 4.3
var y: Double = 3.4
var z: Double {
    return x*y
}
print(z)
x = 10
y = 10
print(z) //è‡ªå‹•é‡æ–°è¨ˆç®—zå€¼
#+end_src

#+RESULTS:
: 14.62
: 100.0

*** contentView è£¡çš„ body å°±æ˜¯ computed variable
#+begin_src swift -r -n :eval no
var body: som View {
    return Text("Hello world")
}
#+end_src

* åŸºæœ¬é‹ç®—
:PROPERTIES:
:CUSTOM_ID: operation
:END:
** æŒ‡æ´¾é‹ç®—å­
æŒ‡æ´¾é‹ç®—ï¼ˆa = bï¼‰ï¼Œè¡¨ç¤ºç”¨ b çš„å€¼ä¾†åˆå§‹åŒ–æˆ–æ›´æ–° a çš„å€¼ï¼š
#+begin_src swift -r -n :results output :exports both
let b = 10
var a = 5
a = b
// a ç¾åœ¨ç­‰æ–¼ 10

let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
#+end_src

** æ•¸å€¼é‹ç®—å­
*** Swift æ”¯æ´æ‰€æœ‰æ•¸å€¼å‹åˆ¥åŸºæœ¬é‹ç®—ï¼š
- åŠ æ³•(+)
- æ¸›æ³•(-)
- ä¹˜æ³•(*)
- é™¤æ³•(/)
- é¤˜æ•¸(%)
#+begin_src swift -r -n :results output :exports both
print(1 + 2)       // ç­‰æ–¼ 3
print(5 - 3)       // ç­‰æ–¼ 2
print(2 * 3)       // ç­‰æ–¼ 6
print(10.0 / 2.5)  // ç­‰æ–¼ 4.0
print(10 / 3)      // ç­‰æ–¼ 1
print(10 & 3)      // ç­‰æ–¼ 1
#+end_src

#+RESULTS:
: 3
: 2
: 6
: 4.0
: 3
: 32.0

*** ä¸åŒæ•¸å€¼çš„é‹ç®—
#+begin_src swift -r -n :results output : exports both
var r = 10
var pi = 3.14
//print(r*r*pi)  // Try this Error
print(Double(r)*Double(r)*pi)
#+end_src

#+RESULTS:
: 314.0

*** åŠ æ³•é‹ç®—å­ä¹Ÿç”¨æ–¼ String çš„æ‹¼æ¥ï¼š
#+begin_src swift -r -n :results output :exports both
"hello, " + "world"  // ç­‰æ–¼ "hello, world"
#+end_src

** è¤‡åˆæŒ‡æ´¾é‹ç®—å­ï¼ˆCompound Assignment Operatorsï¼‰
#+begin_src swift -r -n :results output :exports both
var a = 1
a += 2 // a ç¾åœ¨æ˜¯ 3 (ref:+=)
#+end_src
ä¸Šè¿°ç¨‹å¼ç¬¬[[(+=)]]è¡Œä¸­çš„ a += 2 ç‚º a = a + 2 çš„å¦ä¸€ç¨®å¯«æ³•ï¼Œå…¶ä»–é‹ç®—å­å¦‚-ã€*ã€/ã€%çš†å¯å¥—ç”¨åŒæ¨£çš„ç°¡å¯«æ–¹å¼ã€‚

** é‚è¼¯é‹ç®—å­
é‚è¼¯é‹ç®—çš„æ“ä½œç‰©ä»¶æ˜¯é‚è¼¯å¸ƒæ—å€¼ã€‚Swift æ”¯æ´åŸºæ–¼ C èªè¨€çš„ä¸‰å€‹æ¨™æº–é‚è¼¯é‹ç®—ã€‚
- é‚è¼¯éï¼ˆ!aï¼‰
- é‚è¼¯ä¸”ï¼ˆa && bï¼‰
- é‚è¼¯æˆ–ï¼ˆa || bï¼‰

* Property Observers
:PROPERTIES:
:CUSTOM_ID: observer
:END:
** Set/Get
åœ¨ä»¥å¾€çš„ç¶“é©—ä¸­ï¼Œå°è®Šæ•¸é€²è¡Œ assign æ˜¯ä¸€ä»¶ç›´è¦ºè€Œç°¡å–®çš„äº‹ï¼Œä¾‹å¦‚ï¼š
#+begin_src swift -r -n :results output :exports both
var x: Int = 4
var y: Int = 5
var z: Int

z = x + y
print(z)
#+end_src

#+RESULTS:
: 9

é¡ä¼¼ C#ï¼Œåœ¨ Swift ä¸­ï¼Œæˆ‘å€‘å»èƒ½é€é Set/Get ä¾†ä»‹å…¥ assign çš„éç¨‹ï¼Œä¾‹å¦‚ï¼š
#+begin_src swift -r -n :results output :exports nil
var x: Int = 4
var y: Int = 5
var z: Int {
    get { return x + y }
    set { y = newValue - x } (ref:set)
}

print(z)
z = 30
print("xæ–°å€¼: \(x), yæ–°å€¼: \(y)")
#+end_src

#+RESULTS:
: 9
: x æ–°å€¼: 4, y æ–°å€¼: 26

å¦‚ä¸Šä¾‹ä¸­ï¼Œæˆ‘å€‘å¯ä»¥å¤¾å¸¶ä¸€äº›ç¨‹å¼ç¢¼ï¼Œåœ¨æœ‰äººè³¦äºˆ z æ–°å€¼æ™‚(z=?)åˆ©ç”¨ set(ç¬¬[[(set)]]è¡Œ)è§¸ç™¼é€™äº›ç¨‹å¼ç¢¼ï¼›åŒç†ï¼Œä¹Ÿå¯ä»¥åœ¨æœ‰äººè®€å–å…¶å€¼æ™‚è§¸ç™¼ã€‚è€Œ newValue ä»£è¡¨è¢« assign çš„æ–°å€¼ã€‚

åˆå¦‚ä¸‹ä¾‹ï¼ŒæŸå­¸ç”Ÿçš„æœŸä¸­è€ƒä¸‰ç§‘æˆç¸¾å°±å¯ä»¥åœ¨è¼¸å…¥æˆç¸¾å¾Œè‡ªè¡Œåˆ¤æ–·å„ç§‘æ˜¯å¦åŠæ ¼
#+begin_src swift -r -n :results output :exports nil
class MidExam {
    var id: String = ""
    var chPass = false
    var ch: Int = 0 {
        didSet { (ref:didset1)
            if ch >= 60 {chPass = true}
        }
    }
    var maPass = false
    var ma: Int = 0 {
        didSet { (ref:didset2)
            if ma >= 60 {maPass = true}
        }
    }
}

let stsc = MidExam()
stsc.id = "202010101"
stsc.ch = 70
stsc.ma = 32

print(stsc.chPass)
print(stsc.maPass)
#+end_src

#+RESULTS:
: true
: false

ä¸Šè¿°ç¨‹å¼ç¬¬[[(didset1)]]åŠ[[(didset2)]]è¡Œä¸­çš„ didSet æœƒåœ¨è®Šæ•¸è¢« assign æ–°å€¼æ™‚è§¸ç™¼åŸ·è¡Œï¼Œè€Œ willSet å‰‡æ˜¯åœ¨è®Šæ•¸å³å°‡è¢« assign æ™‚è§¸ç™¼ã€‚

** willSet/set/didSet
- ä½¿ç”¨ set æ™‚ï¼Œå› ç‚ºè®Šæ•¸çš„å€¼æ­£åœ¨è¢«æ”¹è®Šï¼Œæ‰€ä»¥æœ‰ newValue ä¾†å„²å­˜æ–°å€¼ï¼›
- ä½¿ç”¨ willSet å‰‡è®Šæ•¸å°šæœªè¢«æ”¹è®Šï¼›
- ä½¿ç”¨ didSet å‰‡æ˜¯è®Šæ•¸å·²è¢«æ”¹è®Šï¼Œæ‰€ä»¥æœ‰ oldValue
æ ¹æ“š apple çš„èªªæ³•ï¼ŒwillSet å’Œ didSet ä¸æœƒåœ¨ init ä¸­è¢«å‘¼å«ï¼šThe willSet and didSet observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They are not called while a class is setting its own properties, before the superclass initializer has been called.[fn:2]

* æ§åˆ¶æµç¨‹
:PROPERTIES:
:CUSTOM_ID: flow-control
:END:
** Conditional Statement
The following examples were from [[https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#][docs.swift.org.]]
*** if
In its simplest form, the if statement has a single if condition. It executes a set of statements only if that condition is true.
**** single condition
#+begin_src swift -r -n :eval no
var temperatureInFahrenheit = 30
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
}
#+end_src

**** combined conditions
#+begin_src swift -r -n :eval no
var mathScore = 91
if mathScore <= 100 && mathScore >= 90 {
    print("Grade A")
}
#+end_src

*** if-else
The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false.
#+begin_src swift -r -n :eval no
temperatureInFahrenheit = 40
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
} else {
    print("It's not that cold. Wear a t-shirt.")
}
#+end_src

*** if-else if
You can chain multiple if statements together to consider additional clauses.
#+begin_src swift -r -n :eval no
temperatureInFahrenheit = 90
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
} else if temperatureInFahrenheit >= 86 {
    print("It's really warm. Don't forget to wear sunscreen.")
} else {
    print("It's not that cold. Wear a t-shirt.")
}
#+end_src

*** switch
In its simplest form, a switch statement compares a value against one or more values of the same type.
#+begin_src swift -r -n :eval no
switch some value to consider {
case value 1:
    respond to value 1
case value 2,
     value 3:
    respond to value 2 or 3
default:
    otherwise, do something else
}
#+end_src
This example uses a switch statement to consider a single lowercase character called someCharacter:
#+begin_src swift -r -n :eval no
let someCharacter: Character = "z"
switch someCharacter {
case "a":
    print("The first letter of the alphabet")
case "z":
    print("The last letter of the alphabet")
default:
    print("Some other character")
}
#+end_src
#+begin_src swift -r -n :eval no
// æŠŠåˆ†æ•¸è½‰æˆç­‰ç¬¬
// A(90-100), B(80-90), C(70-80), D(60-70), E(60-)
import Foundation

let str = readLine()    //å¾éµç›¤è®€å…¥ä¸€å­—ä¸², å­˜åˆ°strä¸­
let choice = Int(str!)   //æŠŠstrè½‰æˆæ•´æ•¸ï¼Œå­˜å…¥score

switch choice! {
case 90..<101:
    print("A")
case 80..<90:
    print("B")
case 70..<80:
    print("C")
default:
    print("E")
}

#+end_src

** For-In Loops
*** èªæ³•
#+begin_src swift -r -n :eval no
for counter in lower...upper{
    your codes
}
#+end_src
*** DEMO
#+begin_src swift -r -n :results output :exports both
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
#+end_src

#+RESULTS:
: 1 times 5 is 5
: 2 times 5 is 10
: 3 times 5 is 15
: 4 times 5 is 20
: 5 times 5 is 25

#+begin_src swift -r -n :results output :exports both
let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
print("\(base) to the power of \(power) is \(answer)")
#+end_src

#+RESULTS:
: 3 to the power of 10 is 59049

** While Loops
A while loop performs a set of statements until a condition becomes false. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of while loops:

- while evaluates its condition at the start of each pass through the loop.
- repeat-while evaluates its condition at the end of each pass through the loop.

*** while
A while loop starts by evaluating a single condition. If the condition is true, a set of statements is repeated until the condition becomes false.

**** èªæ³•
#+begin_src swift -r -n :eval no
while condition {
    your codes here
}
#+end_src

**** DEMO
#+begin_src swift -r -n :results output :exports both
var counter = 5
while counter > 0 {
    print("Hello, \(counter)")
    counter -= 1
}
#+end_src

#+RESULTS:
: Hello, 5
: Hello, 4
: Hello, 3
: Hello, 2
: Hello, 1

*** repeat ... while
The other variation of the while loop, known as the repeat-while loop, performs a single pass through the loop block first, before considering the loopâ€™s condition. It then continues to repeat the loop until the condition is false.

**** èªæ³•
#+begin_src swift -r -n :eval no
repeat {
    your codes here
} while condition
#+end_src

**** DEMO
#+begin_src swift -r -n :results output :exports both
var counter = 5
repeat {
    print("Hello, \(counter)")
    counter -= 1
} while counter > 0
#+end_src

#+RESULTS:
: Hello, 5
: Hello, 4
: Hello, 3
: Hello, 2
: Hello, 1

* é›†åˆå‹åˆ¥
:PROPERTIES:
:CUSTOM_ID: set
:END:
Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.[fn:3]
#+CAPTION: Collection Types of Swift
#+LABEL:fig:cts
#+name: fig:cts
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/CollectionTypes_intro_2x.png]]
** é™£åˆ—ï¼ˆArraysï¼‰
é™£åˆ—ä½¿ç”¨æœ‰åºåˆ—è¡¨å„²å­˜åŒä¸€å‹åˆ¥çš„å¤šå€‹å€¼ã€‚ç›¸åŒçš„å€¼å¯ä»¥å¤šæ¬¡å‡ºç¾åœ¨ä¸€å€‹é™£åˆ—çš„ä¸åŒä½ç½®ä¸­ã€‚
*** é™£åˆ—å»ºæ§‹èªæ³•
è¦å»ºç«‹ä¸€å€‹ç©ºçš„æ•´æ•¸é™£åˆ—ï¼š
#+begin_src swift -r -n :results output :exports both
var EnglishScores = [Int]()
print(EnglishScores)
// OR
var NameArray = [String]()
#+end_src

#+RESULTS:
: []

ä¸‹é¢é€™å€‹ç¯„ä¾‹å‰µå»ºäº†ä¸€å€‹å«åš shoppingList ä¸¦ä¸”å„²å­˜å­—ä¸²çš„é™£åˆ—ï¼š
#+begin_src swift -r -n :results output :exports both
var shoppingList: [String] = ["Eggs", "Milk"]
// shoppingList å·²ç¶“è¢«å»ºæ§‹ä¸¦ä¸”æ“æœ‰å…©å€‹åˆå§‹é …ã€‚
#+end_src

#+RESULTS:

*** å­˜å–å’Œä¿®æ”¹é™£åˆ—
æˆ‘å€‘å¯ä»¥é€šéé™£åˆ—çš„æ–¹æ³•å’Œå±¬æ€§ä¾†å­˜å–å’Œä¿®æ”¹é™£åˆ—ï¼Œæˆ–è€…ä¸‹æ¨™èªæ³•ã€‚ é‚„å¯ä»¥
- ä½¿ç”¨é™£åˆ—çš„å”¯è®€å±¬æ€§ count ä¾†ç²å–é™£åˆ—ä¸­çš„è³‡æ–™é …æ•¸é‡
- ä½¿ç”¨å¸ƒæ—é … isEmpty ä¾†ä½œç‚ºæª¢æŸ¥ count å±¬æ€§çš„å€¼æ˜¯å¦ç‚º 0
- ä½¿ç”¨ append æ–¹æ³•åœ¨é™£åˆ—å¾Œé¢æ·»åŠ æ–°çš„è³‡æ–™é …
- +=
- remove(at: index)
#+begin_src swift -r -n :results output :exports both
var shoppingList: [String]  = ["Eggs", "Milk"]
print(shoppingList.count)
print(shoppingList.isEmpty)
shoppingList += ["Bird"]  // Not += "Bird"
shoppingList.append("Fish")
print(shoppingList)
print(shoppingList[0])
shoppingList += ["Beer"]
print(shoppingList)
shoppingList.remove(at: 1)
print(shoppingList)
#+end_src

#+RESULTS:
: 2
: false
: ["Eggs", "Milk", "Bird", "Fish"]
: Eggs
: ["Eggs", "Milk", "Bird", "Fish", "Beer"]
: ["Eggs", "Bird", "Fish", "Beer"]

*** ä»¥ for éæ­·é™£åˆ—
#+begin_src swift -r -n :results output :exports both
var shoppingList: [String]  = ["Eggs", "Milk", "Beer"]
for index in 0...2 {
    print(shoppingList[index])
}
for item in shoppingList {
    print(item)
}
#+end_src

#+RESULTS:
: Eggs
: Milk
: Beer
: Eggs
: Milk
: Beer

*** ä»¥ repeat ç”¢ç”Ÿ array
If you need to create an array of a specific size holding some default values, Swift has a built-in initializer called repeating:count:. You tell it what to repeat, and how often, and Swift will generate an array of that size.[fn:13]
#+begin_src swift -r -n :results output :exports nil
let nums1 = [Int](repeating: 0, count: 10)
let str1 = [String](repeating: "TNFSH", count: 5)
print(nums1)
print(str1)

let nums2 = [[Int]](repeating: [Int](repeating: 6, count: 3), count: 2)
print(nums2)
#+end_src

#+RESULTS:
: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
: ["TNFSH", "TNFSH", "TNFSH", "TNFSH", "TNFSH"]
: [[6, 6, 6], [6, 6, 6]]

*** Modify array
**** map: æ‰¹æ¬¡ update array
é€šå¸¸æˆ‘å€‘æœƒä½¿ç”¨åˆ° map å‡½æ•¸çš„åŸå› ï¼Œä¸»è¦æ˜¯è¦å°‡é™£åˆ—çš„å…§å®¹é€²è¡Œæ‰¹æ¬¡è®Šæ›´[fn:12]ï¼Œå¦‚ï¼š
  #+begin_src swift -r -n :results output :exports nil
let origin = ["James", "Vanessa", "Ruby", "Letranger"]
let lowercaseVersion = origin.map { $0.lowercased() }
print(lowercaseVersion)

let letterCounts = origin.map { $0.count }
print(letterCounts)

let nums = [0, 1, 2, 3, 4, 5]
let doubleNums = nums.map { (number) -> Int in
    number * 2
}
print(doubleNums)

let doubleStrings = nums.map { (number) -> String in
    "2 * \(number) = \(number * 2)"
}
print(doubleStrings)
  #+end_src

  #+RESULTS:
  : ["james", "vanessa", "ruby", "letranger"]
  : [5, 7, 4, 9]
  : [0, 2, 4, 6, 8, 10]
  : ["2 * 0 = 0", "2 * 1 = 2", "2 * 2 = 4", "2 * 3 = 6", "2 * 4 = 8", "2 * 5 = 10"]

*** flatMap()
flatMap å…¶å¯¦å°±æ˜¯ flat + map çš„çµæœã€‚è€Œ flatMap æœ€å¸¸æ˜¯ç”¨ä¾†è™•ç†æ”¤å¹³æŸå€‹é™£åˆ—çš„ç‹€æ³[fn:12]
#+begin_src swift -r -n :results output :exports nil
let nums = [2, 3, 4]
let mapped = nums.map { Array(repeating: $0, count: $0) }
print(mapped)

let flatMapped = mapped.flatMap{$0} (ref:flat)
print(flatMapped)

#+end_src

#+RESULTS:
: [[2, 2], [3, 3, 3], [4, 4, 4, 4]]
: [2, 2, 3, 3, 3, 4, 4, 4, 4]

ä¸Šè¿°ç¨‹å¼ä¸­ç¬¬[[(flat)]]è¡Œçš„æ•ˆæœèˆ‡ Array(nums.map(transform).joined())ç›¸åŒã€‚

*** compactMap
compactMap æ‰€æ˜ å°„å‡ºçš„å…ƒç´ çµæœéƒ½æ˜¯éå¯é¸ï¼ˆnon-nilï¼‰çš„å€¼ã€‚å› æ­¤ï¼Œç•¶ä½ çš„å¸Œæœ›æ˜ å°„çµæœçš„é™£åˆ—æ˜¯éå¯é¸é¡å‹çš„ï¼Œé‚£éº¼ä½¿ç”¨ compactMap æ˜¯ä¸€å€‹é©åˆçš„åšæ³•[fn:12]ã€‚
#+begin_src swift -r -n :results output :exports nil
let possibleNums = ["1", "2", "three", "///4///", "5"]
let mapped = possibleNums.map { str in Int(str) }
print(mapped)

let comMapped = possibleNums.compactMap { str in Int(str) }
print(comMapped)
#+end_src

#+RESULTS:
: [Optional(1), Optional(2), nil, nil, Optional(5)]
: [1, 2, 5]

*** Array of Struct
åŸºæœ¬çš„é™£åˆ—æä¾›äº†æˆ‘å€‘å„²å­˜å¤§æ‰¹è³‡æ–™çš„æ©Ÿåˆ¶ï¼Œç„¶è€Œï¼Œä¸Šè¿°æ‰€ç¤ºç¯„çš„ç°¡æ˜“å‹é™£åˆ—å½ˆæ€§ç•¥å«Œä¸è¶³ï¼Œå¦‚æœæˆ‘å€‘æƒ³è¦é–‹ç™¼ä¸€å€‹åœ–æ›¸ç›¸é—œçš„ appï¼Œä¸€é–‹å§‹æˆ‘å€‘è‡³å°‘éœ€è¦é€™æ¨£çš„é™£åˆ—ï¼š
#+begin_src swift -r -n :results output :exports nil
let book = ["Xçš„æ‚²åŠ‡", "åœ°ç„è—èª¿","æ±æ–¹åˆ—è»Šè¬€æ®ºæ¡ˆ","å…«ç™¾è¬ç¨®æ­»æ³•","è¡€å­—ç ”ç©¶"]
#+end_src
ç„¶è€Œï¼Œæ›¸æœ¬è‡³å°‘é‚„è¦æœ‰ä½œè€…å§ï¼Œæ–¼æ˜¯ï¼Œæˆ‘å€‘å¯èƒ½åˆæœƒåŠ å…¥ä½œè€…çš„é™£åˆ—:
#+begin_src swift -r -n :results output :exports nil
let book = ["Xçš„æ‚²åŠ‡", "åœ°ç„è—èª¿","æ±æ–¹åˆ—è»Šè¬€æ®ºæ¡ˆ","å…«ç™¾è¬ç¨®æ­»æ³•","è¡€å­—ç ”ç©¶"]
let author = ["è‰¾å‹’é‡Œï¼æ˜†æ©", "ææŸ¥å¾·", "é˜¿å˜‰èâ€§å…‹è‰çµ²è’‚","å‹å€«æ–¯.åœæ´›å…‹","æŸ¯å—é“çˆ¾"]
#+end_src
é€™ç¨®è¨­è¨ˆæ–¹å¼é›–ç„¶å¯è¡Œï¼Œä½†æ˜¯å»æœ‰å¹¾å€‹å•é¡Œï¼š
1. æ›¸åèˆ‡ä½œè€…å­˜åœ¨ä¸åŒé™£åˆ—ä¸­ï¼Œè€Œä¸”æ›¸åèˆ‡ä½œè€…ä¸¦ç„¡ç›´æ¥çš„é€£çµ
2. ç•¶æˆ‘å€‘è¦å†åŠ å…¥å‡ºç‰ˆå¹´ä»½ã€å‡ºç‰ˆç¤¾ã€å”®åƒ¹...ç­‰è³‡è¨Šæ™‚ï¼Œå°±æœƒç™¼ç¾éœ€è¦å¤ªå¤šçš„é™£åˆ—äº†

Struct å°±æ˜¯ä¸€ç¨®ååˆ†é©åˆç”¨ä¾†å„²å­˜ç›¸é—œè³‡æ–™çš„å‹åˆ¥ï¼Œä»¥ä¸Šè¿°æ›¸ç±è³‡æ–™ç‚ºä¾‹ï¼Œæˆ‘å€‘å¯ä»¥å…ˆå»ºç«‹ä¸€å€‹é€™æ¨£çš„ Struct:
#+begin_src swift -r -n :results output :exports nil
struct Book {
    var title: String
    var author: String
}
#+end_src
æ¥ä¸‹ä¾†ï¼Œå†å»ºç«‹ä¸€å€‹ä¸Šè¿° struct çš„é™£åˆ—ï¼Œå¦‚æ­¤ä¸€ä¾†ï¼Œä¸ç®¡æ›¸ç±è³‡æ–™å†å¦‚ä½•è¤‡é›œï¼Œæˆ‘å€‘éƒ½å¯ä»¥ä¸€å€‹é™£åˆ—ä¾†å„²å­˜ï¼š
#+begin_src swift -r -n :results output :exports nil
struct Book {
    var title: String
    var author: String
}
var books = [
    Book(title:"Xçš„æ‚²åŠ‡", author: "è‰¾å‹’é‡Œï¼æ˜†æ©"),
    Book(title:"åœ°ç„è—èª¿", author: "ææŸ¥å¾·"),
    Book(title:"æ±æ–¹åˆ—è»Šè¬€æ®ºæ¡ˆ", author: "é˜¿å˜‰èâ€§å…‹è‰çµ²è’‚"),
    Book(title:"å…«ç™¾è¬ç¨®æ­»æ³•", author: "å‹å€«æ–¯.åœæ´›å…‹"),
    Book(title:"è¡€å­—ç ”ç©¶", author: "æŸ¯å—é“çˆ¾")
]
// å­˜å–é™£åˆ—ä¸­structçš„æ–¹å¼
print(books[1].title)
print(books[1].author)
#+end_src

#+RESULTS:
: åœ°ç„è—èª¿
: ææŸ¥å¾·

** é›†åˆï¼ˆSetsï¼‰
é›†åˆï¼ˆSetï¼‰æ˜¯ Swift é›†åˆé¡å‹ï¼ˆcollection typesï¼‰ä¹‹ä¸€ï¼Œé›†åˆç”¨ä¾†å­˜å„²é¡å‹ç›¸åŒä¸”æ²’æœ‰ç¢ºå®šé †åºå”¯ä¸€çš„å€¼ã€‚

*** å®£å‘Š
#+begin_src swift -r -n :results output :exports both
var letrers = Set<Character>()
#+end_src

*** å­˜å–é›†åˆ
#+begin_src swift -r -n :results output :exports both
var letters = Set<Character>()
print(letters.count)
letters.insert("a")
print(letters.isEmpty)
letters.insert("b")
letters.insert("c")
letters.insert("d")
letters.remove("c")
for item in letters {
    print("\(item)")
}
#+end_src

#+RESULTS:
: 0
: false
: a
: b
: d

*** äº¤é›†ã€è¯é›†
#+begin_src swift -r -n :results output :exports both
let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let primeNumbers: Set = [2, 3, 5, 7]

print(oddDigits.union(evenDigits))
print(oddDigits.union(evenDigits).sorted())
print(oddDigits.intersection(evenDigits).sorted())
print(oddDigits.subtracting(primeNumbers).sorted())
print(oddDigits.symmetricDifference(primeNumbers).sorted())
#+end_src

#+RESULTS:
: [4, 7, 6, 1, 2, 3, 5, 8, 9, 0]
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
: []
: [1, 9]
: [1, 2, 9]

*** å­¸ç¿’è³‡æº
- [[https://swift.gg/2019/07/09/Sets-in-Swift/][Swiftä¸­çš„é›†åˆ(Set)]]

** å­—å…¸ï¼ˆDictionariesï¼‰
å­—å…¸æ˜¯ä¸€ç¨®å„²å­˜å¤šå€‹ç›¸åŒå‹åˆ¥çš„å€¼çš„å®¹å™¨ã€‚æ¯å€‹å€¼ï¼ˆvalueï¼‰éƒ½é—œè¯å”¯ä¸€çš„éµï¼ˆkeyï¼‰ï¼Œéµä½œç‚ºå­—å…¸ä¸­çš„é€™å€‹å€¼è³‡æ–™çš„è­˜åˆ¥ç¬¦è™Ÿã€‚å’Œé™£åˆ—ä¸­çš„è³‡æ–™é …ä¸åŒï¼Œå­—å…¸ä¸­çš„è³‡æ–™é …ä¸¦æ²’æœ‰å…·é«”é †åºã€‚æˆ‘å€‘åœ¨éœ€è¦é€šéè­˜åˆ¥ç¬¦è™Ÿï¼ˆéµï¼‰å­˜å–è³‡æ–™çš„æ™‚å€™ä½¿ç”¨å­—å…¸ï¼Œé€™ç¨®æ–¹æ³•å¾ˆå¤§ç¨‹åº¦ä¸Šå’Œæˆ‘å€‘åœ¨ç¾å¯¦ä¸–ç•Œä¸­ä½¿ç”¨å­—å…¸æŸ¥å­—ç¾©çš„æ–¹æ³•ä¸€æ¨£[fn:4]ã€‚

*** å»ºç«‹å­—å…¸
#+begin_src swift -r -n :results output :exports both
var namesOfIntegers = [Int: String]()
// namesOfIntegers is an empty [Int: String] dictionary
namesOfIntegers[16] = "Sixteen"
print(namesOfIntegers)
#+end_src

#+RESULTS:
: [16: "Sixteen"]

ä¸€å€‹å­—å…¸å­—é¢é‡æ˜¯ä¸€å€‹å®šç¾©æ“æœ‰ä¸€å€‹æˆ–è€…å¤šå€‹éµå€¼å°çš„å­—å…¸é›†åˆçš„ç°¡å–®èªå¥ã€‚ä¸€å€‹éµå€¼å°æ˜¯ä¸€å€‹ key å’Œä¸€å€‹ value çš„çµåˆé«”ã€‚åœ¨å­—å…¸å­—é¢é‡ä¸­ï¼Œæ¯ä¸€å€‹éµå€¼å°çš„éµå’Œå€¼éƒ½ç”±å†’è™Ÿåˆ†å‰²ã€‚é€™äº›éµå€¼å°æ§‹æˆä¸€å€‹åˆ—è¡¨ï¼Œå…¶ä¸­é€™äº›éµå€¼å°ç”±æ–¹æ‹¬è™ŸåŒ…å«ä¸¦ä¸”ç”±é€—è™Ÿåˆ†å‰²ï¼š
#+begin_src swift -r -n :results output :exports both
[key 1: value 1, key 2: value 2, key 3: value 3]
#+end_src

*** å­˜å–å­—å…¸
#+begin_src swift -r -n :results output :exports both
var autherOfWriting: [String: String] = ["è€äººèˆ‡æµ·": "æµ·æ˜å¨", "ç•°é„‰äºº": "å¡è¬¬", "ç™¾å¹´å­¤å¯‚": "é¦¬å¥æ–¯", "æµªæ·˜æ²™": "æ±æ–¹ç™½"]
print(autherOfWriting)
print("ä¸€å…±æœ‰\(autherOfWriting.count)æœ¬æ›¸")
print(autherOfWriting.isEmpty)
autherOfWriting["é¼ ç–«"] = "å¡è¬¬"
for (writing, author) in autherOfWriting {
    print("\(writing)çš„ä½œè€…ç‚º\(author)")
}
#+end_src

#+RESULTS:
: ["æµªæ·˜æ²™": "æ±æ–¹ç™½", "ç™¾å¹´å­¤å¯‚": "é¦¬å¥æ–¯", "è€äººèˆ‡æµ·": "æµ·æ˜å¨", "ç•°é„‰äºº": "å¡è¬¬"]
: ä¸€å…±æœ‰ 4 æœ¬æ›¸
: false
: æµªæ·˜æ²™çš„ä½œè€…ç‚ºæ±æ–¹ç™½
: ç™¾å¹´å­¤å¯‚çš„ä½œè€…ç‚ºé¦¬å¥æ–¯
: è€äººèˆ‡æµ·çš„ä½œè€…ç‚ºæµ·æ˜å¨
: ç•°é„‰äººçš„ä½œè€…ç‚ºå¡è¬¬
: é¼ ç–«çš„ä½œè€…ç‚ºå¡è¬¬

* Functions
:PROPERTIES:
:CUSTOM_ID: function
:END:
Functions are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to â€œcallâ€ the function to perform its task when needed.

Swiftâ€™s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter. Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.

** Functions çš„å®šç¾©èˆ‡å‘¼å«
*** èªæ³•
#+begin_src swift -r -n :eval no
func name(arg1 param1: DataTyp, arg2 param2: DataType) -> returnValue DataType {
     your code here
     return returnValue
}
#+end_src

*** DEMO
#+begin_src swift -r -n :results output : exports both
func greet(person: String) -> String {
    let greeting = "Hello, " + person + "!"
    return greeting
}

print(greet(person: "Vanessa"))
print(greet(person: "James"))

#+end_src

#+RESULTS:
: Hello, Vanessa!
: Hello, James!

*** Functions çš„åƒæ•¸èˆ‡å‚³å›å€¼
Function å¯ä»¥æ²’æœ‰åƒæ•¸ï¼Œä¹Ÿå¯ä»¥æœ‰å¾ˆå¤šåƒæ•¸ï¼Œå¯ä»¥æ²’æœ‰å‚³å›å€¼ï¼Œä¹Ÿå¯ä»¥æœ‰å¾ˆå¤šå‚³å›å€¼(é€™é»èˆ‡ C/C++ä¸åŒ)
**** æ²’æœ‰åƒæ•¸
#+begin_src swift -r -n :eval no
func sayHelloWorld() -> String {
    return "hello, world"
}
print(sayHelloWorld())
#+end_src
**** æœ‰å¾ˆå¤šåƒæ•¸
#+begin_src swift -r -n :eval no
func greet(person: String, alreadyGreeted: Bool) -> String {
    if alreadyGreeted {
        return "Hello, " + person + " again."
    } else {
        return "Hello, " + person
    }
}
print(greet(person: "Tim", alreadyGreeted: true))
// Prints "Hello again, Tim!"
#+end_src

function çš„åƒæ•¸å¯ä»¥æœ‰å…©ç¨®åç¨±ï¼šinternal name èˆ‡ external nameï¼Œinternal ç”¨æ–¼ function å…§ï¼›external name æä¾›å¤–éƒ¨ç¨‹å¼å‘¼å« function ä½¿ç”¨ã€‚è‹¥ function æœ‰ä¸€å€‹ä»¥ä¸Šçš„åƒæ•¸ï¼Œå¯ä»¥çœç•¥ç¬¬ä¸€å€‹åƒæ•¸çš„åç¨±ï¼Œå¦‚ï¼š
#+begin_src swift -r -n :results output
func greet(_ person: String, hiAgain alreadyGreeted: Bool) -> String {
    if alreadyGreeted {
        return "Hello, " + person + " again."
    } else {
        return "Hello, " + person
    }
}
print(greet("Vanessa", hiAgain: true))
print(greet("James", hiAgain: false))
// Prints "Hello again, Tim!"

#+end_src

#+RESULTS:
: Hello, Vanessa again.
: Hello, James
**** æ²’æœ‰å‚³å›å€¼
#+begin_src swift -r -n :eval no
func greet(person: String) {
    print("Hello, \(person)!")
}
greet(person: "Dave")
#+end_src
**** æœ‰å¾ˆå¤šå‚³å›å€¼
#+begin_src swift -r -n :results output :exports both
func myDiv(dividend: Int, divisor: Int) -> (quotient: Int, remainder: Int) {
    return (dividend / divisor, dividend % divisor)
}

let results = myDiv(dividend: 10, divisor: 3)
print("å•†ï¼š\(results.quotient)ï¼Œé¤˜æ•¸ï¼š\(results.remainder)")
#+end_src

#+RESULTS:
: å•†ï¼š3ï¼Œé¤˜æ•¸ï¼š1

* Generics
:PROPERTIES:
:CUSTOM_ID: generics
:END:
ç•¶ä½¿ç”¨è€…"ä¸åœ¨ä¹"å…¶è³‡æ–™å‹åˆ¥æ™‚ä½¿ç”¨ï¼Œå…¸å‹çš„ä¾‹å­ç‚ºé™£åˆ—ï¼Œé™£åˆ—å¯ä»¥å„²å­˜å„å¼å„æ¨£å‹æ…‹çš„è³‡æ–™ï¼šInt, Double, String, Struct...

é™£åˆ—çš„å®šç¾©æ–¹å¼å¦‚ä¸‹
#+begin_src swift -r -n :eval no
strut Array<Element> {
    //....
    func append(_ element: Element) {...} (ref:arap)
}
#+end_src
ä¸Šè¿°ç¨‹å¼ç¬¬[[(arap)]]è¡Œ append çš„åƒæ•¸ Element å³ç‚ºä¸€"don't care"å‹åˆ¥ï¼Œä»£è¡¨<Element>è£¡å¯ä»¥å¡«ä¸Š Int, String, Struct...ã€‚å…¶æ­£å¼åç¨±ç‚º Type Parameterã€‚

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:
** Varietities of Types
- struct
- class
- protocol
- "Dont' Care" type (generics)
- enum
- functions

** Functions as Types
å¦‚åŒ Int æˆ– Doubleï¼Œfunction ä¹Ÿå¯ä»¥æ˜¯ä¸€ç¨® typeï¼Œå¦‚ï¼š
#+begin_src swift -r -n :eval no
var foo: (Double) -> Void
func doSomething(what: () ->)
#+end_src
ä¸Šè¿°ç¨‹å¼ä¸­ç¬¬ 1 è¡Œçš„ foo ç‚ºä¸€è®Šæ•¸ï¼Œå…¶å‹åˆ¥ç‚ºï¼šè¼¸å…¥ä¸€å°æ•¸è®Šæ•¸ã€ä¸å‚³å›å€¼ï¼Œç¬¬ 2 è¡Œ function ä¸­çš„åƒæ•¸ what çš„å‹åˆ¥ç‚ºä¸€å€‹æ²’æœ‰è¼¸å…¥ã€å‚³å› bool çš„è®Šæ•¸ã€‚

å¦‚ä¸‹ä¾‹ï¼š
#+begin_src swift -r -n :results output
func square(operand: Double) -> Double {
    return operand * operand
}

var operation = square (ref:fat)
let result1 = operation(4)
print(result1)

operation = abs
let result2 = operation(-3)
print(result2)
#+end_src

#+RESULTS:
: 16.0
: 3.0

ç¨‹å¼ä¸­çš„ç¬¬[[(fat)]]è¡Œä¸­ï¼Œä»¤ operation è®Šæ•¸ä¹‹å‹åˆ¥ç‚º square é€™å€‹ functionï¼Œæ–¼æ˜¯ operation å°±å¯ä»¥å¦‚ function èˆ¬é€²è¡Œè¨ˆç®—ï¼›ä¹Ÿå¯ä»¥ä»¤ operation ç‚ºå…§å»ºçš„ function(å¦‚ abs)

** Closures
åœ¨å°‡ function è¦–ç‚ºåƒæ•¸å‚³éæ™‚ï¼Œä¹Ÿå¯ä»¥æŠŠ function å…§å®¹ç›´æ¥å¯«å‡ºä¾†ï¼Œé€™ç¨® inlined function å°±ç¨±ç‚º closure
Closure(é—­åŒ…) å°±æ˜¯æ²¡æœ‰åå­—çš„functionï¼Œå¯ä»¥å°†å®ƒassignç»™variableæˆ–constantï¼Œä¹Ÿå¯ä»¥â€ç°ç”¨ç°å®šä¹‰â€ã€‚é‚£ä¹ˆæˆ‘ä»¬ä¸ºä»€ä¹ˆè¦ç”¨Closureè€Œä¸ç”¨functionå‘¢ï¼Ÿæ€ä¹ˆç”¨Closureå‘¢ï¼Ÿå¾€ä¸‹çœ‹ä½ å°±çŸ¥é“äº†ï¼
*** syntax
#+begin_src swift -r -n :results output :exports nil
import Foundation

var simpleClosure: (Int, Int) -> Int (ref:dec1)
simpleClosure = { (a: Int, b: Int) -> Int in (ref:dec2)
    return a + b
}
print(simpleClosure(3, 4))
#+end_src

#+RESULTS:
: 7
å› ç‚ºç¬¬[[(dec1)]]è¡Œå·²å®£å‘Šäº†åƒæ•¸èˆ‡return typeï¼Œæ•…ç¬¬[[(dec2)]]è¡Œä¹Ÿå¯ä»¥æ”¹å¯«æˆ
#+begin_src swift -r -n :results output :exports nil
import Foundation

var simpleClosure: (Int, Int) -> Int (ref:dec1)
simpleClosure = { (a, b) in
    return a + b
}
print(simpleClosure(3, 4))

#+end_src

#+RESULTS:
: 7
ä¹Ÿå¯å†ç°¡åŒ–ç‚º:
#+begin_src swift -r -n :results output :exports nil
import Foundation

var simpleClosure: (Int, Int) -> Int (ref:dec1)
simpleClosure = {
    return $0 + $1
}
print(simpleClosure(3, 4))
#+end_src

#+RESULTS:
: 7
*** closure as function parameter
#+begin_src swift -r -n :results output :exports nil
import Foundation

var simpleClosure: (Int, Int) -> Int (ref:dec1)
simpleClosure = {
    return $0 + $1
}

func operation(_ a: Int, _ b: Int, op: (Int, Int) -> Int) -> Int {
    return op(a, b)
}

print(operation(2, 3, op: simpleClosure))

#+end_src

#+RESULTS:
: 5

* Struct, Class, and Enum
:PROPERTIES:
:CUSTOM_ID: SW-Struct-Class-Enum
:END:
#+begin_verse
struct, class, and enum are fundamentally important concepts for every iOS developer. Itâ€™s difficult to imagine common iOS apps without them. [fn:5]
#+end_verse

Class å’Œ Struct æ˜¯ä¸€ç¨®å¤šåŠŸèƒ½ä¸”éˆæ´»çš„æ§‹é€ é«”ï¼Œä½œç‚ºç¨‹å¼ç¢¼ä¸­çš„æ§‹é€ åŸºç¤ã€‚ä½ å¯ä»¥ä½¿ç”¨èˆ‡å¸¸æ•¸ï¼Œè®Šæ•¸å’Œå‡½æ•¸å®Œå…¨ç›¸åŒçš„èªæ³•ä¾†å®šç¾©å±¬æ€§å’Œæ–¹æ³•ï¼Œä»¥ä¾¿ç‚º Class å’Œ Struct å¢åŠ åŠŸèƒ½[fn:6]ã€‚

| strudt                                    | class                                   |
| Value type                                | Reference type                          |
| Copied when passed or assigned            | Passed around via pointers              |
| Copy on write                             | Automatically reference counted         |
| Functional programming                    | Object-oriented programming             |
| No inheritance                            | Inheritance (single)                    |
| "Free" init initalizes ALL vars           | "Free" init initializes NO vars         |
| Mutability must be explicitly stated      | Always mutable                          |
| Your "go to" data structure               | Used in specific circumstances          |
| Everything you've seen so far is a struct | The ViewModel in MVVM is always a class |
|                                           |                                         |

- å¤§å¤šè®Šæ•¸å‡ç‚º struct(é™¤äº† View ä¹‹å¤–)ï¼Œå¦‚ arrays, dictionaries, Ints, Bools, Doubles,
- functional programming: foucs åœ¨è³‡æ–™çš„ functionality
- object-oriented programming: focus åœ¨å°‡è³‡æ–™èˆ‡å…¶ functionality å°è£(encapsulate)å…¥æŸå€‹ object
- single inheritance: åªèƒ½ç¹¼æ‰¿è‡ªä¸€å€‹ class
- æ”¯æ´ multiple inheritance çš„èªè¨€ï¼šC++, Common Lisp, Perl, Python, R, Raku, Tcl[fn:7].

** èªæ³•
#+begin_src swift -r -n :eval no
struct SomeStructure {
    // structure definition goes here
}
class SomeClass {
    // class definition goes here
}
#+end_src

** DEMO
*** å®£å‘Š
#+begin_src swift -r -n :eval no
struct Resolution {
    var width = 0
    var height = 0
}
class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}

#+end_src

*** Init
ç”¨æ–¼å»ºç«‹ stuct æˆ– classï¼Œç‚ºå…§éƒ¨è®Šæ•¸é€²è¡Œåˆå§‹åŒ–ã€‚
#+begin_src swift -r -n :eval no
struct DiceGme {
    init(numberOfDices: Int){
        // create a dice with that many dices
    }
}
#+end_src

*** Structure and Class Instances
The Resolution structure definition and the VideoMode class definition only describe what a Resolution or VideoMode will look like. They themselves donâ€™t describe a specific resolution or video mode. To do that, you need to create an instance of the structure or class.

#+begin_src swift -r -n :eval no
let someResolution = Resolution()
let someVideoMode = VideoMode()
#+end_src

*** Accessing Properties
You can access the properties of an instance using dot syntax. In dot syntax, you write the property name immediately after the instance name, separated by a period (.), without any spaces:

#+begin_src swift -r -n :eval no
print("The width of someResolution is \(someResolution.width)")
// Prints "The width of someResolution is 0"
print("The width of someVideoMode is \(someVideoMode.resolution.width)")
// Prints "The width of someVideoMode is 0"
#+end_src

You can also use dot syntax to assign a new value to a variable property:
#+begin_src swift -r -n :eval no
someVideoMode.resolution.width = 1280
print("The width of someVideoMode is now \(someVideoMode.resolution.width)")
// Prints "The width of someVideoMode is now 1280"
#+end_src

** Struct
*** stored propertieså’Œcomputed properties
#+begin_src swift -r -n :results output :exports nil
struct Person {
    let firstName: String
    let lastName: String
}

struct Employee {
    let identity: Person
    var jobTitle: String
    var salary: Double
}

let me = Person(firstName: "Letranger", lastName: "Yen")
var letranger = Employee(identity: me, jobTitle: "CEO", salary: 3000)

print(me.firstName)
print(letranger.identity)
print(letranger.jobTitle)
#+end_src

#+RESULTS:
: Letranger
: Person(firstName: "Letranger", lastName: "Yen")
: CEO

Personèˆ‡Employeeä¸‹çš„firstName, lastName, jobTitleéƒ½ç‚ºstored property,ä¹Ÿéƒ½å­˜äº†å€¼ï¼Œæœƒä½”ç”¨memoryï¼Œå¦ç«¹ç¨®propertiesç‚ºè¨ˆç®—æ‰€å¾—ï¼Œç¨±computed propertiesã€‚
#+begin_src swift -r -n :results output :exports nil
struct Person {
    let firstName: String
    let lastName: String
}

struct Employee {
    let identity: Person
    var jobTitle: String
    var salary: Double

    var tax: Double {
        return salary * 0.05
    }
}

let me = Person(firstName: "Letranger", lastName: "Yen")
var letranger = Employee(identity: me, jobTitle: "CEO", salary: 3000)

print(letranger.tax)
#+end_src

#+RESULTS:
: 150.0
*** type properties
computed propertyå’Œstored propertyéƒ½æ˜¯instanceçš„å±æ€§ï¼Œæ•°æ®ç±»å‹ä¹Ÿæœ‰è‡ªå·±çš„å±æ€§ï¼Œè¿™å°±æ˜¯type propertyã€‚ä¾‹å¦‚ï¼š
#+begin_src swift -r -n :results output :exports nil
struct Person {
    let firstName: String
    let lastName: String
}
struct Employee {
  static var location = "é«˜é›„"
  let identity: Person
  var jobTitle: String
  var salary: Double
}
print(Employee.location)
#+end_src

#+RESULTS:
: é«˜é›„

locationå‰é¢åŠ äº†staticï¼Œè¿™å°±æ„å‘³ç€locationæ˜¯Employeeè¿™ä¸ªç±»å‹çš„å±æ€§ï¼Œä¸ç”¨åˆ›å»ºinstanceå°±å¯ä»¥è¯»å–ã€‚åœ¨å®è·µä¸­æœ‰æ—¶å€™ä¼šå¾ˆæœ‰ç”¨ã€‚
*** property observers
store propertyæ˜¯æœ‰observerè§‚å¯Ÿè€…çš„ï¼ŒwillSetä¼šåœ¨å±æ€§å³å°†æ›´æ–°çš„æ—¶å€™æ‰§è¡Œï¼›didSetä¼šåœ¨å±æ€§åˆšæ›´æ–°å®Œçš„æ—¶å€™æ‰§è¡Œã€‚
#+begin_src swift -r -n :results output :exports nil
struct Person {
    let firstName: String
    let lastName: String
}

struct Employee {
    let identity: Person
    static var location = "é«˜é›„"
    var jobTitle: String
    var salary: Double {
        didSet {
            if salary >= oldValue * 2 {
                Employee.location = "åœ‹å¤–"
            }
        }
    }

    var tax: Double {
        return salary * 0.05
    }
}

let me = Person(firstName: "Letranger", lastName: "Yen")
var letranger = Employee(identity: me, jobTitle: "CEO", salary: 3000)

print(letranger.tax)
print(Employee.location)
letranger.salary = 10000
print(Employee.location)
#+end_src

#+RESULTS:
: 150.0
: é«˜é›„
: åœ‹å¤–
*** Structä¸­çš„methods
é¦–å…ˆå¦‚æœä¸€ä¸ªfuncå®šä¹‰åœ¨structçš„å¤–é¢ï¼Œé‚£ä»–å°±æ˜¯ä¸ªfunctionï¼Œå¦‚æœå®šä¹‰åœ¨structçš„é‡Œé¢é‚£ä»–å°±æ˜¯methodã€‚ä½†å› ä¸ºæˆ‘ä»¬å·²ç»æœ‰äº†computed property, æˆ‘ä»¬åœ¨éœ€è¦å¤§é‡è®¡ç®—æˆ–è€…éœ€è¦è¯»å†™æ•°æ®åº“çš„æ—¶å€™ç”¨methodsï¼Œå…¶ä»–æƒ…å†µä¸€èˆ¬ç”¨computed propertyå°±å¯ä»¥äº†ã€‚

#+begin_src swift -r -n :eval no
struct Birthday {
  var day: Int = 12
  var month: Int = 12
  var year: Double = 1999

  func myBirthday() {
  print("I've born in \(year).\(month).\(day)")
  }
}

struct Person {
  var firstName: String = "Abboskhon"
  var lastName: String = "Shukurullaev"
  var phoneNumber: String = 123456
  var emailAddress: String = "abbsh24@gmail.com"

  func myInfo() {
  print("My name is \(firstName) \(secondName). My phone number is \(phoneNumber) and email address is \(emailAddress)")
  }
}
#+end_src

*** Mutating methods
#+begin_verse
Structs have also got so-called mutating methods that play a role in updating the property values of a structure within an instance method. [fn:5]
#+end_verse
#+begin_src swift -r -n :eval no
struct Counter {
  var count: Int = 0

  mutating func increment() {
    count += 1
  }
  mutating func increment(by amount: Int) {
    count += amount
  }
  mutating func reset() {
    count = 0
  }
}
var counter = Counter()   //default is 0
counter.increment()       //becomes 1
counter.increment(by: 9)  //becomes 10
counter.reset()           //reset to 0
#+end_src

** Classes
#+begin_verse
Classes and structures are very similar, and both can be used to define properties and methods. [fn:5]
#+end_verse
#+begin_src swift -r -n :results output :exports nil
class Person {
  var firstName: String
  var lastName: String

  init(firstName: String, lastName: String) {
    self.firstName = firstName
    self.lastName = lastName
  }

  var fullName: String {
    return "\(firstName) \(lastName)"
  }
}

let me = Person(firstName: "Joshua", lastName: "Jiang")
print(me.fullName)
#+end_src

#+RESULTS:
: Joshua Jiang
*** Struct v.s. Class
**** init
ä¸åƒstructä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªinitè®©ä½ ç”¨ï¼Œä¸Šè¿°ä»£ç ä¸­çš„initæ˜¯å¿…é¡»è¦å†™çš„ï¼Œè€Œä¸”å’Œstructä¸€æ ·ï¼Œåœ¨initä¸­æ‰€æœ‰stored propertyï¼ˆä¸æ‡‚è¿™ä¸ªçš„å»çœ‹ä¸Šä¸€ç¯‡structå“ˆï¼‰éƒ½å¿…é¡»èµ‹åˆå§‹å€¼ã€‚
**** reference type v.s. value type
Structæ˜¯å€¼ç±»å‹ï¼Œclassæ˜¯å¼•ç”¨ç±»å‹ã€‚åˆ†åˆ«æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿ
#+begin_src swift -r -n :results output :exports nil
class Person {
  var firstName: String
  var lastName: String

  init(firstName: String, lastName: String) {
    self.firstName = firstName
    self.lastName = lastName
  }

  var fullName: String {
    return "\(firstName) \(lastName)"
  }
}

var me = Person(firstName: "Joshua", lastName: "Jiang")
var prince = me (ref:copy)
print("\(me.firstName), \(prince.firstName)") // Joshua, Joshua

me.firstName = "coolboy"
print("\(me.firstName), \(prince.firstName)") // coolboy, coolboy

#+end_src

#+RESULTS:
: Joshua, Joshua
: coolboy, coolboy
ä¸Šè¿°ç¨‹å¼ç¬¬[[(copy)]]è¡Œå°‡me assignçµ¦prince,å¹¶æ²¡æœ‰æ‹·è´æ•´ä¸ªinstanceç»™princeï¼Œè€Œæ˜¯æ‹·è´äº†æŒ‡å‘instanceçš„åœ°å€ï¼›æ‰€ä»¥å½“meçš„firstNameå˜äº†ï¼Œé‚£ä¹ˆprinceçš„è‡ªç„¶ä¹Ÿä¼šå˜ã€‚
**** åˆ¤å®šç›¸ç­‰or not
å½“ä½ æ¯”è¾ƒå€¼ç±»å‹æ—¶ï¼Œä¸ç®¡æ˜¯structè¿˜æ˜¯Intï¼Œç”¨==å³å¯
å½“ä½ æ¯”è¾ƒå¼•ç”¨ç±»å‹æ—¶ï¼Œéœ€è¦ç”¨===ï¼Œæ¯”è¾ƒçš„æ˜¯ä»–ä»¬æŒ‡å‘çš„åœ°å€æ˜¯å¦ç›¸åŒ
**** constant or variable
æˆ‘ä»¬çŸ¥é“å¦‚æœä½ æŠŠä¸€ä¸ªstructå¤åˆ¶ç»™constantçš„æ—¶å€™ï¼Œä½ æ˜¯ä¸èƒ½ä¿®æ”¹ä»–çš„å±æ€§çš„ï¼›ä½†classç¡®å¯ä»¥ï¼š
#+begin_src swift -r -n :results output :exports nil
class Person {
  var firstName: String
  var lastName: String

  init(firstName: String, lastName: String) {
    self.firstName = firstName
    self.lastName = lastName
  }

  var fullName: String {
    return "\(firstName) \(lastName)"
  }
}
struct Employee {
    var jobTitle: String
}
let employee = Employee(jobTitle: "CEO")
employee.jobTitle = "CTO" // error: cannot assign to property

let me = Person(firstName: "Letrange", lastName: "Yen")
me.firstName = "TNFSH" // it's OK
#+end_src

#+RESULTS:
**** å¦‚ä½•é€‰æ‹©ç”¨Classè¿˜æ˜¯Struct
Structæ˜¯ç”¨æ¥ä»£è¡¨å€¼çš„ï¼Œæ¯”å¦‚è·ç¦»ã€åç§°ä¹‹ç±»çš„ï¼Œç”¨çš„æ—¶å€™åˆ›å»ºä¸ç”¨çš„æ—¶å€™æ¯æ‰ï¼Œå¾ˆå¿«çš„è¿™ç§ï¼Œä½ è¦ç”¨structï¼›

Classä»£è¡¨ä¸€ä¸ªå¯¹è±¡ï¼Œåƒä¸€ä¸ªå­¦ç”Ÿæˆ–è€…ä¸€ä¸ªåŸå¸‚ä¹‹ç±»çš„ï¼Œé€šå¸¸æœ‰è¶…å¤šçš„å±æ€§ï¼Œä¸€èˆ¬é•¿æ—¶é—´åœ¨å†…å­˜é‡Œï¼Œä¸ä¼šéšä¾¿å°±æ¯æ‰ï¼Œè¿™æ—¶å€™ä½ å½“ç„¶è¦ç”¨class

*** Inheritance & Override methods and properties
#+begin_verse
The biggest difference that structs do not have is hierarchical relations. Classes can have parent classes, that are called superclass, and child classes, that are called subclasses. [fn:5]
#+end_verse
#+begin_src swift -r -n :eval no
class Animals {
    func animals() {
        print("Animals are mainly of 3 types: Land Animals, Sea animals, Air Animals")
    }
}

class LandAnimals: Animals {
    override func animals() {
        print("Land animals are cats, sheeps, horses.")
    }
}

class Cat: LandAnimals {
    override func animals() {
        print("I am a cat and I am a land animal.")
    }
}
#+end_src

** çµæ§‹è·Ÿé¡çš„æ¯”è¼ƒ (Comparing Structures and Classes) [fn:8]
*** åœ¨ Swift ä¸­çš„çµæ§‹èˆ‡é¡æœ‰è¨±å¤šç›¸åŒä¹‹è™•ï¼Œå…©è€…çš†èƒ½ï¼š
- å®šç¾©å±¬æ€§ä¾†å„²å­˜å€¼
- å®šç¾©æ–¹æ³•ä¾†æä¾›åŠŸèƒ½
- å®šç¾©ä¸‹æ¨™ä¾†æä¾›è¨ªå•ä»–å€‘ç”¨ä¸‹æ¨™èªæ³•çš„å€¼
- å®šç¾©åˆå§‹åŒ–å™¨ä¾†è¨­å®šä»–å€‘çš„åˆå§‹ç‹€æ…‹
- å¯è¢«æ“´å±•ä»¥æ“´å±•å…¶åŠŸèƒ½ï¼Œè¶…è¶Šé è¨­çš„å¯¦ç¾
- ç¬¦åˆå”è­°ä»¥æä¾›æŸç¨®æ¨™æº–åŠŸèƒ½
*** é¡å…·æœ‰çš„é™„åŠ åŠŸèƒ½ï¼Œä½†çµæ§‹æ²’æœ‰ï¼š
- ç¹¼æ‰¿ä½¿ä¸€å€‹é¡èƒ½å¤ ç¹¼æ‰¿å¦ä¸€å€‹çš„ç‰¹æ€§
- é¡å‹è½‰æ›ä½¿æˆ‘å€‘å¯ä»¥åœ¨é‹è¡Œæ™‚æª¢æŸ¥å’Œè§£é‡‹é¡å¯¦ä¾‹çš„é¡å‹
- ååˆå§‹åŒ–å™¨å…è¨±é¡çš„å¯¦ä¾‹é‡‹æ”¾å®ƒå·²åˆ†é…çš„ä»»ä½•è³‡æº
- å¼•ç”¨è¨ˆæ•¸å…è¨±å°é¡å¯¦ä¾‹çš„å¤šå€‹å¼•ç”¨
*** çµæ§‹å’Œåˆ—èˆ‰æ˜¯å€¼å‹åˆ¥ (Structures and Enumerations Are Value Types)
å€¼å‹åˆ¥æ˜¯ä¸€ç¨®å…¶å€¼åœ¨è¢«è³¦å€¼çµ¦è®Šæ•¸æˆ–å¸¸æ•¸æ™‚è¢«è¤‡è£½ï¼Œæˆ–è€…åœ¨å‚³éçµ¦å‡½æ•¸æ™‚è¢«è¤‡è£½ã€‚å¯¦éš›ä¸Šï¼ŒSwift çš„æ•´æ•¸ã€æµ®é»æ•¸ã€å¸ƒæ—å€¼ã€å­—ç¬¦ä¸²ã€æ•¸çµ„å’Œå­—å…¸ä¸­çš„æ‰€æœ‰åŸºæœ¬å‹åˆ¥éƒ½æ˜¯å€¼å‹åˆ¥ï¼Œä¸¦ä¸”åœ¨å¹•å¾Œå¯¦ç¾ç‚ºçµæ§‹ã€‚æ‰€æœ‰çµæ§‹å’Œåˆ—èˆ‰éƒ½æ˜¯ Swift ä¸­çš„å€¼å‹åˆ¥ã€‚é€™ä»£è¡¨è‘—æˆ‘å€‘å‰µå»ºçš„ä»»ä½•çµæ§‹å’Œåˆ—èˆ‰å¯¦ä¾‹ä»¥åŠå®ƒå€‘ä½œç‚ºå±¬æ€§çš„ä»»ä½•å€¼é¡å‹åœ¨ä»£ç¢¼ä¸­å‚³éæ™‚å§‹çµ‚æœƒè¢«è¤‡è£½ã€‚[fn:8]
**** ç¯„ä¾‹
#+begin_src swift -r -n :eval no
struct Resolution {
    var width = 0
    var height = 0
}

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd

cinema.width = 2048

print("cinema is now \(cinema.width) pixels wide")
// Prints "cinema is now 2048 pixels wide"

print("hd is still \(hd.width) pixels wide")
// Prints "hd is still 1920 pixels wide"
#+end_src
ç”±ä¸Šè¿°ä¾‹å­å¯çŸ¥ï¼Œç•¶ cinema è¢«è³¦äºˆ hd ç•¶å‰çš„å€¼ï¼Œå„²å­˜åœ¨ hd çš„å€¼è¢«è¤‡è£½åˆ°æ–° cinema çš„å¯¦ä¾‹ã€‚æœ€å¾Œçµæœå…©å€‹æ“æœ‰ç›¸åŒå€¼ä½†å®Œå…¨ä¸åŒçš„å¯¦ä¾‹ï¼Œæ‰€ä»¥ç•¶ä¿®æ”¹ cinema.width = 2048 çš„æ™‚å€™ï¼Œä¸¦ä¸æœƒå½±éŸ¿å„²å­˜åœ¨ hd ä¸­çš„ widthã€‚[fn:8]
#+CAPTION: Struct value type
#+LABEL:fig:Structure
#+name: fig:Structure
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/struct.png]]
*** é¡æ˜¯åƒè€ƒå‹åˆ¥ (Classes Are Reference Types)
ä¸åŒæ–¼å€¼å‹åˆ¥ï¼Œç•¶åƒè€ƒå‹åˆ¥è¢«æŒ‡å®šçµ¦ä¸€å€‹è®Šæ•¸æˆ–å¸¸æ•¸ï¼Œæˆ–æ˜¯å‚³éé€²ä¸€å€‹å‡½æ•¸çš„æ™‚å€™ï¼Œä¸¦ä¸æœƒè¢«è¤‡è£½ã€‚åƒè€ƒå‹åˆ¥éå‰¯æœ¬ï¼Œæ˜¯ä½¿ç”¨ç›¸åŒå­˜åœ¨çš„å¯¦ä¾‹ã€‚[fn:8]
**** ç¯„ä¾‹
#+begin_src swift -r -n :eval no
class VideoMode {
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}

let tenEighty = VideoMode()

tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0


let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0

print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")
// Prints "The frameRate property of tenEighty is now 30.0"
#+end_src
ç”±ä¸Šè¿°ä¾‹å­å¯çŸ¥ï¼Œç•¶ alsoTenEighty è¢«æŒ‡å®šç‚º tenEightyï¼Œä¸¦ä¸”ä¿®æ”¹ alsoTenEighty.frameRate = 30.0 æ™‚ï¼Œä¹Ÿæœƒæ›´å‹•åˆ° tenEighty.frameRate çš„å€¼ã€‚[fn:8]
#+CAPTION: Class Reference type
#+LABEL:fig:Class-1
#+name: fig:Class-1
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/class.png]]

** with v.s. without struct: Why you need struct
*** ç‹€æ³ä¸€: without struct
#+begin_src swift -r -n :eval no
//å­¸ç”Ÿ1è³‡æ–™
var st1-no = "S01"
var st1-name = "James"
var st1-english = 93
var st1-math = 90
//å­¸ç”Ÿ2è³‡æ–™
var st2-no = "S02"
var st2-name = "Vanessa"
var st2-english = 90
var st2-math = 99
#+end_src
*** ç‹€æ³äºŒ: with struct
#+begin_src swift -r -n :eval no
struct Student {
    var no: String?
    var name: String
    var english = 0.0
    var math = 0.0
}

let st1 = Studetn(no: "S01", name: "James", english: 93, math: 92)
let st2 = Studetn()
st2.no = "S02"
st2.name = "Vanessa"
st2.english = 90
st2.math =  99
#+end_src

** Inheritance
*** ä½¿ç”¨ inheritance çš„å„ªé»
**** ä¸ç”¨ inheritance
#+begin_src swift -r -n :results output :exports both
class Car {
    var topSpeed = 200
    func drive() {
        print("Driving at \(topSpeed)")
    }
}
class FutureCar {
    var topSpeed = 300
    func drive() {
        print("Driving at \(topSpeed)")
    }
    func autoDrive() {
        print("Auto-driving")
    }
}
let myRide = Car()
print(myRide.topSpeed)
myRide.drive()

let myNewRide = FutureCar()
myNewRide.drive()
myNewRide.autoDrive()
#+end_src

#+RESULTS:
: 200
: Driving at 200
: Driving at 300
: Auto-driving
**** ä½¿ç”¨ inheritance
#+begin_src swift -r -n :results output :exports both
class Car {
    var topSpeed = 200
    func drive() {
        print("Driving at \(topSpeed)")
    }
}
class FutureCar: Car {
    override func drive() {
        super.drive()
        print("and rockets boosting at 50")
    }

    func autoDrive() {
        print("Auto-driving")
    }
}
let myNewRide = FutureCar()
print(myNewRide.topSpeed)
myNewRide.drive()
#+end_src

#+RESULTS:
: 200
: Driving at 200
: and rockets boosting at 50

** Computer property
#+begin_src swift -r -n :results output :exports both
class Square {
    var edge = 0.0
    var area: Double {
        get {
            return edge*edge
        }
        set(newArea) {
            edge = newArea.squareRoot()
        }
    }
}

let square = Square()
square.edge = 10
print(square.area)
square.area = 36
print(square.edge)
#+end_src

#+RESULTS:
: 100.0
: 6.0

** Structures and Enumerations Are Value Types
#+begin_src swift -r -n :results output :exports both :file test.py
struct Resolution {
  var width = 0
  var height = 0
}

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
#+end_src

When cinema was given the current value of hd, the values stored in hd were copied into the new cinema instance. The end result was two completely separate instances that contained the same numeric values. However, because they are separate instances, setting the width of cinema to 2048 doesnâ€™t affect the width stored in hd, as shown in the figure below[fn:9]:

#+CAPTION: Value Types
#+LABEL:fig:vt
#+name: fig:vt
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/sharedStateStruct_2x.png]]

** Classes Are Reference Types
#+begin_src swift -r -n :results output :exports both :file test.py

struct Resolution {
  var width = 0
  var height = 0
}
class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}

let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0

let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
#+end_src

Because classes are reference types, tenEighty and alsoTenEighty actually both refer to the same VideoMode instance. Effectively, they are just two different names for the same single instance, as shown in the figure below[fn:9]:

#+CAPTION: Value Types
#+LABEL:fig:vt
#+name: fig:vt
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/sharedStateClass_2x.png]]

** Enumerations
#+begin_verse
Enumerations are different from structs and classes. Enum is a special Swift type that defines a common type for a group of related values. Then, enums can be interacted with other data types such as a switch, if statements, and others. [fn:5]
#+end_verse
å¾ Swift 3 é–‹å§‹ï¼Œæˆ‘å€‘çš„ enum å…§è¨­å®šçš„æƒ…å¢ƒå­—ä¸²è¦ä»¥å°å¯«å­—æ¯é–‹é ­ã€‚
#+begin_src swift -r -n :eval no
//1 representation of enum
enum DownloadStatus {
    case downloading
    case finished
    case failed
    case cancelled
}

var currentStatus = DownloadStatus.downloading

switch currentStatus {
case .downloading:
    print("Downloading...")

case .finished:
    print("Just finished the download...")

case .failed:
    print("Failed to download the file...")

case .cancelled:
    print("The download is cancelled...")
}
#+end_src

#+begin_verse
æ­¤æ™‚ï¼Œä½ å¯èƒ½æœƒæƒ³ï¼Œç‚ºä»€éº¼éœ€è¦ä½¿ç”¨ enum ä¾†å®šç¾©å¤šå€‹æƒ…æ³ï¼Œè€Œä¸é¸æ“‡å®£å‘Šä¸€å€‹åŒ…å«å››å€‹æƒ…å¢ƒé …ç›®çš„ arrayï¼Œå¦‚ä¸‹åœ–æ‰€ç¤º:

let downloadStatus = [â€œdownloadingâ€, â€œfinishedâ€, â€œfailedâ€, â€œcancelledâ€]
let currentStatus = downloadStatus[0]

ä½ å¯ä»¥é€™æ¨£åšæ²’éŒ¯ï¼Œä½†æ˜¯å¦‚æ­¤ä¸€ä¾†æœƒæœ‰å…©å€‹ç¼ºé»ï¼Œé¦–å…ˆï¼Œä½ å¯èƒ½æœƒä¸çŸ¥é“ downloadStatus[0]ä»£è¡¨ä»€éº¼ï¼Œé™¤éä½ å¼•ç”¨ downloadStatus arrayï¼Œè‹¥æ˜¯æ¯”è¼ƒ downloadStatus[0]èˆ‡ DownloadStatus.downloading é€™å…©ç¨®è¡¨é”æ–¹å¼ï¼Œå¾ˆæ˜é¡¯çš„æ˜¯å¾Œè€…çš„å¯è®€æ€§æ¯”è¼ƒé«˜ã€‚

å…¶æ¬¡ï¼Œå› ç‚º currentStatus æ˜¯ String é¡å‹ï¼Œè®Šé‡å¯ä»¥è¢«è³¦äºˆä»»ä½•å­—ç¬¦ä¸²å€¼ï¼Œç„¡æ³•å°‡å®ƒé™åˆ¶ç‚º â€œdownloadingâ€, â€œfinishedâ€, â€œfailedâ€ ä»¥åŠ â€œcancelledâ€ï¼Œé™¤éåŸ·è¡Œä¸€äº›é¡å¤–çš„é©—è­‰ã€‚åä¹‹ï¼Œå¦‚æœä½¿ç”¨ enumï¼Œæˆ‘å€‘å¯ä»¥å°‡ myDirection é™åˆ¶åœ¨ .downloadingã€.finishedã€.failed æˆ– .cancelled ç­‰å››ç¨®æƒ…å¢ƒä¹‹ä¸€ï¼Œä¸æœƒå‡ºç¾å…¶ä»–æ„æ–™ä¹‹å¤–çš„æƒ…æ³ã€‚ [fn:10]

#+end_verse
*** Raw Values
Swiftçš„enumå¯ä»¥åŠ raw valuesï¼Œåƒä¸Šè¿°ä¾‹å­ï¼Œæœ‰äº†raw valuesï¼Œæˆ‘ä»¬å®Œå…¨ä¸éœ€è¦getStatusè¿™ä¸ªfuncäº†ã€‚
#+begin_src swift -r -n :results output :exports nil
enum Status: String {
  case pending = "å®¡æ ¸ä¸­"
  case approved = "å®¡æ ¸é€šè¿‡"
  case failed = "å®¡æ ¸æœªé€šè¿‡"
}
print(Status.pending.rawValue) // å®¡æ ¸ä¸­
#+end_src

#+RESULTS:
: å®¡æ ¸ä¸­

a) å¦‚æœraw valueçš„ç±»å‹æ˜¯Intçš„è¯ï¼Œä½ è¦æ˜¯ä¸ç»™ä»–ä»¬èµ‹å€¼ï¼Œswiftä¼šè‡ªåŠ¨ä»0ä¸€ä¸ªä¸ªèµ‹å€¼ï¼›ä½ å¯ä»¥ç»™ç¬¬ä¸€ä¸ªèµ‹å€¼ä¸€ä¸ªintï¼Œé‚£ä¹ˆswiftä¹Ÿä¼šæŠŠåé¢é€æ¬¡åŠ 1ï¼›
b) åƒè¿™ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘æ²¡æœ‰èµ‹å€¼ï¼Œé‚£ä¹ˆpendingçš„rawValueå°±æ˜¯"pending"
c) ä½ è¿˜å¯ä»¥é€šè¿‡rawValueæ¥è·å¾—caseï¼Œæ¯”å¦‚let pending = Status(rawValue: "å®¡æ ¸ä¸­")ï¼Œä½†æ˜¯pendingä¼šæ˜¯ä¸ªoptionalä½ è¦æ³¨æ„
#+begin_src swift -r -n :results output :exports nil
enum Status: String {
  case pending
  case approved
  case failed(msg: String)
}

func review(_ name: String) -> Status {
  if name.count > 10 {
    return .failed(msg: "åå­—å¤ªé•¿äº†")
  }
  return .pending
}

print(review("dsafs")) // pending
review("dsafsdfsdfsd") // failed(msg: "åå­—å¤ªé•¿äº†")
#+end_src

#+RESULTS:
#+begin_example
<stdin>:4:8: error: enum with raw type cannot have cases with arguments
  case failed(msg: String)
       ^
<stdin>:1:14: note: declared raw type 'String' here
enum Status: String {
             ^
<stdin>:1:14: error: 'Status' declares raw type 'String', but does not conform to RawRepresentable and conformance could not be synthesized
enum Status: String {
             ^
Swift.RawRepresentable:2:20: note: protocol requires nested type 'RawValue'; do you want to add it?
    associatedtype RawValue
                   ^
<stdin>:15:1: warning: result of call to 'review' is unused
review("dsafsdfsdfsd") // failed(msg: "åå­—å¤ªé•¿äº†")
#+end_example

** çµæ§‹å’Œé¡ä¹‹é–“çš„é¸æ“‡ (Choosing Between Structures and Classes)
#+begin_verse
ç¸½çš„ä¾†èªªï¼Œç”¨ class ä¾†å®šç¾©è³‡æ–™ç‰©ä»¶çš„è©±ï¼Œå°±å¥½åƒæ˜¯åœ¨ç”¨é›²ç«¯å…±äº«æ–‡ä»¶ä¸€æ¨£ï¼šæ¯å€‹äººçš„è¢å¹•ä¸Šéƒ½æœƒæœ‰ä¸€ä»½æ–‡ä»¶å¯ä»¥ç·¨è¼¯ï¼Œä½†é€™å€‹æ–‡ä»¶ä¸¦æ²’æœ‰å­˜åœ¨é›»è…¦è£¡ï¼Œè€Œæ˜¯è·Ÿé›²ç«¯çš„ç‰ˆæœ¬é€£ç·šï¼Œæ‰€ä»¥æ‰€æœ‰çš„è®Šå‹•éƒ½æ˜¯ç›´æ¥åœ¨é›²ç«¯ç‰ˆæœ¬ä¸Šæ›´æ–°çš„ã€‚å¥½è™•æ˜¯æ–¹ä¾¿ï¼Œå£è™•æ˜¯èª°ä¿®æ”¹äº†ç”šéº¼æ±è¥¿ç¶“ç†ä¸æœƒçŸ¥é“ï¼ˆclass æœ¬èº«æ²’æœ‰å¸³è™ŸåŠŸèƒ½ï¼ï¼‰ã€‚

ç”¨ struct çš„è©±ï¼Œå‰‡æ˜¯åƒå‚³çµ±çš„é›¢ç·šæ–‡ä»¶æª”æ¡ˆä¸€æ¨£ã€‚ä¸€é–‹å§‹æ–‡ä»¶åªæœ‰ç¶“ç†æœ‰ï¼Œè€Œå¦‚æœä»–æƒ³è¦è®“æ‰‹ä¸‹å°ç¾å»ä¿®æ”¹æ–‡ä»¶çš„è©±ï¼Œä»–å°±éœ€è¦æ‹·è²ä¸€ä»½æª”æ¡ˆçµ¦å°ç¾ã€‚å°ç¾ä¿®æ”¹å®Œæª”æ¡ˆå¾Œï¼Œå¿…é ˆæŠŠå®ƒäº¤é‚„çµ¦ç¶“ç†ï¼Œç„¶å¾Œç¶“ç†å†æ±ºå®šè¦ä¸è¦ç”¨ä¿®æ”¹éçš„æª”æ¡ˆå–ä»£åŸæœ¬çš„æ–‡ä»¶ã€‚[fn:11]
#+end_verse
#+CAPTION: MVC
#+LABEL:fig:MVC
#+name: fig:MVC
#+ATTR_LATEX: :width 400
#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:images/mvc-1.png]]
- åœ¨ MVC æ¶æ§‹ä¸­ï¼ŒModel åŒ…å«äº† Data Objects èˆ‡ Documentï¼Œå…¶ä¸­ Documents åŒ…å«æ‰€æœ‰çš„è³‡æ–™ç®¡ç†è€…å…ƒä»¶(å¦‚ Core Data çš„ NSManagedObjectContextï¼Œæˆ–æ˜¯ä»»ä½•è² è²¬ä¸‹è¼‰ã€ä¸Šå‚³è³‡æ–™ç‰©ä»¶çš„ç¶²è·¯å±¤å…ƒä»¶ï¼Œå¦‚è‡ªè¨‚çš„ NetworkManager)ã€‚
- Document æœ€å¥½æ˜¯ç”¨ class ä¾†å®šç¾©ï¼Œå› ç‚ºå®ƒè‚©è² äº†è¨±å¤šæºé€šçš„å·¥ä½œã€‚Data Objects å‰‡æ˜¯è³‡æ–™çš„ä»£è¡¨ï¼Œè¦ç”¨ class æˆ– struct ä¾†å®šç¾©éƒ½å¯ä»¥ã€‚
- ç”¨ class å®šç¾© Data Objects çš„è©±ï¼Œä»»ä½•è®Šå‹•åªè¦åŸ·è¡Œä¸€æ¬¡å°±å¯ä»¥äº†ï¼Œå› ç‚ºå®ƒçš„å¯¦é«”åªæœƒæœ‰ä¸€å€‹ã€‚ç„¶è€Œï¼Œç”¨ struct å®šç¾©çš„è©±ï¼Œå‰‡éœ€è¦å°‡è®Šå‹•æ‰‹å‹•å¥—ç”¨åˆ°æ–‡ä»¶æ‰€ç®¡ç†çš„é‚£ä»½å¯¦é«”ï¼Œå¥½è®“æ•´å€‹ app éƒ½èƒ½ä½¿ç”¨æœ€æ–°çš„è³‡æ–™ã€‚é€™é›–ç„¶å¯«èµ·ä¾†è¼ƒç‚ºå›‰å”†ï¼Œå»è®“é–±è®€èˆ‡ç¶­è­·æ›´ç‚ºç°¡å–®(å¯ä»¥ç¢ºå®šæ˜¯åœ¨å“ªè£¡è¢«è®Šæ›´è³‡æ–™)[fn:11]ã€‚
*** é¸æ“‡åŸå‰‡
- Choose Structures by Default
- Use Classes When You Need Objective-C Interoperability
- Use Classes When You Need to Control Identity
- Use Structures When You Don't Control Identity

* Pattern Matching
:PROPERTIES:
:CUSTOM_ID: PatternMatching
:END:
** if case
if caseä½ å¯ä»¥å½“æˆswitch(x) { case ...: }çš„ç®€åŒ–ç‰ˆ
#+begin_src swift -r -n :results output :exports nil
let point = (0, 1)
// if case
if case (0, 0) = point {
  print("0, 0") // ä¸ä¼šè¿è¡Œ
}
#+end_src

#+RESULTS:
** wildcard
#+begin_src swift -r -n :results output :exports nil
let point = (0, 3, 8)
switch point {
case (_, 0, _):
    print("åœ¨yè½´")
case (0, _, _):
    print("åœ¨xè½´")
case (_, _, 0):
    print("åœ¨zè½´")
case (_, _, _):
    print("ä¸åœ¨xyzè½´")
}
// åœ¨xè½´
#+end_src

#+RESULTS:
: åœ¨xè½´

** for case
foråé¢ä¹Ÿå¯ä»¥è·Ÿcaseï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥èµ‹å€¼
#+begin_src swift -r -n :results output :exports nil
let groupSizes = [1, 5, 4, 6, 2, 1, 3]
for case 1 in groupSizes {
  print("æˆ‘æ˜¯1") // 2æ¬¡
}

let names: [String?] = ["Joshua", nil, "Dog"]
for case let name? in names {
    print(name, terminator: " ")
}
// Joshua Dog

#+end_src

#+RESULTS:
: æˆ‘æ˜¯1
: æˆ‘æ˜¯1
: Joshua Dog
ä¸Šé¢çš„ä¾‹å­ç¬¬ä¸€ä¸ªåªæœ‰å€¼æ˜¯1çš„æ—¶å€™æ‰ä¼šprintï¼›ç¬¬äºŒä¸ªæ˜¯Optionalçš„ç‰¹æ®Šç”¨æ³•ï¼Œnameï¼Ÿä»£è¡¨ä¸æ˜¯nilçš„å€¼ï¼Œåªæœ‰åœ¨nameä¸æ˜¯nilçš„æ—¶å€™æ‰ä¼šè¢«printã€‚

** æ£€æŸ¥æ•°æ®ç±»å‹
#+begin_src swift -r -n :results output :exports nil
let array: [Any] = [15, "George", 2.0]

for element in array {
    switch element {
    case is String:
        print("\(element)æ˜¯String")
    case let num as Int:
        print("\(num)æ˜¯Int")
    default:
        print("\(element)æ˜¯ä¸ªå•¥ï¼Ÿï¼Ÿ")
    }
}
// 15æ˜¯Int
// Georgeæ˜¯String
// 2.0æ˜¯ä¸ªå•¥ï¼Ÿï¼Ÿ
#+end_src

#+RESULTS:
: 15æ˜¯Int
: Georgeæ˜¯String
: 2.0æ˜¯ä¸ªå•¥ï¼Ÿï¼Ÿ

** case...where...
caseåé¢è¿˜å¯ä»¥å†åŠ whereè¿›ä¸€æ­¥çš„ç­›é€‰ï¼š
#+begin_src swift -r -n :results output :exports nil
for number in 1...9 {
    switch number {
    case let x where x % 2 == 0:
        print("å¶æ•°")
    case _ where number % 2 > 0:
        print("å¥‡æ•°")
    default:
        print("QQ")
    }
}
#+end_src

#+RESULTS:
: å¥‡æ•°
: å¶æ•°
: å¥‡æ•°
: å¶æ•°
: å¥‡æ•°
: å¶æ•°
: å¥‡æ•°
: å¶æ•°
: å¥‡æ•°

** ifå¤šä¸ªæ¡ä»¶
#+begin_src swift -r -n :results output :exports nil
var a: Int? = 6
if let a = a, a > 5, case 1...9 = a {
    print("yes")
}
#+end_src

* Footnotes

[fn:13] [[https://www.hackingwithswift.com/example-code/language/how-to-create-an-array-by-repeating-an-item][How to create an array by repeating an item]]

[fn:12] [[https://medium.com/jeremy-xue-s-blog/swift-transforming-an-array-e2bcb4f4d67d][Swift â€” Transforming an Array]]

[fn:1] [[https://ithelp.ithome.com.tw/articles/10157433][[Swift] (1) - Swift ç°¡ä»‹ ]]

[fn:2] [[https://docs.swift.org/swift-book/LanguageGuide/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-XID_368][Properties]]

[fn:3] [[https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html][The Swift Programming Language Swift 5.3]]

[fn:4] [[https://tommy60703.gitbooks.io/swift-language-traditional-chinese/content/chapter2/04_Collection_Types.html][ã€ŠThe SwÂ­ift PrÂ­ogrammÂ­ing LaÂ­nguageÂ­ã€‹æ­£é«”ä¸­æ–‡ç‰ˆ]]

[fn:5] [[https://levelup.gitconnected.com/demystifying-struct-class-and-enum-in-swift-5-43dde089e96a][Demystifying Struct, Class, and Enum in Swift 5]]

[fn:6] [[https://ithelp.ithome.com.tw/articles/10195467][Day-15 Swift èªæ³•(11) - Class èˆ‡ Struct çš„æ„›æ¨äº¤ç¹” ]]

[fn:7] [[https://en.wikipedia.org/wiki/Multiple_inheritance][Multiple inheritance]]

[fn:8] [[https://ithelp.ithome.com.tw/articles/10220520][ Day 10: [Swift] çµæ§‹å’Œé¡ (Struct and Class) ]]

[fn:9] [[https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html][Structures and Classes]]

[fn:10] [[https://appcoda.com.tw/mastering-swift/][ç²¾é€šSwiftï¼šåˆ—èˆ‰ã€é–‰åŒ…ã€æ³›å‹ã€Protocolså’Œé«˜éšå‡½æ•¸]]

[fn:11] [[https://www.appcoda.com.tw/swift-class/][Swift Class vs Structï¼šè¨­è¨ˆ Model æ™‚ï¼Œè©²ç”¨ Struct é‚„æ˜¯ Class å‘¢ï¼Ÿ]]
